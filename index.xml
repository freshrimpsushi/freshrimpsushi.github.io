<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>생새우초밥집</title>
    <link>https://freshrimpsushi.github.io/</link>
    <description>Recent content on 생새우초밥집</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Tue, 12 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>git 자동 로그인하는 법</title>
      <link>https://freshrimpsushi.github.io/how-to-save-git-password/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/how-to-save-git-password/</guid>
      <description>커맨드 git config credential.helper store Credential 정보를 저장하면 된다.</description>
    </item>
    
    <item>
      <title>서열정렬에서의 치환행렬</title>
      <link>https://freshrimpsushi.github.io/substitution-matrix/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/substitution-matrix/</guid>
      <description>정의 서열정렬 점수를 매길 때 매치와 미스매치의 기준이 되는 행렬을 치환행렬이라 한다. 예시 거두절미하고 예시부터 보자. 줄리아에서는 BioAlignments라는 패키지가 나와있고 손쉽게 원하는 치환행렬을 불러들일 수 있다. DNA 분석에 자주 사용되는 EDNAFULL나 단백질 서열에 쓰이는 BLOSUM(BLOcks SUbstitution Matrix), PAM (Point Accepted Mutation) 행렬을 불러보면 다음과 같다. julia&amp;gt; using</description>
    </item>
    
    <item>
      <title>서열정렬 점수와 갭 페널티</title>
      <link>https://freshrimpsushi.github.io/sequence-alignment-score-and-gap-penalty/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/sequence-alignment-score-and-gap-penalty/</guid>
      <description>정의(서열정렬 점수) 레퍼런스 서열과 쿼리 서열이 주어져 있다고 하자. 서열정렬 점수란 두 서열을 비교했을 때 얼마나 일치하는지를 수치화하는 것과 그 방법을 말한다. 점수화는 다음과 같은 사항들에 가중치를 주어 계산된다. 1. Match: 두 서열이 일치하는 횟수다. 2. Mismatch: 두 서열이 일치하지 않는 횟수다. 예로써 위와 같은 두 염기서열이 있다고 하자. 이때 서열정렬</description>
    </item>
    
    <item>
      <title>서열정렬이란?</title>
      <link>https://freshrimpsushi.github.io/what-is-sequence-alignment/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/what-is-sequence-alignment/</guid>
      <description>정의 염기서열 간의 유사도를 근거로 나열하는 것을 서열정렬이라 한다. 설명 1 생명정보공학에서 유전체의 길이는 무척 길기 때문에 이를 데이터화하는 것부터가 엄청난 일이다. 상상하기에는 우리도 중합효소처럼 DNA의 상류부터 하류까지 순서대로 읽으면서 저장하면 좋을 것 같지만, 현실적으로는 그렇게 할 수가 없기 때문에 조각으로 나눠진 짧은 염기서열</description>
    </item>
    
    <item>
      <title>라돈 변환의 유도와 성질</title>
      <link>https://freshrimpsushi.github.io/derivation-and-properties-of-radon-transform/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/derivation-and-properties-of-radon-transform/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>문자열의 편집 거리</title>
      <link>https://freshrimpsushi.github.io/edit-distance-of-strings/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/edit-distance-of-strings/</guid>
      <description>빌드업 편집 방법1 문자열에는 다음과 같이 네가지 작용이 있다. 1. 삽입: 문자열에 새로운 문자를 끼워넣는다. 2. 제거: 문자열에서 문자 하나를 없앤다. 3. 교체: 문자열에서 문자 하나를 다른 문자로 바꾼다. 4. 전치: 두 문자의 위치를 서로 바꾼다. 종류 편집 거리는 문자열간의 거리 함수로써 편집 방법을 허용하거나 금지함으로써 다음과 같은 타입들로 구분</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 유전체와 유전자</title>
      <link>https://freshrimpsushi.github.io/genome-and-gene-in-bioinformatics/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/genome-and-gene-in-bioinformatics/</guid>
      <description>정의 1. 한 개체의 염기서열을 모두 모은 것을 유전체라고 한다. 2. 유전체의 일부를 차지하는 구간으로, 유전 형질의 단위가 되는 것을 유전자라고 한다. 특히 진핵생물에서는 인트론과 엑손으로 이루어져있다. 설명 사실 genome에 대해 유전체라는 순화는 거의 쓰이지 않고, 게놈 혹은 지놈으로 부르는게 보통이다. 지놈과 유전자는, 특히 유전자는 생명공</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 인트론과 엑손</title>
      <link>https://freshrimpsushi.github.io/intron-and-exon-in-bioinformatics/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/intron-and-exon-in-bioinformatics/</guid>
      <description>정의 진핵 생물의 DNA에서 실제로 단백질의 합성에 관여하는 부분을 엑손, 그렇지 않은 부분을 인트론이라고 한다. 설명 원핵 생물과 진핵 생물은 세포핵에 핵막이 있냐 없느냐로 구분되지만, 생명정보공학의 관점에서 중요한 차이점은 센트럴 도그마에 의해 mRNA가 전사되고 난 뒤의 스플라이싱Splicing이라는 과정이 있느냐 없느냐다. 원핵 생물</description>
    </item>
    
    <item>
      <title>염기서열의 상류와 하류</title>
      <link>https://freshrimpsushi.github.io/upstream-and-downstream-of-nucleic-sequence/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/upstream-and-downstream-of-nucleic-sequence/</guid>
      <description>빌드업 1 염기서열의 방향은 위의 그림처럼 오탄당의 탄소 원자 위치에 따라 번호를 부여함으로써 나타낼 수 있다. RNA와 DNA는 구체적으로 3번 탄소 3&amp;rsquo;와 5번 탄소 5&amp;rsquo;가 **인산에스터 결합(Phosphodiester Bond)**을 형성함으로써 사슬 구조를 이룬다. 가령 네 개의 염기가 다음과 같이 탄소 위치</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 코돈과 아미노산, 유전 부호</title>
      <link>https://freshrimpsushi.github.io/codon-amino-acid-genetic-code/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/codon-amino-acid-genetic-code/</guid>
      <description>정의 1. DNA의 염기 3개를 순서쌍으로 묶은 단위를 트리플렛 코드Triplet Code라 한다. 2. 센트럴 도그마에 따라 전사된 mRNA의 트리플렛 코드를 코돈이라 한다. 3. 화학적으로 아미노기와 카복시기를 포함한 분자로, 단백질의 구성 단위를 아미노산이라 부른다. 4. 코돈의 순열에 따라 아미노산의 대응관계를 유전 부호라 한다. 설명 유전 부호</description>
    </item>
    
    <item>
      <title>분자생물학의 중심원리</title>
      <link>https://freshrimpsushi.github.io/central-dogma-of-molecular-biology/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/central-dogma-of-molecular-biology/</guid>
      <description>원리 분자생물학의 중심원리 혹은 센트럴 도그마란 유전 정보는 DNA에서 RNA로, RNA에서 단백질로 전달된다는 가설로써 다음과 같은 세 가지 현상으로 이루어져있다. 1. 복제: DNA는 스스로 복제된다. 2. 전사: DNA와 같은 정보를 담은 RNA가 만들어진다. 3. 번역: RNA의 정보에 따라 단백질이 합성된다. 설명 센트럴 도그마는 DNA의 이</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 주요 염기와 염기쌍</title>
      <link>https://freshrimpsushi.github.io/primary-base-and-base-pair-in-bioinformatcs/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/primary-base-and-base-pair-in-bioinformatcs/</guid>
      <description>정의 다음의 다섯가지 염기를 주요 염기라고 한다. 1. 퓨린 염기 : 아데닌Adenin $A$, 구아닌Guanine $G$ 2. 피리미딘 염기 : 사이토신Cytosine $C$, 티민Thymine $T$, 유라실Uracil $U$ 설명 티민은 DNA에서만 사용되며, 유라실은 RNA에서만 사용된다. 따라서 데이터에서 $T$ 와 $U$ 중 어느 것이 쓰이는지만 확인해도 DNA와 RNA</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 염기서열</title>
      <link>https://freshrimpsushi.github.io/nucleic-sequence-in-bioinformatics/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/nucleic-sequence-in-bioinformatics/</guid>
      <description>빌드업 1. 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 2. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화학식은 $H_{3}PO_{4}$이다. 3. 5개의 탄소 원자를 갖는 단당류를 오탄당Pentose이라 한다. 4. 유전 정보의 기본단위로써 기능하는 분자를 질소 염기Nitrog</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 DNA, RNA, 염색체</title>
      <link>https://freshrimpsushi.github.io/dna-rna-chromosome-in-bioinformatics/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/dna-rna-chromosome-in-bioinformatics/</guid>
      <description>빌드업 1. 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 2. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화학식은 $H_{3}PO_{4}$이다. 3. 5개의 탄소 원자를 갖는 단당류를 오탄당Pentose이라 한다. 4. 유전 정보의 기본단위로써 기능하는 분자를 질소 염기Nitrog</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 원핵 생물과 진핵 생물</title>
      <link>https://freshrimpsushi.github.io/prokaryotes-and-eukaryotes/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/prokaryotes-and-eukaryotes/</guid>
      <description>정의 1. 핵막이 없는 생물을 **원핵 생물^Prokaryotes^**이라 한다. 2. 핵막이 있는 핵으로 이루어진 생물을 **진핵 생물^Eukaryotes^**이라 한다. 설명 진핵 생물에서는 유전 물질을 지니는 부분인 **세포핵^Nucleus^**과 각종 대사가 일어나는 **세포질^Cytoplasm^**이 **핵막^Nu</description>
    </item>
    
    <item>
      <title>비파괴검사, 토모그래피, 팬텀이란</title>
      <link>https://freshrimpsushi.github.io/nondestructive-testing/</link>
      <pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/nondestructive-testing/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>컴프턴 카메라의 원리</title>
      <link>https://freshrimpsushi.github.io/principle-of-the-compton-camera/</link>
      <pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/principle-of-the-compton-camera/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>촬영의 원리, 라돈 변환</title>
      <link>https://freshrimpsushi.github.io/ct/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/ct/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://freshrimpsushi.github.io/greedy-algorithm/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/greedy-algorithm/</guid>
      <description>정의 그리디 알고리즘이란 어떤 선택을 할 때 그 순간만을 고려해서 가장 좋은 경우를 고르는 방법이다. 예시 그리드 알고리즘은 탐욕Greed이라는 이름대로 길게 보지 않고 그 순간만을 생각한다. 좋게 말하면 항상 최선을 다하는 것이지만, 크게 보았을 때 이는 현명하지 못할 수도 있다. 다음의 예시를 보자 : 왼쪽 0에서 시작해 오른쪽 1에 도착하는 경로를 찾는</description>
    </item>
    
    <item>
      <title>레벤슈타인 알고리즘</title>
      <link>https://freshrimpsushi.github.io/levensteins-algorithm/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/levensteins-algorithm/</guid>
      <description>알고리즘 문자열 $A,B$ 를 $A=[a_{i}]=(a_{1}, a_{2} , \cdots, a_{n})$ 과 $B=[b_{j}]=(b_{1}, b_{2} , \cdots, b_{m})$ 로 표현하자. **Step 1.** 행렬 $M_{(n+1) \times (m+1)} = [m_{x y }]$ 를 만들고 $M_{11} = 0$ 을 대입한다. **Step 2.** $m_{(i+1) 1} = i$ 그리고 $m_{ 1 (j+1)} = j$ 을 대입한다. **Step 3.** for $i = 1, 2, \cdots , n$ 그리고 $j=1,2, \cdots , m$ if $a_{i}==b_{j}$ $M_{i,j} = M_{(i-1)(j-1)}$ 을 대입한다. else $M_{i,j} = \min \left{ M_{(i-1)(j)}, M_{(i)(j-1)}, M_{(i-1)(j-1)}\right} + 1 $ 을 대입한다. **Step 4.** $A$,$B$ 의 최소 수정 거리는 $m_{nm}$ 이다. 설명 **편집 거리**란 두 문자열 간의 유사성</description>
    </item>
    
    <item>
      <title>기수 정렬</title>
      <link>https://freshrimpsushi.github.io/radix-sort/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/radix-sort/</guid>
      <description>알고리즘 기수 정렬 자리수가 $k$ 로 제한된 $n$ 개의 자연수로 이루어진 데이터가 주어져있다고 하자. 그러면 데이터는 다음의 알고리즘에 따라 정렬되며 그 시간 복잡도는 $O (n)$ 이다. $i = 1 , \cdots , k$ 번째 자리수들끼리 비교해서 정렬한다. 설명 기수 정렬은 자리수의 제한이 있기 때문에 부동소수점이 있는 데이터에 적용할 수는 없으나, 정렬할 때 데이터간의 비교를</description>
    </item>
    
    <item>
      <title>프로그래밍 패러다임</title>
      <link>https://freshrimpsushi.github.io/programming-paradigm/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/programming-paradigm/</guid>
      <description>정의 프로그래밍 패러다임이란 주어진 문제를 해결하는 프로그램을 작성할 때의 관점 내지 방법론을 말한다. 어떠한 패러다임에 알맞는 프로그래밍 언어는 그러한 프로그래밍 패러다임을 갖는다고 말하며, 대개의 언어는 하나의 패러다임을 갖는다. 여러 패러다임을 갖는 언어를 멀티 패러다임 언어라고 한다. 설명 언어가 하나의 패러다임을 갖는다는 것은 다른 패</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘 시간 복잡도의 하한</title>
      <link>https://freshrimpsushi.github.io/lower-bound-of-comparison-sort-algorithm/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/lower-bound-of-comparison-sort-algorithm/</guid>
      <description>정리 비교 정렬 알고리즘의 시간복잡도는 아무리 좋아도 $\Omega ( n \log n )$ 이다. 설명 알고리즘이 원래 신기한 것이지만, 삽입 정렬과 같은 효율적인 알고리즘도 퀵 정렬에 밀리는 것을 보면 그 이상의 알고리즘도 있지 않을까 궁금할 수밖에 없다. 다행인지 아닌지는 모르겠으나, 이 증명에 따라 그보다 효율적인 알고리즘을 생각할 필요는 없다. 물론 일반적인 비교 알고</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘들의 시간 복잡도</title>
      <link>https://freshrimpsushi.github.io/time-complexity-of-comparison-sort-algorithms/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/time-complexity-of-comparison-sort-algorithms/</guid>
      <description>시각화 $n$ 개의 데이터가 주어져 있을 때, 비교 정렬 알고리즘들의 시간 복잡도는 다음과 같다. [1] 버블 정렬 : $$\Theta ( n^2 ) \ O ( n^2 )$$ [2] 선택 정렬 : $$\Theta ( n^2 ) \ O ( n^2 )$$ [3] 삽입 정렬 : $$\Theta ( n^2 ) \ O ( n^2 )$$ [4] 힙 정렬 : $$\Theta ( n \log n ) \ O ( n \log n )$$ [5] 합병 정렬 : $$\Theta ( n \log n ) \ O ( n \log n )$$ [6] 퀵 정렬 : $$\Theta ( n \log n ) \ O ( n^2 )$$ 여기서 소개되는 알고리즘들이</description>
    </item>
    
    <item>
      <title>동적 프로그래밍</title>
      <link>https://freshrimpsushi.github.io/dynamic-programing/</link>
      <pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/dynamic-programing/</guid>
      <description>빌드업 문제를 풀 때, 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 최적 부분 구조Optimal Substructure를 가진다고 한다. 최적 부분 구조를 갖춘 문제의 예로써 가장 쉬운 것이 바로 피보나치 수를 구하는 것이다. $n$ 번째 피보나치 수는 $a_{n} = a_{n-1} + a_{n-2}$ 와 같이 구해지므로, 큰 문제 $a_{n}$ 에 작은 문제 $a_{n-1}$, $a_{n-2}$ 가 포함되어 있기 때문이다. 이</description>
    </item>
    
    <item>
      <title>재귀함수를 쓸 때 주의해야하는 이유</title>
      <link>https://freshrimpsushi.github.io/why-we-care-recursive-function/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/why-we-care-recursive-function/</guid>
      <description>예시 프로그래밍을 처음 배우면 그것이 어떤 언어든지 &amp;lsquo;재귀함수는 조심해서 써야한다&amp;rsquo;는 경고가 함께한다. 사실 재귀함수라는 게 그렇게 빈번하게 사용되는 테크닉이 아니기 때문에 그 이유는 설명하지 않는 경우가 많은데, 배우는 입장에선 이 좋은 걸 왜 꺼리는지 이해가 잘 되지 않을 수 있다. 예시를 통해 알아보자. def fibo1(n) : if n==1 or n==2</description>
    </item>
    
    <item>
      <title>시간복잡도와 공간복잡도</title>
      <link>https://freshrimpsushi.github.io/time-complexity-and-space-complexity/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/time-complexity-and-space-complexity/</guid>
      <description>정의 주어진 문제를 풀 때의 걸리는 시간을 시간복잡도, 메모리 소요를 공간복잡도라고 한다. 예시 점근적 표기법은 이들을 표현하는데에 굉장히 유용한 수단이 된다. 시간복잡도에 대한 예시를 살펴보자. (0) 상수 시간 : $O(1)$ $n$ 에 관계없이 끝낼 수 있는 알고리즘으로, 사실상 시간이 걸리지 않는 것이다. 가령 $\mathbb{x} = [4,3,8,-1,-9,0,5,7,2,6]$ 에서 세번째 원소를 찾는 알고리즘은 $\mathbb{x}$ 가 어떻게</description>
    </item>
    
    <item>
      <title>알고리즘의 비용에 대한 점근적 표기법</title>
      <link>https://freshrimpsushi.github.io/asymptotic-notation-big-o/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/asymptotic-notation-big-o/</guid>
      <description>노테이션 크기가 $n$ 인 데이터에 대해 알고리즘의 비용을 다음과 같이 나타낸다. 1. $O$ 표기법: $$ O(g(n)) := \left{ f(n) , | , \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \le c g(n) \right} $$ **2. $\Omega$ 표기법**: $$ \Omega (g(n)) := \left{ f(n) , | , \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \ge c g(n) \right} $$ **3. $\Theta$ 표기법**: $$ \Theta (g(n)) := O (g(n)) \cap \Omega (g(n)) $$ 설명 점근적 표기법은 알고리즘의 비용을 수리적으로 나타내는 것으로,</description>
    </item>
    
    <item>
      <title>멜린 변환</title>
      <link>https://freshrimpsushi.github.io/mellin-transform/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/mellin-transform/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>힐베르트 변환</title>
      <link>https://freshrimpsushi.github.io/hilbert-transform/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/hilbert-transform/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>라돈 역변환</title>
      <link>https://freshrimpsushi.github.io/inverse-radon-transform/</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/inverse-radon-transform/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>백 프로젝션 변환</title>
      <link>https://freshrimpsushi.github.io/back-projection-transform/</link>
      <pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/back-projection-transform/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>푸리에 슬라이스 정리</title>
      <link>https://freshrimpsushi.github.io/fourier-slice-theorem/</link>
      <pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/fourier-slice-theorem/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>라돈 변환의 정의와 성질</title>
      <link>https://freshrimpsushi.github.io/definition-and-property-of-radon-transform/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/definition-and-property-of-radon-transform/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>평면 위의 직선을 표현하는 방법</title>
      <link>https://freshrimpsushi.github.io/-no-english/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/-no-english/</guid>
      <description>평면위의 직선을 특정 짓는 방법은 여러가지가 있을테지만 직선의 기울기와 $y$절편을 이용하는 방법이 보편적이다. 중고등학생에게도 익숙할 만큼 쉬운 방법이기도 하다. 그림$(1)$과 같은 직선이 있다고 하자. 그러면 기울기$a$와 $y$절편 $b$ 이 두 정보만 알면 평면위의 직선을 나타낼 수 있다. $y=ax+b$라고 표현하거나 그림으로 그려</description>
    </item>
    
    <item>
      <title>베이즈 인자를 통한 가설검정</title>
      <link>https://freshrimpsushi.github.io/statistical-hypothesis-test-via-bayes-factor/</link>
      <pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/statistical-hypothesis-test-via-bayes-factor/</guid>
      <description>개요 고전적인 가설검정을 쓸 수 있게 되려면 기각역, 유의확률과 같은 개념에 대한 수학적인 이해를 포함해서 이를 직관적으로 받아들일 수 있을 정도의 통계학적 센스까지 갖추어야한다. 학부 1학년 교양 수준에서도 몇 시간이나 할애해가며 가르치고, 그래도 가설검정을 제대로 받아들이지 못하는 학생이 수두룩한 것도 당연한 일이다. 고등학교에서 배우는 통계</description>
    </item>
    
    <item>
      <title>최고사후밀도 신용구간</title>
      <link>https://freshrimpsushi.github.io/highst-posterior-density-credible-interval/</link>
      <pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/highst-posterior-density-credible-interval/</guid>
      <description>정의 모수공간 $\Theta$ 의 부분집합 $C \subset \Theta$ 가 유의수준 $\alpha$ 에 대해 $C : = \left\{ \theta \in \Theta , | , p ( \theta | y ) \ge k (\alpha) \right\} $ 를 자료 $y$ 가 주어졌을 때 $\theta$ 에 대한 $100(1 - \alpha) % $ 최고사후밀도 신용구간이라고 한다. 설명 여기서 $k(\alpha)$ 는 $p(\theta \in C | y ) \ge 1 - \alpha$ 를 만족하는 가장 큰 상수다. 수식과 말보다는 그림을 통해 보는게 훨씬 이해하기 좋다. 실제 계산에서도 위와 같이 $k$ 를 계속 바꿔</description>
    </item>
    
    <item>
      <title>신용구간과 신뢰구간의 차이</title>
      <link>https://freshrimpsushi.github.io/credible-interval-vs-confidence-interval/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/credible-interval-vs-confidence-interval/</guid>
      <description>요약 신용구간과 신뢰구간의 차이는 실로 베이지안과 프리퀀티스트의 차이라고 볼 수 있다. 신뢰구간(프리퀀티스트) : 모수는 고정된 상수고, 신뢰구간이 랜덤으로 구해진다. 신용구간(베이지안) : 모수도 분포를 가진 변수고, 신용구간도 사후분포로 구해진다. 신뢰구간 고전통계에서 모수 $\mu$ 에 대한 $95 %$ 신뢰구간 $[a , b]$ 이 의미하는 것은 같은 방법으</description>
    </item>
    
    <item>
      <title>신용구간</title>
      <link>https://freshrimpsushi.github.io/credible-interval/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/credible-interval/</guid>
      <description>정의 모수공간 $\Theta$ 의 부분집합 $C \subset \Theta$ 가 유의수준 $\alpha$ 에 대해 $P ( \theta \in C | y ) \ge 1 - \alpha$ 를 만족할 때, $C$ 를 자료 $y$ 가 주어졌을 때 $\theta$ 에 대한 $100(1 - \alpha) % $ 신용구간이라고 한다. 설명 베이지안에서의 구간추정이란 모수 $\theta$ 를 포함하는 확률이 높은 구간을 찾는 것이다. 이로써 찾아지는 &amp;lsquo;신용구간&amp;rsquo;이란 프리퀀티스트에게는 &amp;lsqu</description>
    </item>
    
    <item>
      <title>제프리 사전분포</title>
      <link>https://freshrimpsushi.github.io/jeffreys-prior/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/jeffreys-prior/</guid>
      <description>정의 자료의 분포 $p( y | \theta) $ 에 대해 $\pi ( \theta ) \propto I^{1/2} ( \theta )$ 를 제프리 사전분포Jeffreys Prior라고 한다. $I$ 는 피셔정보Fishser Information를 의미한다. $$ I ( \theta ) = E \left[ \left( \left. {{\partial \ln p (y | \theta) } \over {\partial \theta}} \right)^2 \right| \theta \right] = E \left[ \left. - {{\partial^2 \ln p (y | \theta) } \over { (\partial \theta )^2 }} \right| \theta \right] $$ 라플라스 사전분포 $\pi (\theta) \propto 1$ 는 모수 $\theta$ 의 사전분포로써는</description>
    </item>
    
    <item>
      <title>라플라스 사전분포</title>
      <link>https://freshrimpsushi.github.io/laplace-prior/</link>
      <pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/laplace-prior/</guid>
      <description>빌드업 모수에 대한 정보가 거의 없다면 구태여 복잡한 사전분포를 생각할 이유는 없다. 내년 모 대학의 통계학과 신입생의 성비를 추측해보라고 했을 때, 통계학과를 어느정도 아는 사람이라면 예년의 성비를 보고 어느정도 짐작을 하겠지만 전혀 관계도 없고 관심도 없는 사람이 이 질문을 들었을 땐 특별한 이유가 없는 한 50:50이라고 추측할 것이다. 어떤 주머니</description>
    </item>
    
    <item>
      <title>켤레사전분포</title>
      <link>https://freshrimpsushi.github.io/conjugate-prior/</link>
      <pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/conjugate-prior/</guid>
      <description>정의 사전분포와 사후분포가 동일한 분포족에 속하면 사전분포를 켤레사전분포라고 한다. 베이지안이란 본래 사전분포가 어떻게 되든 업데이트를 통해 모수를 찾아가는 것이긴 하지만, 모형에 대해 어느정도 아는 바가 있다면 적절한 사전분포를 사용함으로써 수학적 계산을 간단하게 하고 결과를 이해하기 쉽게 할 수 있다. 정리 [1] $\text{Bin} (n , \theta) $ 의 켤레사전분포는 $\theta</description>
    </item>
    
    <item>
      <title>라플라스 계승 법칙</title>
      <link>https://freshrimpsushi.github.io/laplaces-law-of-succession/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/laplaces-law-of-succession/</guid>
      <description>정리 이항모형 $\displaystyle p(y | \theta) = \pmatrix{ n \\ y} \theta^{y} (1- \theta)^{n-y}$ 의 사전분포가 균일분포 $U (0,1)$ 를 따르고 사후분포가 베타분포 $\beta (y+1 , n-y+1)$ 을 따라 $p( \theta | y ) \sim \theta^{y} (1- \theta)^{n-y} $ 이라고 하자. 그러면 이제까지 얻은 데이터 $y$ 에 대해 새로운 $\tilde{y}$ 가 $1$ 일 확률은 $$ p(\tilde{y} = 1| y) = {{y+1} \over {n+2}} $$ 프리퀀티스트의 관점으로 보았을 때 $\tilde{y} = 1$ 일 확률은 그 표본비율 $\displaystyle {{y} \over {n}}$ 에 가까울 것이다. 그런데 기본적으로 $n$</description>
    </item>
    
    <item>
      <title>베이지안 패러다임</title>
      <link>https://freshrimpsushi.github.io/bayesian-paradigm/</link>
      <pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/bayesian-paradigm/</guid>
      <description>빌드업 통계학이란 &amp;lsquo;모수를 파악하는 방법을 연구하는 학문&amp;rsquo;이라고 할 수 있다. 어떤 물리량을 측정하는 것처럼 공식이나 법칙을 통해 정확하게 모수를 추정할 수 있다면 더할나위 없지만, 현실적으로 그게 불가능하기 때문에 가정과 표본을 이용해 &amp;lsquo;모수로 예상되는 것&amp;rsquo;을 찾아낼 뿐이다. 우리나라 남성</description>
    </item>
    
    <item>
      <title>베이즈 정리로 보는 몬티홀 딜레마</title>
      <link>https://freshrimpsushi.github.io/monty-hall-dilemma/</link>
      <pubDate>Mon, 08 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/monty-hall-dilemma/</guid>
      <description>개요 알다시피 몬티홀 게임은 실제로 경품이 어디있든 관계 없이 선택을 바꾸는 것이 유리하다. 이것을 팩트로써 받아들이냐와 별개로 몬티홀 게임을 직관적으로 이해하지 못했거나 수식적인 표현이 서툰 사람들이 있다. 설명 편의상 본인이 플레이어고, 1번 문을 선택했다고 생각해보자. 문번호 사전확률 1 1/3 2 1/3 3 1/3 이 때 우리는 경품에 대한 어떤 정보도 없기에</description>
    </item>
    
    <item>
      <title>베이즈 정리 증명</title>
      <link>https://freshrimpsushi.github.io/proof-of-bayes-theorem/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/proof-of-bayes-theorem/</guid>
      <description>정리 표본공간 $S$ 와 사건 $A$ 에 대해서 ${S_1,S_2,&amp;hellip;,S_n}$ 가 $S$ 의 분할이면 $$ \displaystyle P(S_k|A)=\frac { P(S_k)P(A|S_k) }{ \sum _{ k=1 }^{ n }{ P(S_k)P(A|S_k) } } $$ 혹은 베이즈 법칙으로도 불리는 이 정리는 두개의 법칙만 쓰면 될 정도로 쉽게 증명할 수 있으나 그 응용은 어마어마하다. 이른바 베이지안 패러다임은 통계학 자체를 양분하는 사고방식으로써, 그 중요도는 몇 번을 강조해도 부족함이 없다. 우리가 알고 싶은 것은 위 식에서</description>
    </item>
    
  </channel>
</rss>
