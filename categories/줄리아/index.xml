<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>줄리아 on 생새우초밥집</title>
    <link>https://freshrimpsushi.github.io/categories/%EC%A4%84%EB%A6%AC%EC%95%84/</link>
    <description>Recent content in 줄리아 on 생새우초밥집</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Sun, 27 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/categories/%EC%A4%84%EB%A6%AC%EC%95%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>줄리아에서 움짤 찌는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-gif-animation-in-julia/</link>
      <pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-gif-animation-in-julia/</guid>
      <description>코드 원래 생새우초밥집에서는 이보다는 훨씬 자세한 설명을 추가하는 편이지만, 줄리아에서 움짤을 찌는 게 얼마나 쉬운지를 강조하기 위해 가능한한 짧게 설명하도록 하겠다. 위와 같은 랜덤 워크를 시뮬레이션하는 건 둘째치더라도, 위와 같이 움짤로 만드는 것은 언어에 따라 아주 어렵고 힘들 수 있다. 그러나 줄리아에서는 @animate 매크로와 gif() 함수를 통해 어마어마하</description>
    </item>
    
    <item>
      <title>줄리아에서 거리 행렬 계산하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-calculate-a-distance-matrix-in-julia/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-calculate-a-distance-matrix-in-julia/</guid>
      <description>개요 거리 행렬Distance Matrix 은 파티클 다이나믹스Particle Dynamics 및 무빙 에이전트Moving Agent 기반 시뮬레이션 등에 흔히 사용되나, 막상 찾아보면 딱 정리된 함수로는 없고 직접 계산하는 코드를 짜려면 막막한 게 보통이다. 줄리아에서는 pairwise() 와 Distances 패키지의 Euclidean() 함수를 사용해서 위와 같이 손쉽게 거리 행렬을 계산할 수 있다.1 dims 옵션을 통해 행과 열</description>
    </item>
    
    <item>
      <title>줄리아에서 빈 배열 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-empty-array-in-julia/</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-empty-array-in-julia/</guid>
      <description>코드 julia&amp;gt; empty = Array{Float64, 2}(undef, 3, 4) 3×4 Array{Float64,2}: 3.39519e-313 3.18299e-313 4.66839e-313 1.061e-313 4.03179e-313 5.51719e-313 1.6976e-313 4.24399e-314 2.97079e-313 4.66839e-313 7.00259e-313 5.0e-324 위의 코드를 실행시키면 빈 배열이 만들어진다. 간혹 1.76297e-315처럼 이상한 값이 들어가는 것처럼 보이기도 하지만 이는 0에 아주 가까운 값으로써 초기화엔 큰 문제가 없다. Array{X, Y}(undef, ...)는 자료형 X로 Y차원 배열을 자료형에 해당하는 미정값으로 사이즈 ...만큼 채운 배열이 된다</description>
    </item>
    
    <item>
      <title>리눅스에서 줄리아 최신 버전 설치하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-the-latest-version-julia-in-linux/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-the-latest-version-julia-in-linux/</guid>
      <description>본 포스트에서 줄리아 최신 버전은 v1.3.1이다. 가이드 Step 1. 줄리아 다운로드 Generic Linux Binaries for x86에서 자기 CPU의 비트에 맞는 파일을 다운로드 받는다. Step 2. 압축 해제 후 이동 압축을 해제한다. 줄리아가 저장되어 있을 위치로 폴더를 옮긴다. 본인이 원하는 곳 어디라도 상관 없는데, 해당 포스트에서는 /home/[유저이름]/julia-1.3</description>
    </item>
    
    <item>
      <title>줄리아에서 병렬처리 하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-parallel-processing-in-julia/</link>
      <pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-parallel-processing-in-julia/</guid>
      <description>코드 원래 생새우초밥집에는 상세한 설명을 포함하는데, 줄리아가 병렬처리를 얼마나 편하게 할 수 있는지 강조하기 위해 굳이 설명을 생략하려 한다. using Base.Threads for i in 1:10 println(i^2) end 위의 반복문을 병렬처리하고 싶다면 단지 포문 앞에 @threads만 붙이면 된다. @threads for i in 1:10 println(i^2) end 그래도 당부의 말을 한마디만 적는다면, 병렬처리라고 해서 모든 게 빨라지지는 않는다는</description>
    </item>
    
    <item>
      <title>줄리아의 강력한 편의 기능, 매크로</title>
      <link>https://freshrimpsushi.github.io/posts/macro-in-julia/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/macro-in-julia/</guid>
      <description>개요 매크로는 줄리아로 코딩할 때 편의를 주는 기능들로써, 스코프 앞에 두어 실행한다. 예를 들어 자신의 프로그램이 얼마나 많은 시간을 소비하는지 알고 싶다면 다음과 같이 작성하면 된다. @time for t in 1:10 foo() bar() end 예시 많은 종류가 있지만 다음의 매크로들이 특히 널리 쓰인다: @time : 뒤에 이어지는 함수나 스코프의 실행 시간을 측정해준다. 어떤 상황에서 어떻게 최적</description>
    </item>
    
    <item>
      <title>줄리아에서 파이프 오퍼레이터 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/pipe-operator-in-julia/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/pipe-operator-in-julia/</guid>
      <description>개요 줄리아는 데이터를 다루는데에서 강점을 내세우는만큼 파이프라인 연산자를 지원한다. 코드 julia&amp;gt; (1:5) .|&amp;gt; (x -&amp;gt; sqrt(x+2)) .|&amp;gt; sin |&amp;gt; minimum 0.4757718381527513 julia&amp;gt; minimum(sin.((x -&amp;gt; sqrt(x+2)).(1:5))) 0.4757718381527513 위의 예제 코드는 배열 $[1,2,3,4,5]$ 를 $\sqrt{x + 2}$ 에 넣어서 얻은 결과를 $\sin$ 에 넣은 후 그 중 작은 값을 얻는 코드로,위와 아래 코드는 완전히 같은 결과를 낸다. 파이프라인이 복잡한 코드를 작성하는 중에 얼마나 유용한지는 굳이 설명할 필요가 없</description>
    </item>
    
    <item>
      <title>줄리아에서의 람다식</title>
      <link>https://freshrimpsushi.github.io/posts/lambda-expression-in-julia/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/lambda-expression-in-julia/</guid>
      <description>개요 줄리아에서 람다식은 다음과 같이 정의된다. (x -&amp;gt; 3x^2 - 2x + 3)(1) 이는 익명함수 $\lambda : \mathbb{Z} \to \mathbb{Z}$ 를 다음과 같이 정의하고, 거기에 $1$ 을 대입해서 $4$ 라는 함수값을 얻은 것에 해당한다. $$ \lambda : x \mapsto ( 3 x^{2} - 2 x + 3 ) \\ \lambda(1) = 4 $$ 사실 람다식 자체는 줄리아의 특징이 아니라 매트랩과 파이썬을 비롯해 함수형 언어에 영향을 받았다면 거의 당연하게 지원하고, 줄리아</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지 불러오고 행렬로 변환 저장하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-read-and-save-an-image-convert-to-matrix-in-julia/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-read-and-save-an-image-convert-to-matrix-in-julia/</guid>
      <description>코드 using Images cd(&amp;quot;C:/Users/rmsms/OneDrive/examples&amp;quot;) pwd() example = load(&amp;quot;example.jpg&amp;quot;) typeof(example) size(example) gray1 = Gray.(example) typeof(gray1) size(gray1) M = convert(Array{Float64},gray1) typeof(M) size(M) colorview(Gray, M.^(1/2)) save(&amp;quot;rgb.png&amp;quot;, colorview(RGB, example)) save(&amp;quot;gray1.png&amp;quot;, colorview(Gray, gray1)) save(&amp;quot;gray2.png&amp;quot;, colorview(Gray, transpose(gray1))) save(&amp;quot;gray3.png&amp;quot;, colorview(Gray, M.^(1/2))) 예제 코드를 위에서부터 간략하게 이해해보자: cd() : Change Directory, 작업 경로를 원하는 곳으로 바꿔준다. pwd() : Print Working Directory, 작업 경로를 출력해준다. 예제를 그대로 따라해보고싶다면 위의 파일을 작업 경로에 다운로드 받고 파일 이름을 example.jpg로 수정하자. load() : 작업 경로 내</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지 크기 변경하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-resize-a-image-in-a-julia/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-resize-a-image-in-a-julia/</guid>
      <description>🚧 이 포스트는 아직 이관 작업이 완료되지 않았습니다 🚧 매트랩에서 이미지 크기 조정하는 방법Images 패키지의 imresize를 사용하면 된다. 함수 이름이 매트랩과 같다. imresize(X,ratio=a) : 배열 X를 a배만큼 조정한 이미지를 반환한다. 매트랩에서와는 다르게 냅다 비율만 적으면 안되고 반드시 ratio=a와 같이 적어야한다.imresize(X,</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지배열을 회전하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-rotate-imagearraymatrix-in-julia/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-rotate-imagearraymatrix-in-julia/</guid>
      <description>🚧 이 포스트는 아직 이관 작업이 완료되지 않았습니다 🚧 매트랩에서 이미지 회전시키는 방법imrotate(X,$\theta$) : 배열 X를 $\theta$라디안 만큼 회전시킨다. 여기서 주의해야할 점은 각도의 단위가 도($^{\circ})$인 매트랩과 달리 각도의 단위가 라디안 이라는 것이다. 또한 매트랩과는 다르게 시계방향으로</description>
    </item>
    
    <item>
      <title>줄리아에서 2차원 배열 연산에 관한 함수들</title>
      <link>https://freshrimpsushi.github.io/posts/1460/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/1460/</guid>
      <description>🚧 이 포스트는 아직 이관 작업이 완료되지 않았습니다 🚧 $A=\begin{pmatrix} 1 &amp;amp; 2 &amp;amp; 1 \\ 0 &amp;amp; 3 &amp;amp; 0 \\ 2 &amp;amp; 3 &amp;amp; 4 \end{pmatrix}$라고 하자.**전치행렬 A=[1 2 1; 0 3 0; 2 3 4] transpose(A) A&amp;quot; 행렬의 원소가 실수라면 transpose()와 &amp;lsquo;는 같은 행렬을 반환하지만 자료형이 미묘하게 다르다. 그 이유는 &amp;lsquo;가 정확하게는 tran</description>
    </item>
    
    <item>
      <title>줄리아에서 배열을 히트맵 이미지로 출력 저장하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-plot-and-save-arrays-as-heatmap-images-in-julia/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-plot-and-save-arrays-as-heatmap-images-in-julia/</guid>
      <description>🚧 이 포스트는 아직 이관 작업이 완료되지 않았습니다 🚧 매트랩에서 Heatmap Plots 패키지의 heatmap 함수를 쓰면 2차원 배열을 히트맵 이미지로 출력할 수 있고, savefig 함수로 해당 이미지를 저장할 수 있다. @\_\_DIR\_\_은 줄리아 코드 파일의 위치를 알려주는 매크로이다. julia&amp;gt; cd(@\_\_DIR\_\_) julia&amp;gt; using Plots julia&amp;gt; A=[i for i=1:25] 25-element Array{Int64,1}: 1 2 3 4 ⋮ 23 24 25 julia&amp;gt; A=transpose(reshape(A, 5,5)) 5×5 LinearAlgebra.Transpose{Int64,Array{Int64,2}}: 1 2 3 4 5 6 7 8 9 10 11 12 13</description>
    </item>
    
    <item>
      <title>줄리아에서 집합 자료형과 연산자</title>
      <link>https://freshrimpsushi.github.io/posts/set-type-and-operator-in-julia/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/set-type-and-operator-in-julia/</guid>
      <description>개요 줄리아에서는 파이썬과 마찬가지로 집합 자료형을 지원한다. 원래 집합 자료형이 그렇듯 쓰는 사람은 요긴하게 쓰고 안 쓰는 사람은 일절 사용하지 않는데, 줄리아는 언어 설계 자체가 수학과 가까운만큼 집합의 개념과 연산이 잘 구현되어 있어 반드시 알아두는 게 좋다. 기존의 언어, 특히 파이썬과 가장 다른 점은 유니코드 기호들도 코드의 일부로 사용할 수 있다</description>
    </item>
    
    <item>
      <title>줄리아에서 배열의 슬라이싱과 인덱싱</title>
      <link>https://freshrimpsushi.github.io/posts/slicing-and-indexing-in-julia/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/slicing-and-indexing-in-julia/</guid>
      <description>코드 줄리아는 R, 파이썬, 매트랩의 장점이 모두 섞여있는 언어다. 배열은 프로그래밍의 근간이 되는만큼 그 활용에서 여러 언어들의 흔적을 찾아볼 수 있다. 행렬 julia&amp;gt; M = [1. 2. ; 3. 4.] 2×2 Array{Float64,2}: 1.0 2.0 3.0 4.0 julia&amp;gt; size(M) (2, 2) julia&amp;gt; length(M) 4 행렬의 경우 매트랩의 문법과 거의 똑같이 정의하고 거의 똑같이 사용할 수 있다. size() 함수는 매트랩과 똑같이 쓰이고, 파이썬에서 numpy 패키지의 프로</description>
    </item>
    
    <item>
      <title>줄리아에서 배열을 열 방향으로 평행이동시키는 코드</title>
      <link>https://freshrimpsushi.github.io/posts/translation-transform-code-in-julia/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/translation-transform-code-in-julia/</guid>
      <description>🚧 이 포스트는 아직 이관 작업이 완료되지 않았습니다 🚧 function translation(X:: Array{Float64,2},s:: Int64) pixels=length(X[:,1]); X\_translation = zeros(pixels, pixels); if s&amp;gt;0 for j=s:pixels-1 X\_translation[:,j+1]=X[:,j+1-s]; end elseif s&amp;lt;0 for j=1:pixels+s X\_translation[:,j]=X[:,j-s] end else X\_translation=X; end return X\_translation end 실수 성분을 갖는 $n\times n$ 배열 $X$와 평행이동시킬 칸 $s$를 입력하면 오른쪽으로 $s$만큼 평행이동한 $n\times n$배열 $X_{\mathrm{translation}}$을 반환한다. $s&amp;gt;0$이면 오른쪽으로 $s$</description>
    </item>
    
    <item>
      <title>줄리아에서 벡터를 생성하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-generate-vector-in-julia/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-generate-vector-in-julia/</guid>
      <description>코드 julia&amp;gt; x1=[1 2 3] 1×3 Array{Int64,2}: 1 2 3 julia&amp;gt; x2=[1, 2, 3] 3-element Array{Int64,1}: 1 2 3 julia&amp;gt; x3=[i for i in 1:3] 3-element Array{Int64,1}: 1 2 3 julia&amp;gt; x4=[i for i in 1:3:10] 4-element Array{Int64,1}: 1 4 7 10 julia&amp;gt; x5=[i for i in 1:3:11] 4-element Array{Int64,1}: 1 4 7 10 x1은 2차원 배열이다. 생겨먹은건 행벡터와 같기 때문에 성분 좌표를 1개만 입력하면 행벡터인 것 처럼 인식한다. x2, x3, x4, x5 는 1차원 배열이다. x=[i for i in n:m]과 같이 입력하면 $n$부터 $m$까지 간격이 $1$</description>
    </item>
    
    <item>
      <title>줄리아에서 패키지 설치하고 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-and-use-packages-in-julia/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-and-use-packages-in-julia/</guid>
      <description>방법 1 using LinearAlgebra using Pkg Pkg.add(&amp;quot;Plots&amp;quot;) Pkg.add(&amp;quot;Distributions&amp;quot;) using Plots 위의 코드는 LinearAlgebra 패키지와 Pkg 패키지를 불러오며, .add() 함수를 통해 Plots, Distribution 패키지를 설치하는 코드를 나타낸다. 패키지를 불러오는 키워드 using 은 마치 수학에서 어떤 정리나 논법을 사용할 때 쓰는 말과 닮았다. 패키지를 설치하는 것 자체는 파이썬보다는 R에 더 가깝고, 사용법은 파이썬과 더 비슷하다. R과 마찬가지로 패키지 이름을 큰따옴표</description>
    </item>
    
    <item>
      <title>줄리아의 타입과 애노테이션</title>
      <link>https://freshrimpsushi.github.io/posts/type-and-annotation-in-julia/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/type-and-annotation-in-julia/</guid>
      <description>코드 julia&amp;gt; typeof(0) Int64 julia&amp;gt; typeof(0.0) Float64 julia&amp;gt; typeof(0 == 0.0) Bool julia&amp;gt; typeof(Bool) DataType julia&amp;gt; typeof(NaN) Float64 julia&amp;gt; typeof(Inf) Float64 julia&amp;gt; typeof(&#39;O&#39;) Char julia&amp;gt; typeof(&amp;quot;Ohmygirl&amp;quot;) String julia&amp;gt; typeof(&amp;quot;O&amp;quot;) String 줄리아에는 온갖 타입들이 구현되어있다. $0$ 과 $0.0$ 은 같은 $0$ 이지만 다른 타입을 가지며, 보다시피 타입인 Bool조차 DataType이라는 타입을 갖는다. C 언어처럼 String은 Char의 배열이며, 위와 같이 큰 따옴표인가 작은 따옴표인가로 구분된다. julia&amp;gt; supertype(Int64) Signed julia&amp;gt; supertype(Signed) Integer</description>
    </item>
    
    <item>
      <title>줄리아 프로그래밍 언어</title>
      <link>https://freshrimpsushi.github.io/posts/what-is-julia-language/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/what-is-julia-language/</guid>
      <description>개요 줄리아 는 MIT에서 개발되어 2012년 공개된 프로그래밍 언어로써, 생산성이 높으면서도 속도가 높은 언어를 지향한다. C나 포트란에 준하는 속도를 내면서도 파이썬이나 R처럼 고수준의 문법을 갖추었으며, 그 외에도 여러 언어들의 장점을 취하고 있다. 2019년 11월 현재는 GPU가 급속도로 발전하면서 딥러닝이 유행을 선도하고 있어 조금</description>
    </item>
    
  </channel>
</rss>
