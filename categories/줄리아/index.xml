<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>줄리아 on 생새우초밥집</title>
    <link>https://freshrimpsushi.github.io/categories/%EC%A4%84%EB%A6%AC%EC%95%84/</link>
    <description>Recent content in 줄리아 on 생새우초밥집</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Sun, 27 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/categories/%EC%A4%84%EB%A6%AC%EC%95%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>줄리아에서 움짤 찌는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-gif-animation-in-julia/</link>
      <pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-gif-animation-in-julia/</guid>
      <description>원래 생새우초밥집에서는 이보다는 훨씬 자세한 설명을 추가하는 편이지만, 줄리아에서 움짤을 찌는 게 얼마나 쉬운지를 강조하기 위해 가능한한 짧게 설명하도록 하겠다.위와 같은 랜덤 워크를 시뮬레이션하는 건 둘째치더라도, 위와 같이 움짤로 만드는 것은 언어에 따라 아주 어렵고 힘들 수 있다. 그러나 줄리아에서는 @animate 매크로와 gif() 함수를 통해 어마어마하게 쉽</description>
    </item>
    
    <item>
      <title>줄리아에서 거리 행렬 계산하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-calculate-a-distance-matrix-in-julia/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-calculate-a-distance-matrix-in-julia/</guid>
      <description>using Distances coordinate = [2 3 4; 5 1 3; 1 7 5; 1 7 6; 2 4 3] pairwise(Euclidean(), coordinate; dims=1) pairwise(Euclidean(), coordinate; dims=2) 거리 행렬Distance Matrix 은 파티클 다이나믹스Particle Dynamics 및 무빙 에이전트Moving Agent 기반 시뮬레이션 등에 흔히 사용되나, 막상 찾아보면 딱 정리된 함수로는 없고 직접 계산하는 코드를 짜려면 막막한 게 보통이다.줄리아에서는 pairwise() 와 Distances 패키지의 Euclidean() 함수를 사용해서 위와 같이 손쉽</description>
    </item>
    
    <item>
      <title>줄리아에서 빈 배열 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-empty-array-in-julia/</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-empty-array-in-julia/</guid>
      <description>empty = Array{Float64, 2}(undef, 3, 4) 위의 코드를 실행시키면 다음과 같이 빈 배열이 만들어진다. 간혹 1.76297e-315처럼 이상한 값이 들어가는 것처럼 보이기도 하지만 이는 0에 아주 가까운 값으로써 초기화엔 큰 문제가 없다.Array{X, Y}(undef, &amp;hellip;)는 자료형 X으로 Y차원 배열을 자료형에 해당하는 미정값으로 사이즈 &amp;hellip;만큼 채운 배</description>
    </item>
    
    <item>
      <title>리눅스에서 줄리아 최신 버전 설치하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-the-latest-version-julia-in-linux/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-the-latest-version-julia-in-linux/</guid>
      <description>본 포스트에서 줄리아 최신 버전은 v1.3.1이다.Step 1. 줄리아 다운로드Generic Linux Binaries for x86에서 자기 CPU의 비트에 맞는 파일을 다운로드 받는다.Step 2. 압축 해제 후 이동압축을 해제한다.줄리아가 저장되어 있을 위치로 폴더를 옮긴다. 본인이 원하는 곳 어디라도 상관 없는데, 해당 포스트에서는 다음의 위치로 옮겨두었다 :/</description>
    </item>
    
    <item>
      <title>줄리아의 강력한 편의 기능 매크로</title>
      <link>https://freshrimpsushi.github.io/posts/macro-in-julia/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/macro-in-julia/</guid>
      <description>위 코드의 #1, #2, #3은 기능상으로 모두 같다.코드를 실행하면 위와 같이 소요시간을 알려주는데, 이 시간 차이에 큰 의미는 없으므로 당장은 매크로에 대해서만 살펴보도록 하자 :@time : 뒤에 이어지는 함수나 스코프의 실행 시간을 측정해준다. 어떤 상황에서 어떻게 최적화를 해야할지 막막할 때 일단 시간을 재보고 좋은 쪽을 고르기가 편해진다. 언어에 따라서는 시간</description>
    </item>
    
    <item>
      <title>줄리아에서 파이프 오퍼레이터 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/pipe-operator-in-julia/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/pipe-operator-in-julia/</guid>
      <description>R 에서 파이프 오퍼레이터 (1:5) .|&amp;gt; (x -&amp;gt; sqrt(x+2)) .|&amp;gt; sin |&amp;gt; minimum minimum(sin.((x -&amp;gt; sqrt(x+2)).(1:5))) 줄리아는 데이터를 다루는데에서 강점을 내세우는만큼 파이프라인 연산자를 지원한다. 위의 예제 코드는배열 $[1,2,3,4,5]$ 를$\sqrt{x + 2}$ 에 넣어서 얻은 결과를$\sin$ 에 넣은 후그 중 작은 값을 얻는 코드로,위와 아래 코드는 완전히 같은 결과를 낸다. 파이프라인이 복잡한 코드를 작성하는 중에 얼마</description>
    </item>
    
    <item>
      <title>줄리아에서 집합 자료형과 연산자</title>
      <link>https://freshrimpsushi.github.io/posts/set-type-and-operator-in-julia/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/set-type-and-operator-in-julia/</guid>
      <description>X = Set([1,2,3,1]); print(X) X[1] for i in X print(i) end if 1∈X print(&amp;quot;!&amp;quot;) else print(&amp;quot;?&amp;quot;) end if 0∈X print(&amp;quot;!&amp;quot;) else print(&amp;quot;?&amp;quot;) end if 0∉X print(&amp;quot;!&amp;quot;) else print(&amp;quot;?&amp;quot;) end if [1,2] ⊆ X print(&amp;quot;!&amp;quot;) else print(&amp;quot;?&amp;quot;) end if [0,1,2] ⊆ X print(&amp;quot;!&amp;quot;) else print(&amp;quot;?&amp;quot;) end Y = [&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,3] ∪(X,Y) ∩(X,Y) ∩(Y,X) setdiff(X,Y); X setdiff!(X,Y); X 줄리아에서는 파이썬과 마찬가지로 집합 자료형을 지원한다. 원래 집합 자료형이 그렇듯 쓰는 사람은 요긴하게 쓰고 안 쓰는 사람은 일절 사용하지 않는데, 줄리아는 언어 설계 자체</description>
    </item>
    
    <item>
      <title>줄리아에서 배열의 슬라이싱과 인덱싱</title>
      <link>https://freshrimpsushi.github.io/posts/slicing-and-indexing-in-julia/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/slicing-and-indexing-in-julia/</guid>
      <description>M = [1. 2. ; 3. 4.] size(M) length(M) x = [[1,2,3,4] for \_ in 1:4]; x y = [3,2,5,1,4] y[[4,2,1,5,3]] y[3:end] y[3:4] .= -1; y x = [1 2; 3 4] x[1,:] x[[1],:] x[1,1] = -1; x 줄리아는 R, 파이썬, 매트랩의 장점이 모두 섞여있는 언어다. 배열은 프로그래밍의 근간이 되는만큼 그 활용에서 여러 언어들의 흔적을 찾아볼 수 있다.행렬의 경우 매트랩의 문법과 거의 똑같이 정의하고 거의 똑같이 사용할 수 있다. size() 함수는 매트랩과 똑같이 쓰이고, 파</description>
    </item>
    
    <item>
      <title>줄리아에서 배열을 열 방향으로 평행이동시키는 코드</title>
      <link>https://freshrimpsushi.github.io/posts/translation-transform-code-in-julia/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/translation-transform-code-in-julia/</guid>
      <description>function translation(X:: Array{Float64,2},s:: Int64) pixels=length(X[:,1]); X\_translation = zeros(pixels, pixels); if s&amp;gt;0 for j=s:pixels-1 X\_translation[:,j+1]=X[:,j+1-s]; end elseif s&amp;lt;0 for j=1:pixels+s X\_translation[:,j]=X[:,j-s] end else X\_translation=X; end return X\_translation end 실수 성분을 갖는 $n\times n$ 배열 $X$와 평행이동시킬 칸 $s$를 입력하면 오른쪽으로 $s$만큼 평행이동한 $n\times n$배열 $X_{\mathrm{translation}}$을 반환한다. $s&amp;gt;0$이면 오른쪽으로 $s$칸 만큼 이동하고, $s&amp;lt;0$이면 왼쪽으로 $</description>
    </item>
    
    <item>
      <title>줄리아에서 벡터를 생성하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-generate-vector-in-julia/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-generate-vector-in-julia/</guid>
      <description>매트랩에서 등간격의 행벡터를 생성하는 방법 x1=[1 2 3] x2=[1, 2, 3] x3=[i for i in 1:3] x4=[i for i in 1:3:10] x5=[i for i in 1:3:11] $\mathsf{x1}$은 2차원 배열이다. 생겨먹은건 행벡터와 같기 때문에 성분 좌표를 1개만 입력하면 행벡터인 것 처럼 인식한다.$\mathsf{x2}$, $\mathsf{x3}$, $\mathsf{x4}$, $\mathsf{x5}$는 1차원 배열이다. x=[i for i in n:m]과 같이 입</description>
    </item>
    
    <item>
      <title>줄리아의 타입과 애노테이션</title>
      <link>https://freshrimpsushi.github.io/posts/type-and-annotation-in-julia/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/type-and-annotation-in-julia/</guid>
      <description>줄리아에는 온갖 타입들이 구현되어있다. $0$ 과 $0.0$ 은 같은 $0$ 이지만 다른 타입을 가지며, 보다시피 타입인 Bool조차 DataType이라는 타입을 갖는다. C 언어처럼 String은 Char의 배열이며, 위와 같이 큰 따옴표인가 작은 따옴표인가로 구분된다.위와 같이 supertype() 함수를 사용하면 타입의 상위 타입을 확인할 수 있다. 모든 타입은 Any 타입의 하</description>
    </item>
    
    <item>
      <title>줄리아 프로그래밍 언어</title>
      <link>https://freshrimpsushi.github.io/posts/what-is-julia-language/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/what-is-julia-language/</guid>
      <description>줄리아 는 MIT에서 개발되어 2012년 공개된 프로그래밍 언어로써, 생산성이 높으면서도 속도가 높은 언어를 지향한다. C나 포트란에 준하는 속도를 내면서도 파이썬이나 R처럼 고수준의 문법을 갖추었으며, 그 외에도 여러 언어들의 장점을 취하고 있다. 2019년 11월 현재는 GPU가 급속도로 발전하면서 딥러닝이 유행을 선도하고 있어 조금 뒤쳐</description>
    </item>
    
    <item>
      <title>줄리아에서 2차원 배열 연산에 관한 함수들</title>
      <link>https://freshrimpsushi.github.io/posts/1460/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/1460/</guid>
      <description>$A=\begin{pmatrix} 1 &amp;amp; 2 &amp;amp; 1 \\ 0 &amp;amp; 3 &amp;amp; 0 \\ 2 &amp;amp; 3 &amp;amp; 4 \end{pmatrix}$라고 하자.**전치행렬 A=[1 2 1; 0 3 0; 2 3 4] transpose(A) A&amp;quot; 행렬의 원소가 실수라면 transpose()와 &amp;lsquo;는 같은 행렬을 반환하지만 자료형이 미묘하게 다르다. 그 이유는 &amp;lsquo;가 정확하게는 transpose가 아니라 conjugate transpose이기 때문</description>
    </item>
    
    <item>
      <title>줄리아에서 배열을 히트맵 이미지로 출력 저장하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-plot-and-save-arrays-as-heatmap-images-in-julia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-plot-and-save-arrays-as-heatmap-images-in-julia/</guid>
      <description>매트랩에서 Heatmap Plots 패키지의 heatmap 함수를 쓰면 2차원 배열을 히트맵 이미지로 출력할 수 있고, savefig 함수로 해당 이미지를 저장할 수 있다. @\_\_DIR\_\_은 줄리아 코드 파일의 위치를 알려주는 매크로이다. julia&amp;gt; cd(@\_\_DIR\_\_) julia&amp;gt; using Plots julia&amp;gt; A=[i for i=1:25] 25-element Array{Int64,1}: 1 2 3 4 ⋮ 23 24 25 julia&amp;gt; A=transpose(reshape(A, 5,5)) 5×5 LinearAlgebra.Transpose{Int64,Array{Int64,2}}: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 julia&amp;gt; h1=heatmap(A) julia&amp;gt; savefig(h1, &amp;quot;heatmap1.png&amp;quot;) 그런데 배열 A</description>
    </item>
    
    <item>
      <title>줄리아에서 병렬처리 하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-parallel-processing-in-julia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-parallel-processing-in-julia/</guid>
      <description>using Base.Threads for i in 1:10 println(i^2) end @threads for i in 1:10 println(i^2) end 원래 생새우초밥집에는 상세한 설명을 포함하는데, 줄리아가 병렬처리를 얼마나 편하게 할 수 있는지 강조하기 위해 굳이 설명을 생략하려 한다.위의 반복문을 병렬처리하고 싶다면 단지 포문 앞에 @threads만 붙이면 된다.그래도 당부의 말을 한마디만 적는다면, 병렬처리라고 해서 모든 게 빨라지지는 않는다는 것이</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지 불러오고 행렬로 변환 저장하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-read-and-save-an-image-convert-to-matrix-in-julia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-read-and-save-an-image-convert-to-matrix-in-julia/</guid>
      <description>using Images cd(&amp;quot;C: \\\ Users \\\ rmsms \\\ OneDrive \\\ examples&amp;quot;) pwd() example = load(&amp;quot;example.jpg&amp;quot;) typeof(example) size(example) gray1 = Gray.(example) typeof(gray1) size(gray1) M = convert(Array{Float64},gray1) typeof(M) size(M) colorview(Gray, M.^(1/2)) save(&amp;quot;rgb.png&amp;quot;, colorview(RGB, example)) save(&amp;quot;gray1.png&amp;quot;, colorview(Gray, gray1)) save(&amp;quot;gray2.png&amp;quot;, colorview(Gray, transpose(gray1))) save(&amp;quot;gray3.png&amp;quot;, colorview(Gray, M.^(1/2))) 예제 코드를 위에서부터 간략하게 이해해보자 :cd() : Change Directory, 작업 경로를 원하는 곳으로 바꿔준다.pwd() : Print Working Directory, 작업 경로를 출력해준다. 예제를 그대로 따라해보고싶다면 위의 파일을 작업 경로에 다운로드 받고 파일 이름을 example.jpg로 수정하</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지 크기 변경하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-resize-a-image-in-a-julia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-resize-a-image-in-a-julia/</guid>
      <description>매트랩에서 이미지 크기 조정하는 방법Images 패키지의 imresize를 사용하면 된다. 함수 이름이 매트랩과 같다. imresize(X,ratio=a) : 배열 X를 a배만큼 조정한 이미지를 반환한다. 매트랩에서와는 다르게 냅다 비율만 적으면 안되고 반드시 ratio=a와 같이 적어야한다.imresize(X,m,n) : 배열 X를 m행,n열로 확대/축소한 이미</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지배열을 회전하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-rotate-imagearraymatrix-in-julia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-rotate-imagearraymatrix-in-julia/</guid>
      <description>매트랩에서 이미지 회전시키는 방법imrotate(X,$\theta$) : 배열 X를 $\theta$라디안 만큼 회전시킨다. 여기서 주의해야할 점은 각도의 단위가 도($^{\circ})$인 매트랩과 달리 각도의 단위가 라디안 이라는 것이다. 또한 매트랩과는 다르게 시계방향으로 회전 한다. 다른 변수를 입력하지 않을 경우 보간법은 b</description>
    </item>
    
    <item>
      <title>줄리아에서 패키지 설치하고 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-and-use-packages-in-julia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-and-use-packages-in-julia/</guid>
      <description>방법 1 using LinearAlgebra using Pkg Pkg.add(&amp;ldquo;Plots&amp;rdquo;) Pkg.add(&amp;ldquo;Distributions&amp;rdquo;) using Plots 위의 코드는 `LinearAlgebra` 패키지와 `Pkg` 패키지를 불러오며, `.add()` 함수를 통해 `Plots`, `Distribution` 패키지를 설치하는 코드를 나타낸다. 패키지를 불러오는 키워드 **using** 은 마치 수학에서 어떤 정리나 논법을 사용할 때 쓰는 말과 닮았다. 패키지를 설치하는 것 자체는 [파이썬보다](https://freshrimpsushi.github.io/pos</description>
    </item>
    
    <item>
      <title>줄리아의 람다식</title>
      <link>https://freshrimpsushi.github.io/posts/lambda-expression-in-julia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/lambda-expression-in-julia/</guid>
      <description>(x -&amp;gt; 3x^2 - 2x + 3)(1) # Example 1 example = rand(-20:20,10) sort(example, by=(x -&amp;gt; abs(x))) # Example 2 example = rand(1:3,10); println(example) uexample = sort(unique(example)) counts = map(x-&amp;gt;count(y-&amp;gt;x==y,example),uexample) 줄리아에서 람다식은 위와 같이 정의된다. 이는 익명함수 $\lambda : \mathbb{Z} \to \mathbb{Z}$ 를 다음과 같이 정의하고, 거기에 $1$ 을 대입해서 $4$ 라는 함수값을 얻은 것에 해당한다. $$ \lambda : x \mapsto ( 3 x^{2} - 2 x + 3 ) \\ \lambda(1) = 4 $$ 사실 람다식 자체는 줄리아의 특징이 아니라 매트랩과 파이썬을 비롯해 함수형 언어에 영</description>
    </item>
    
  </channel>
</rss>
