<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>줄리아 on 생새우초밥집</title>
    <link>https://freshrimpsushi.github.io/categories/%EC%A4%84%EB%A6%AC%EC%95%84/</link>
    <description>Recent content in 줄리아 on 생새우초밥집</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Sat, 15 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/categories/%EC%A4%84%EB%A6%AC%EC%95%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>줄리아에서 file.choose()처럼 대화창 열어서 파일 선택하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-choose-a-file-interactively-in-julia/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-choose-a-file-interactively-in-julia/</guid>
      <description>코드 1 using Gtk file_name = open_dialog(&amp;quot;파일 열기&amp;quot;) 첫번째 인수로 주어지는 문자열은 대화창의 타이틀이다. 실행하면 다음과 같이 &amp;lsquo;파일 열기&amp;rsquo;라는 대화창이 뜨는 것을 확인할 수 있다. 환경 OS: Windows julia: v1.6.0 https://discourse.julialang.org/t/choose-a-file-interactively/10910/3&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>줄리아에서 소수점 아래 특정 자리에서 반올림하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-round-function-in-julia/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-round-function-in-julia/</guid>
      <description>코드 사실 줄리아는 문자열 포맷 등이 아주 편리한 언어는 아니다. 콘솔에 출력할 때 문자열 자체 기능을 사용하는 방법도 있지만 round() 함수의 기본 옵션인 digits를 사용하는 게 편한 경우가 많을 것이다. julia&amp;gt; for k in 0:8 println(round(π, digits = k)) end 3.0 3.1 3.14 3.142 3.1416 3.14159 3.141593 3.1415927 3.14159265 환경 OS: Windows julia: v1.6.0</description>
    </item>
    
    <item>
      <title>줄리아에서 히트맵 색 범위 지정하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-set-min-max-values-in-a-heatmap/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-set-min-max-values-in-a-heatmap/</guid>
      <description>코드 1 히트맵을 그릴 때 수치에 따라 값의 스케일이 고정되지 않으면 곤란할 때가 있다. 기본 히트맵 함수에서 clim 옵션을 통해 색의 범위를 고정할 수 있다. using Plots cd(@__DIR__) heatmap(rand(4,4)); png(&amp;quot;1.png&amp;quot;) heatmap(rand(4,4), clim = (0,1)); png(&amp;quot;2.png&amp;quot;) 결과는 다음과 같다. 첫번째 히트맵은 범위가 없지만 두번째 히트맵은 0과 1로 범위가 고정되어있음을 확인할 수 있다. 한쪽만 제한 heatmap(rand(4,4), clim = (0,Inf)) heatmap(rand(4,4), clim = (-Inf,1)) 상한만 두거나 하한만 두고 싶으면</description>
    </item>
    
    <item>
      <title>줄리아에서 zfill() 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/what-is-zfill-in-julia/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/what-is-zfill-in-julia/</guid>
      <description>개요 1 파이썬에서 zfill()은 사실 문자열 클래스의 메소드로써, 좌측을 0으로 채워주는 기능을 가지고 있다. 줄리아에서는 이보다 범용적이고 쓰임새가 많은 내장 함수로써 lpad()를 제공한다. zfill()은 제로zero를 채운다fill는 의미고, lpad()는 왼쪽left의 패딩padding을 의미한다. 코드 julia&amp;gt; lpad(&amp;#34;12&amp;#34;, 4, &amp;#34;0&amp;#34;)</description>
    </item>
    
    <item>
      <title>줄리아에서 구조체 속성 확인하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-check-properties-of-structure-in-julia/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-check-properties-of-structure-in-julia/</guid>
      <description>코드 propertynames() 함수로 확인하면 된다.1 줄리아에는 클래스가 없고 구조체만 있으니2 이 함수로 리턴되는 모든 심볼들은 정확히 프로퍼티들만의 이름들이다. 다음은 Graphs 패키지에서 에르되시-레니 네트워크를 생성하고 노드의 수와 각 노드의 네이버후드를 확인하는 코드다. propertynames() 함수에 해당 네트워크를 집어넣어서 :ne와 fadjlist라는 프로퍼티가 심볼로써</description>
    </item>
    
    <item>
      <title>줄리아에서 도함수 구하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-calculus.jl-in-julia/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-calculus.jl-in-julia/</guid>
      <description>개요1 이름은 Calculus.jl인데 적분은 지원하지 않는다. 일변수 함수의 미분 도함수 derivative() $f : \R \to \R$의 도함수를 구해준다. derivative(f) 혹은 derivative(f, :x): 도함수 $f^{\prime}$을 리턴한다. derivative(f, a): 미분계수 $f^{\prime}(a)$를 리턴한다. julia&amp;gt; f(x) = 1 + 2x + 3x^2 f (generic function with 1 method) julia&amp;gt; g(x) = sin(x) g (generic function with 1 method) julia&amp;gt; derivative(f) #1 (generic function with 1 method) julia&amp;gt; derivative(f, 1) 7.99999999996842 julia&amp;gt; Df</description>
    </item>
    
    <item>
      <title>줄리아에서 특정 값으로 채운 배열 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-array-with-some-value-in-julia/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-array-with-some-value-in-julia/</guid>
      <description>코드 fill() 함수를 사용하면 된다. R에서의 rep() 함수와 비슷한 기능을 한다. julia&amp;gt; fill(1, 4) 4-element Vector{Int64}: 1 1 1 1 julia&amp;gt; fill(false, 2, 3) 2×3 Matrix{Bool}: 0 0 0 0 0 0 julia&amp;gt; fill(3.14, 2, 3, 2) 2×3×2 Array{Float64, 3}: [:, :, 1] = 3.14 3.14 3.14 3.14 3.14 3.14 [:, :, 2] = 3.14 3.14 3.14 3.14 3.14 3.14</description>
    </item>
    
    <item>
      <title>줄리아에서 shp 파일 읽는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-read-shp-file-in-julia/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-read-shp-file-in-julia/</guid>
      <description>코드 위와 같이 XsDB_주거인구_100M_TM.shp라는 shp 파일을 읽어들이는 코드는 다음과 같다. using Shapefile cd(@__DIR__) path = &amp;quot;XsDB_주거인구_100M_TM.shp&amp;quot; table = Shapefile.Table(path) using DataFrames df = DataFrame(table) 물론 파일을 읽어들이는 것만으로는 할 수 있는 것이 제한적이고, 데이터를 살펴보기 위해 데이터프레임으로 변환해줄 필요가 있다. 실행</description>
    </item>
    
    <item>
      <title>줄리아에서 소수점 아래 버리고 정수형으로 바꾸는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-cast-float-to-int-in-julia/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-cast-float-to-int-in-julia/</guid>
      <description>요약 trunc 함수의 첫번째 인수로써 Int 를 넣으면 된다. 코드 julia&amp;gt; @time for t in 1:10^8 Int64(ceil(t/1000)) end 0.189653 seconds julia&amp;gt; @time for t in 1:10^8 trunc(Int64, ceil(t/1000)) end 0.128472 seconds 두 반복문은 정확히 같은 기능을 하지만 1.5배 정도의 속도차이를 보인다. 위는 ceil로 소수점 아래를 버리고 Int64로 타입 캐스트를 했고, 아래는 trunc 함수의 자체 기능으로써 네이티브하게 정수를 리턴했기 때문에 더 빠르다. 다른 언어를 쓰던 사</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임의 열 이름 바꾸는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-change-column-name-of-dataframe-in-julia/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-change-column-name-of-dataframe-in-julia/</guid>
      <description>개요 rename!() 함수로 바꾸면 된다. 1 문자열의 리스트를 줘서 한번에 바꾸는 방법도 있고, 개별적으로 바꾸는 방법도 있다. 코드 using DataFrames df = DataFrame(rand(1:9, 10, 3), :auto) rename!(df, [&amp;quot;X&amp;quot;, &amp;quot;Y&amp;quot;, &amp;quot;Z&amp;quot;]) rename!(df, :X =&amp;gt; :A) 실행 시키면 가장 먼저 다음과 같은 데이터 프레임이 생성된다. julia&amp;gt; df = DataFrame(rand(1:9, 10, 3), :auto) 10×3 DataFrame Row │ x1 x2 x3 │ Int64 Int64 Int64 ─────┼───────────────────── 1 │ 2 3 6 2 │ 9 2</description>
    </item>
    
    <item>
      <title>줄리아에서 NearstNeighbors.jl로 빠르게 거리 계산하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-calculate-distance-using-nearstneibors.jl-in-julia/</link>
      <pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-calculate-distance-using-nearstneibors.jl-in-julia/</guid>
      <description>개요 $n$ 개의 좌표끼리 거리를 계산하는데, 행렬을 만들 필요까지는 없고 단순히 거리만 계산하면 되는 경우 다차원 탐색에 유리한 자료구조인 k-d 트리1를 사용해 속도를 높일 수 있다. NearestNeighbors.jl에 관련 알고리즘이 모두 구현되어 있으니 공식 깃허브 페이지를 참고하도록 하자. 속도 비교 pairwise() 함수로 거리행렬 계산에 최적화된 기법과</description>
    </item>
    
    <item>
      <title>줄리아에서 2차원 배열 csv 파일로 출력하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-export-2d-array-as-csv-file-in-julia/</link>
      <pubDate>Sat, 28 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-export-2d-array-as-csv-file-in-julia/</guid>
      <description>코드 using CSV, DataFrames A = rand(1:10, 10) B = zeros(10) AB = DataFrame(hcat(A,B), [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;]) CSV.write(&amp;quot;AB.csv&amp;quot;, AB) CSV 패키지의 write 함수를 통해 간단하게 2차원 배열을 출력할 수 있다. A, B는 1차원 배열로, hcat 함수로 묶어 데이터프레임으로 변환시켰다. 실행결과 julia&amp;gt; using CSV, DataFrames julia&amp;gt; A = rand(1:10, 10) 10-element Array{Int64,1}: 8 5 4 3 6 4 10 6 2 9 julia&amp;gt; B = zeros(10) 10-element Array{Float64,1}: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 julia&amp;gt; AB = DataFrame(hcat(A,B), [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;]) 10×2 DataFrame Row │ A B │ Float64 Float64 ─────┼────────</description>
    </item>
    
    <item>
      <title>줄리아 변수 이름에 그리스 문자, 첨자 쓰는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-greek-alphabet-and-subscript-in-julia-variable/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-greek-alphabet-and-subscript-in-julia-variable/</guid>
      <description>개요 줄리아에서는 변수 이름으로 유니코드(UTF-8)을 허용한다. 따라서 그리스 문자는 물론 윗첨자, 아랫첨자, 심지어는 한글이나 이모지까지 쓸 수 있다. 굳이 쓸 필요는 없지만 다음과 같이 기괴한 코드도 잘 돌아간다. julia&amp;gt; α₁ = 2 2 julia&amp;gt; α₂ = 1 1 julia&amp;gt; println(α₁ \ast\ α₂) 2 julia&amp;gt; 사인(t) = sin(t) 사인 (generic function with 1 method) julia&amp;gt; 😂 = 1:20 1:20 julia&amp;gt; 사인.(😂)</description>
    </item>
    
    <item>
      <title>줄리아에서 변수의 값을 편리하게 출력하는 법, 보간법</title>
      <link>https://freshrimpsushi.github.io/posts/interpolation-in-julia/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/interpolation-in-julia/</guid>
      <description>개요 줄리아의 편의 기능인 보간법Interpolation에 대해 설명한다. 인터폴레이션을 잘 이용하면 출력문을 쉽고 깔끔하게 쓸 수 있어 아주 편리하다. 수치해석학의 보간법과 관계는 없으나 단어의 의미는 상통한다. 코드 사용법은 아주 간단하다. 다음과 같이 문자열 안에서 변수 앞에 달러 기호 $를 붙이면 변수가 알아서 문자열처럼 읽힌다. 변수 그</description>
    </item>
    
    <item>
      <title>윈도 cmd, powershell에서 줄리아 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-julia-in-windows-cmd-or-powershell/</link>
      <pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-julia-in-windows-cmd-or-powershell/</guid>
      <description>가이드 Step 0. julia 1.6 이상 버전 설치 1.6 버전 이상부터는 인스톨 과정에서 환경변수에 넣을 수 있다. 표시된 옵션을 체크하고 설치하면 된다. 구버전을 사용하고 있다면 1.6 이상 버전을 설치하거나 아래의 지시를 따르면 된다. Step 1. 줄리아 설치 경로 확인 줄리아의 설치 경로를 확인한다. 별달리 건드린 게 없다면 다음 경로에 저장되어 있을 것이다. C:\Users\사</description>
    </item>
    
    <item>
      <title>줄리아에서의 메타 프로그래밍</title>
      <link>https://freshrimpsushi.github.io/posts/meta-programming-in-julia/</link>
      <pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/meta-programming-in-julia/</guid>
      <description>코드 1 줄리아에서는 메타 프로그래밍을 언어 차원에서 지원한다. 다음은 문자열을 코드 그 자체로 읽고 실행한 결과다. julia&amp;gt; text = &amp;#34;f(x) = 2x + 1; f(2)&amp;#34; &amp;#34;f(x) = 2x + 1; f(2)&amp;#34; julia&amp;gt; code = Meta.parse(text) :($(Expr(:toplevel, :(f(x) = begin #= none:1 =# 2x + 1 end), :(f(2))))) julia&amp;gt; eval(code) 5 Meta.Parse(): 이 함수를 통해 입력된 문자열을 표현식Expression으로 바꿔 반환한다. eval(): 표현식을 평가Evaluate한다. 위 예제코드에서는 $f(2)$ 가 실제</description>
    </item>
    
    <item>
      <title>줄리아에서 배열 Flatten 하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-flatten-array-in-julia/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-flatten-array-in-julia/</guid>
      <description>코드 vec() 함수를 쓰면 된다. julia&amp;gt; A = rand(0:9, 3,4) 3×4 Array{Int64,2}: 6 8 7 3 2 9 3 2 5 0 6 7 julia&amp;gt; vec(A) 12-element Array{Int64,1}: 6 2 5 8 9 0 7 3 6 3 2 7 사람이 생각하기로, 사람에게 보이기로는 똑같이 1차원 배열인데 타입상 2차원 배열이라 에러를 내는 경우도 이 방법으로 해결하면 된다. 다음 두 명령은 정확히 같은 배열로 보이지만 $\mathbb{N}^{10 \times 1}$ 행렬이냐 $\mathbb{N}^{10 }$ 벡터냐의 차이가 있다. julia&amp;gt; b = rand(0:9, 10,1) 10</description>
    </item>
    
    <item>
      <title>줄리아에서 거리 행렬 계산 최적화하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-optimize-calculating-distance-matrix/</link>
      <pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-optimize-calculating-distance-matrix/</guid>
      <description>결론 $n$ 개의 좌표끼리 거리를 계산한다고 하자. 모든 좌표끼리 계산할 필요가 없다면 그룹을 나누어 직사각 거리 행렬을 만들면 된다. 직사각 거리행렬은 pairwise() 함수로 쉽고 빠르게 계산할 수 있다. 속도 비교 가령 SIR 모델에 대해 무빙 에이전트 기반 시뮬레이션을 한다고 생각해보자. 원래의 시간복잡도는 $O \left( n^{2} \right)$ 이지만, $S$ 와 $I$ 그룹으로 나누어 계산하면 시간 복잡도</description>
    </item>
    
    <item>
      <title>줄리아에서 가중치를 주고 랜덤 샘플링 하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-random-sampling-with-weight-in-julia/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-random-sampling-with-weight-in-julia/</guid>
      <description>개요 줄리아에서 R에서의 sample()이나 파이썬 패키지 numpy의 random.choice()와 같은 역할을 하는 함수인 sample()과 Weights 함수의 사용법이다. 코드 1 using StatsBase items = 0:5 weights = 0:5 sample(items, Weights(weights)) # With replacement my_samps = sample(items, Weights(weights), 10) # Without replacement my_samps = sample(items, Weights(weights), 2, replace=false) 실행 결과 julia&amp;gt; using StatsBase julia&amp;gt; items = 0:5 0:5 julia&amp;gt; weights = 0:5 0:5 julia&amp;gt; sample(items, Weights(weights)) 5 julia&amp;gt; # With replacement julia&amp;gt; my_samps = sample(items, Weights(weights), 10) 10-element Array{Int64,1}: 4 3 2 1 3 3 5 5 2</description>
    </item>
    
    <item>
      <title>줄리아에서 문자와 정수의 이퀄 오퍼레이터 == 속도 비교</title>
      <link>https://freshrimpsushi.github.io/posts/speed-of-equal-operator-for-character-or-integer-in-julia/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/speed-of-equal-operator-for-character-or-integer-in-julia/</guid>
      <description>결론 배열의 각 원소를 Equal Operator ==를 통해 비교하면 정수보다 Char가 빠르다. 속도 비교 julia&amp;gt; integer = rand(1:5, N); print(typeof(integer)) Array{Int64,1} julia&amp;gt; character = rand([&amp;#39;S&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;I&amp;#39;,&amp;#39;R&amp;#39;,&amp;#39;D&amp;#39;], N); print(typeof(character)) Array{Char,1} julia&amp;gt; @time integer .== 1; 0.009222 seconds (6 allocations: 1.196 MiB) julia&amp;gt; @time character .== &amp;#39;S&amp;#39;; 0.005266 seconds (7 allocations: 1.196 MiB) 위의 코드는 정수와 문자로 이루어진 배열에서 각각 1과 S가 어디에 있는지 파악하는 프로그램이다. 정수냐 문자열이냐의 차이 빼고는 정확히 같으나, 시간 소요는 두배에 육박할만큼 큰</description>
    </item>
    
    <item>
      <title>줄리아 패키지 설치 시 \General\Registry.toml: No such file or directory 해결</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-fix-registry.toml-no-such-file-or-directory/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-fix-registry.toml-no-such-file-or-directory/</guid>
      <description>에러 ERROR: SystemError: opening file &amp;quot;C:\\Users\\rmsms\\.julia\\registries\\General\\Registry.toml&amp;quot;: No such file or directory 원인 사람 정말 열 받게 하는 에러인데, 말 그대로 해당 경로에 Registry.toml 파일이 없어서 일어나는 에러다. 해결법 C:\Users\사용자이름\.julia\registries\General 폴더를 삭제하고 다시 시도해본다. 그러면 위와 같이 Registry.toml 파일도 생기고 설치도 정상적으로 진행되는 것을 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>윈도에서 줄리아 최신 버전 설치하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-julia-in-windows/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-julia-in-windows/</guid>
      <description>가이드 Step 1. 줄리아 설치 줄리아 다운로드 페이지에서 설치 파일을 받고 실행한다. Step 2. vs code 설치 비주얼 스튜디오 코드 다운로드 페이지에서 설치파일을 받고 실행한다. Step 3. 줄리아 확장 설치 좌측 다섯번째 아이콘 혹은 Ctrl + Shift + X으로 Extensions을 연다. &amp;lsquo;julia&amp;rsquo;를 검색하면 최상단에 Julia Language Support가 뜬</description>
    </item>
    
    <item>
      <title>줄리아에서 16진법 RGB 코드 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-hex-rgb-code-in-julia/</link>
      <pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-hex-rgb-code-in-julia/</guid>
      <description>코드 줄리아에서는 rgb() 함수를 사용해서 0부터 1까지의 숫자로 색상을 만드는 법도 있지만 보통 색은 16진법으로 쓰게 편하기 때문에 함수보다 문자열로 바로 넣는 게 낫다. 대개의 언어는 문자열로 &amp;quot;#000000&amp;quot;를 쓰면 바로 검은색이 표현되지만, 줄리아의 경우엔 앞에 colorant를 붙여 명시해주어야한다. using Plots histogram(randn(100), color = colorant&amp;quot;#6666FF&amp;quot;)</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임과 2차원배열 간 변환 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-convert-between-dataframe-and-2-dimensional-array/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-convert-between-dataframe-and-2-dimensional-array/</guid>
      <description>코드 줄리아에서는 다음과 같이 convert() 함수를 통해 간단하게 데이터프레임과 2차원배열 사이를 오갈 수 있다. 이 함수는 물론 다른 자료형에 대해서도 유용하게 사용된다. data1 = rand(4,3) data2 = convert(DataFrame, data1) data3 = convert(Array, data2) 실행결과는 다음과 같다.</description>
    </item>
    
    <item>
      <title>줄리아에서 *.csv 파일 읽어들이는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-read-csv-files-in-julia/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-read-csv-files-in-julia/</guid>
      <description>가이드 사실 줄리아는 아직 데이터 입력 면에서 특출나게 편리한 언어는 아니다. 그래도 빠른 속도를 원한다면 파이썬이나 R, matlab보다 줄리아를 선택해야하는 순간이 올 수도 있을 것이다. 가령 위와 같이 E 드라이브 바로 밑에 있는 *.csv파일을 불러들인다고 하면 다음과 같이 입력하면 된다. using CSV data = CSV.read(&amp;quot;E:/example.csv&amp;quot;) 실행 결과를 보면 *.csv파일이 데이터프</description>
    </item>
    
    <item>
      <title>윈도우에서 줄리아 병렬연산 시 사용하는 쓰레드 수 바꾸는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-change-the-number-of-thread-in-windows/</link>
      <pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-change-the-number-of-thread-in-windows/</guid>
      <description>가이드 줄리아에서는 병렬 연산을 일상적으로 사용하기 때문에 경우에 따라서는 컴퓨터의 모든 소스를 계산에 집중할 필요가 있다. 이때 쓰레드 수를 바꾸는 방법은 여러가지가 있겠지만 가장 스태틱하고 편한 방법은 환경 변수를 편집하는 것이다. Step 1. 시스템 환경 변수 편집 윈도키 혹은 윈도+S를 눌러 &amp;lsquo;시스템 환경 변수 편집&amp;rsquo;을 찾는</description>
    </item>
    
    <item>
      <title>줄리아에서 실행되는 코드 파일의 위치 확인하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-get-the-directory-of-julia-code-file/</link>
      <pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-get-the-directory-of-julia-code-file/</guid>
      <description>가이드 줄리아를 사용하는 사람이라면 서버를 포함해서 여러 운영 체제나 여러 컴퓨터를 사용하는 것에 익숙할 가능성이 높다. 만약 파일 입출력이 있다면 개발환경이 달라질때마다 그 경로를 잡아주는 것이 무척 번거로울 수 있다. 이를 해결해주는 것이 바로 @__DIR__ 매크로다. 가령 다음과 같은 줄리아 코드 파일이 있다고 하자. 기본적으로 터미널에서 실행하면 pwd(</description>
    </item>
    
    <item>
      <title>리눅스에서 줄리아 병렬연산 시 사용하는 쓰레드 수 바꾸는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-change-the-number-of-thread-in-linux/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-change-the-number-of-thread-in-linux/</guid>
      <description>가이드 줄리아에서는 병렬 연산을 일상적으로 사용하기 때문에 경우에 따라서는 컴퓨터의 모든 소스를 계산에 집중할 필요가 있다. 이때 쓰레드 수를 바꾸는 방법은 여러가지가 있겠지만 가장 스태틱하고 편한 방법은 환경 변수를 편집하는 것이다. Step 1. 시스템 환경 변수 편집 Ctrl + Alt + T 를 눌러 터미널을 열고 gedit ~/.bashrc를 입력한다. 그러면 다음과 같이</description>
    </item>
    
    <item>
      <title>줄리아에서 합성함수 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-function-composition-in-julia/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-function-composition-in-julia/</guid>
      <description>코드 julia&amp;gt; f(x) = 2x + 1 f (generic function with 1 method) julia&amp;gt; g(x) = x^2 g (generic function with 1 method) julia&amp;gt; (g ∘ f)(3) 49 설명 줄리아에서 함수의 합성은 프로그래밍적으로는 파이프 오퍼레이터와 흡사하다. 이러한 합성이 가능함으로써 가장 큰 이점은 수학자의 입장에서 수식을 코드로 표현하기가 쉬워진다는 것이다. 위 예시는 단지 다음의 수식을 코드로 옮긴 것에 불과하다. $$ f(x) := 2x + 1 \\ g(x) := x^2 \\ (g \circ f) (3)</description>
    </item>
    
    <item>
      <title>줄리아에서 움짤 찌는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-gif-animation-in-julia/</link>
      <pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-gif-animation-in-julia/</guid>
      <description>코드 원래 생새우초밥집에서는 이보다는 훨씬 자세한 설명을 추가하는 편이지만, 줄리아에서 움짤을 찌는 게 얼마나 쉬운지를 강조하기 위해 가능한한 짧게 설명하도록 하겠다. 위와 같은 랜덤 워크를 시뮬레이션하는 건 둘째치더라도, 위와 같이 움짤로 만드는 것은 언어에 따라 아주 어렵고 힘들 수 있다. 그러나 줄리아에서는 @animate 매크로와 gif() 함수를 통해 어마어마하</description>
    </item>
    
    <item>
      <title>줄리아에서 거리 행렬 계산하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-calculate-a-distance-matrix-in-julia/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-calculate-a-distance-matrix-in-julia/</guid>
      <description>개요 거리 행렬Distance Matrix은 파티클 다이나믹스Particle Dynamics 및 무빙 에이전트Moving Agent 기반 시뮬레이션 등에 흔히 사용되나, 막상 찾아보면 딱 정리된 함수로는 없고 직접 계산하는 코드를 짜려면 막막한 게 보통이다. 줄리아에서는 pairwise() 와 Distances 패키지의 Euclidean() 함수를 사용해서 다음과 같이 손쉽게 거리 행렬을 계산할 수 있다. 1 dims 옵션</description>
    </item>
    
    <item>
      <title>줄리아에서 빈 배열 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-empty-array-in-julia/</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-empty-array-in-julia/</guid>
      <description>코드 크기 지정 julia&amp;gt; empty = Array{Float64, 2}(undef, 3, 4) 3×4 Array{Float64,2}: 3.39519e-313 3.18299e-313 4.66839e-313 1.061e-313 4.03179e-313 5.51719e-313 1.6976e-313 4.24399e-314 2.97079e-313 4.66839e-313 7.00259e-313 5.0e-324 위의 코드를 실행시키면 빈 배열이 만들어진다. 간혹 1.76297e-315처럼 이상한 값이 들어가는 것처럼 보이기도 하지만 이는 0에 아주 가까운 값으로써 초기화엔 큰 문제가 없다. Array{X, Y}(undef, ...)는 자료형 X로 Y차원 배열을 자료형에 해당하는 미정값으로 사이즈 ...만큼 채운 배</description>
    </item>
    
    <item>
      <title>리눅스에서 줄리아 최신 버전 설치하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-the-latest-version-julia-in-linux/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-the-latest-version-julia-in-linux/</guid>
      <description>본 포스트에서 줄리아 최신 버전은 v1.3.1이다. 가이드 Step 1. 줄리아 다운로드 Generic Linux Binaries for x86에서 자기 CPU의 비트에 맞는 파일을 다운로드 받는다. Step 2. 압축 해제 후 이동 압축을 해제한다. 줄리아가 저장되어 있을 위치로 폴더를 옮긴다. 본인이 원하는 곳 어디라도 상관 없는데, 해당 포스트에서는 /home/[유저이름]/julia-1.3</description>
    </item>
    
    <item>
      <title>줄리아에서 병렬처리 하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-parallel-processing-in-julia/</link>
      <pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-parallel-processing-in-julia/</guid>
      <description>코드 원래 생새우초밥집에는 상세한 설명을 포함하는데, 줄리아가 병렬처리를 얼마나 편하게 할 수 있는지 강조하기 위해 굳이 설명을 생략하려 한다. using Base.Threads for i in 1:10 println(i^2) end 위의 반복문을 병렬처리하고 싶다면 단지 포문 앞에 @threads만 붙이면 된다. @threads for i in 1:10 println(i^2) end 그래도 당부의 말을 한마디만 적는다면, 병렬처리라고 해서 모든 게 빨라지지는 않는다는</description>
    </item>
    
    <item>
      <title>줄리아의 강력한 편의 기능, 매크로</title>
      <link>https://freshrimpsushi.github.io/posts/macro-in-julia/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/macro-in-julia/</guid>
      <description>개요 매크로는 줄리아로 코딩할 때 편의를 주는 기능들로써, 스코프 앞에 두어 실행한다. 예를 들어 자신의 프로그램이 얼마나 많은 시간을 소비하는지 알고 싶다면 다음과 같이 작성하면 된다. @time for t in 1:10 foo() bar() end 예시 많은 종류가 있지만 다음의 매크로들이 특히 널리 쓰인다: @time : 뒤에 이어지는 함수나 스코프의 실행 시간을 측정해준다. 어떤 상황에서 어떻게 최적</description>
    </item>
    
    <item>
      <title>줄리아에서 파이프 오퍼레이터 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/pipe-operator-in-julia/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/pipe-operator-in-julia/</guid>
      <description>개요 줄리아는 데이터를 다루는데에서 강점을 내세우는만큼 파이프라인 연산자를 지원한다. 코드 julia&amp;gt; (1:5) .|&amp;gt; (x -&amp;gt; sqrt(x+2)) .|&amp;gt; sin |&amp;gt; minimum 0.4757718381527513 julia&amp;gt; minimum(sin.((x -&amp;gt; sqrt(x+2)).(1:5))) 0.4757718381527513 위의 예제 코드는 배열 $[1,2,3,4,5]$ 를 $\sqrt{x + 2}$ 에 넣어서 얻은 결과를 $\sin$ 에 넣은 후 그 중 작은 값을 얻는 코드로,위와 아래 코드는 완전히 같은 결과를 낸다. 파이프라인이 복잡한 코드를 작성하는 중에 얼마나 유용한지는 굳이 설명할 필요가 없</description>
    </item>
    
    <item>
      <title>줄리아에서의 람다식</title>
      <link>https://freshrimpsushi.github.io/posts/lambda-expression-in-julia/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/lambda-expression-in-julia/</guid>
      <description>개요 줄리아에서 람다식은 다음과 같이 정의된다. (x -&amp;gt; 3x^2 - 2x + 3)(1) 이는 익명함수 $\lambda : \mathbb{Z} \to \mathbb{Z}$ 를 다음과 같이 정의하고, 거기에 $1$ 을 대입해서 $4$ 라는 함수값을 얻은 것에 해당한다. $$ \lambda : x \mapsto ( 3 x^{2} - 2 x + 3 ) \\ \lambda(1) = 4 $$ 사실 람다식 자체는 줄리아의 특징이 아니라 매트랩과 파이썬을 비롯해 함수형 언어에 영향을 받았다면 거의 당연하게 지원하고, 줄리아</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지 불러오고 행렬로 변환 저장하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-read-and-save-an-image-convert-to-matrix-in-julia/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-read-and-save-an-image-convert-to-matrix-in-julia/</guid>
      <description>코드 using Images cd(&amp;quot;C:/Users/rmsms/OneDrive/examples&amp;quot;) pwd() example = load(&amp;quot;example.jpg&amp;quot;) typeof(example) size(example) gray1 = Gray.(example) typeof(gray1) size(gray1) M = convert(Array{Float64},gray1) typeof(M) size(M) colorview(Gray, M.^(1/2)) save(&amp;quot;rgb.png&amp;quot;, colorview(RGB, example)) save(&amp;quot;gray1.png&amp;quot;, colorview(Gray, gray1)) save(&amp;quot;gray2.png&amp;quot;, colorview(Gray, transpose(gray1))) save(&amp;quot;gray3.png&amp;quot;, colorview(Gray, M.^(1/2))) 예제 코드를 위에서부터 간략하게 이해해보자: cd() : Change Directory, 작업 경로를 원하는 곳으로 바꿔준다. pwd() : Print Working Directory, 작업 경로를 출력해준다. 예제를 그대로 따라해보고싶다면 위의 파일을 작업 경로에 다운로드 받고 파일 이름을 example.jpg로 수정하자. load() : 작업 경로 내</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지 크기 변경하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-resize-a-image-in-a-julia/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-resize-a-image-in-a-julia/</guid>
      <description>이미지 크기 변경 Images 패키지의 imresize를 사용하면 된다. 함수 이름이 매트랩과 같다. imresize(X, ratio=a): 배열 X를 a배만큼 조정한 이미지를 반환한다. 매트랩에서와는 다르게 냅다 비율만 적으면 안되고 반드시 ratio=a와 같이 적어야한다. imresize(X, m, n): 배열 X를 m행,n열로 확대/축소한 이미지를 반환한다. 아래는 예제 코드와 그 결과이다. using Images X=load(&amp;quot;example\_image2.jpg&amp;quot;) Y1=imresize(X, ratio=0.5) Y2=imresize(X,500,500)</description>
    </item>
    
    <item>
      <title>줄리아에서 이미지 배열을 회전하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-rotate-imagearraymatrix-in-julia/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-rotate-imagearraymatrix-in-julia/</guid>
      <description>이미지 회전 imrotate(X, theta) : 배열 X를 theta라디안만큼 회전시킨다. 여기서 주의해야할 점은 각도의 단위가 도($^{\circ})$인 매트랩과 달리 각도의 단위가 라디안이라는 것이다. 또한 매트랩과는 다르게 시계방향으로 회전한다. 다른 변수를 입력하지 않을 경우 보간법은 bilinear이고 회전된 이미지는 자르지 않는다. 원본 이미지 X와 이</description>
    </item>
    
    <item>
      <title>줄리아에서 2차원 배열 연산에 관한 함수들</title>
      <link>https://freshrimpsushi.github.io/posts/1460/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/1460/</guid>
      <description>$A = \begin{pmatrix} 1 &amp;amp; 2 &amp;amp; 1 \\ 0 &amp;amp; 3 &amp;amp; 0 \\ 2 &amp;amp; 3 &amp;amp; 4\end{pmatrix}$라고 하자. 전치행렬 julia&amp;gt; A =[1 2 1; 0 3 0; 2 3 4] 3×3 Array{Int64,2}: 1 2 1 0 3 0 2 3 4 julia&amp;gt; transpose(A) 3×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}: 1 0 2 2 3 3 1 0 4 julia&amp;gt; A&#39; 3×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}: 1 0 2 2 3 3 1 0 4 행렬의 원소가 실수라면 transpose()와 &#39;는 같은 행렬을 반환하지만 자료형이 미묘하게 다르다. 그 이유는 &#39;가 정</description>
    </item>
    
    <item>
      <title>줄리아에서 배열을 히트맵 이미지로 출력 저장하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-plot-and-save-arrays-as-heatmap-images-in-julia/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-plot-and-save-arrays-as-heatmap-images-in-julia/</guid>
      <description>Heatmap Plots 패키지의 heatmap 함수를 쓰면 2차원 배열을 히트맵 이미지로 출력할 수 있고, savefig 함수로 해당 이미지를 저장할 수 있다. @__DIR__은 줄리아 코드 파일의 위치를 알려주는 매크로이다. julia&amp;gt; cd(@__DIR__) julia&amp;gt; using Plots julia&amp;gt; A=[i for i=1:25] 25-element Array{Int64,1}: 1 2 3 4 ⋮ 23 24 25 julia&amp;gt; A=transpose(reshape(A, 5,5)) 5×5 LinearAlgebra.Transpose{Int64,Array{Int64,2}}: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 julia&amp;gt; h1=heatmap(A) julia&amp;gt; savefig(h1, &amp;quot;heatmap1.png&amp;quot;) 그런데 배열 A와 히트맵 이미지를 비</description>
    </item>
    
    <item>
      <title>줄리아에서 집합 자료형과 연산자</title>
      <link>https://freshrimpsushi.github.io/posts/set-type-and-operator-in-julia/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/set-type-and-operator-in-julia/</guid>
      <description>개요 줄리아에서는 파이썬과 마찬가지로 집합 자료형을 지원한다. 원래 집합 자료형이 그렇듯 쓰는 사람은 요긴하게 쓰고 안 쓰는 사람은 일절 사용하지 않는데, 줄리아는 언어 설계 자체가 수학과 가까운만큼 집합의 개념과 연산이 잘 구현되어 있어 반드시 알아두는 게 좋다. 기존의 언어, 특히 파이썬과 가장 다른 점은 유니코드 기호들도 코드의 일부로 사용할 수 있다</description>
    </item>
    
    <item>
      <title>줄리아에서 배열의 슬라이싱과 인덱싱</title>
      <link>https://freshrimpsushi.github.io/posts/slicing-and-indexing-in-julia/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/slicing-and-indexing-in-julia/</guid>
      <description>코드 줄리아는 R, 파이썬, 매트랩의 장점이 모두 섞여있는 언어다. 배열은 프로그래밍의 근간이 되는만큼 그 활용에서 여러 언어들의 흔적을 찾아볼 수 있다. 행렬 julia&amp;gt; M = [1. 2. ; 3. 4.] 2×2 Array{Float64,2}: 1.0 2.0 3.0 4.0 julia&amp;gt; size(M) (2, 2) julia&amp;gt; length(M) 4 행렬의 경우 매트랩의 문법과 거의 똑같이 정의하고 거의 똑같이 사용할 수 있다. size() 함수는 매트랩과 똑같이 쓰이고, 파이썬에서 numpy 패키지의 프로</description>
    </item>
    
    <item>
      <title>줄리아에서 배열을 평행이동시키는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/function-that-shifts-array-in-julia/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/function-that-shifts-array-in-julia/</guid>
      <description>설명 circshifr(A, (n,m))를 사용하면 배열 A의 행을 $n$칸씩 아래로 밀고, 열을 $m$칸씩 오른쪽으로 민다. (n,m)은 정수로 이루어진 튜플이어야하고 당연히 음수도 가능하다. 음수일 경우엔 반대 방향으로 평행이동 된다. 3차원 이상의 배열일 경우에는 제일 작은 2차원 배열에 각각 적용된다. 코드 2차원 배열 julia&amp;gt; A = transpose(reshape(1:25,5,5)) 5×5 LinearAlgebra.Transpose{Int64,Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}}: 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>줄리아에서 벡터를 생성하는 여러가지 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-generate-vector-in-julia/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-generate-vector-in-julia/</guid>
      <description>코드 julia&amp;gt; x1=[1 2 3] 1×3 Array{Int64,2}: 1 2 3 julia&amp;gt; x2=[1, 2, 3] 3-element Array{Int64,1}: 1 2 3 julia&amp;gt; x3=[i for i in 1:3] 3-element Array{Int64,1}: 1 2 3 julia&amp;gt; x4=[i for i in 1:3:10] 4-element Array{Int64,1}: 1 4 7 10 julia&amp;gt; x5=[i for i in 1:3:11] 4-element Array{Int64,1}: 1 4 7 10 x1은 2차원 배열이다. 생겨먹은건 행벡터와 같기 때문에 성분 좌표를 1개만 입력하면 행벡터인 것 처럼 인식한다. x2, x3, x4, x5 는 1차원 배열이다. x=[i for i in n:m]과 같이 입력하면 $n$부터 $m$까지 간격이 $1$</description>
    </item>
    
    <item>
      <title>줄리아에서 패키지 설치하고 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-and-use-packages-in-julia/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-and-use-packages-in-julia/</guid>
      <description>방법 1 using LinearAlgebra using Pkg Pkg.add(&amp;quot;Plots&amp;quot;) Pkg.add(&amp;quot;Distributions&amp;quot;) using Plots 위의 코드는 LinearAlgebra 패키지와 Pkg 패키지를 불러오며, .add() 함수를 통해 Plots, Distribution 패키지를 설치하는 코드를 나타낸다. 패키지를 불러오는 키워드 using은 마치 수학에서 어떤 정리나 논법을 사용할 때 쓰는 말과 닮았다. 패키지를 설치하는 것 자체는 파이썬보다는 R에 더 가깝고, 사용법은 파이썬과 더 비슷하다. R과 마찬가지로 패키지 이름을</description>
    </item>
    
    <item>
      <title>줄리아의 타입과 애노테이션</title>
      <link>https://freshrimpsushi.github.io/posts/type-and-annotation-in-julia/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/type-and-annotation-in-julia/</guid>
      <description>코드 julia&amp;gt; typeof(0) Int64 julia&amp;gt; typeof(0.0) Float64 julia&amp;gt; typeof(0 == 0.0) Bool julia&amp;gt; typeof(Bool) DataType julia&amp;gt; typeof(NaN) Float64 julia&amp;gt; typeof(Inf) Float64 julia&amp;gt; typeof(&amp;#39;O&amp;#39;) Char julia&amp;gt; typeof(&amp;#34;Ohmygirl&amp;#34;) String julia&amp;gt; typeof(&amp;#34;O&amp;#34;) String 줄리아에는 온갖 타입들이 구현되어있다. $0$ 과 $0.0$ 은 같은 $0$ 이지만 다른 타입을 가지며, 보다시피 타입인 Bool조차 DataType이라는 타입을 갖는다. C 언어처럼 String은 Char의 배열이며, 위와 같이 큰 따옴표인가 작은 따옴표인가로 구분된다. julia&amp;gt; supertype(Int64) Signed julia&amp;gt; supertype(Signed) Integer</description>
    </item>
    
    <item>
      <title>줄리아 프로그래밍 언어</title>
      <link>https://freshrimpsushi.github.io/posts/what-is-julia-language/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/what-is-julia-language/</guid>
      <description>개요 줄리아는 MIT에서 개발되어 2012년 공개된 프로그래밍 언어로써, 생산성이 높으면서도 속도가 높은 언어를 지향한다. C나 포트란에 준하는 속도를 내면서도 파이썬이나 R처럼 고수준의 문법을 갖추었으며, 그 외에도 여러 언어들의 장점을 취하고 있다. 2019년 11월 현재는 GPU가 급속도로 발전하면서 딥러닝이 유행을 선도하고 있어 조금</description>
    </item>
    
    <item>
      <title>줄리아의 다차원 인덱스</title>
      <link>https://freshrimpsushi.github.io/posts/multidimensional-index-in-julia/</link>
      <pubDate>Sat, 01 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/multidimensional-index-in-julia/</guid>
      <description>개요 줄리아에서는 다차원 배열에 참조할 수 있는 인덱스의 타입인 CatesianIndex를 제공한다. 1 당연히 카티션Catesian이라는 명명은 집합의 곱인 데카르트 곱에서 온 것이다. 코드 julia&amp;gt; M = rand(0:9, 4,4) 4×4 Matrix{Int64}: 9 3 7 0 8 6 2 1 3 8 4 9 5 6 8 2 가령 위와 같은 행렬 M의 3행 4열 원소인 9에 접근하고 싶다고 가정해보자. julia&amp;gt; pt = (3,4) (3, 4) julia&amp;gt;</description>
    </item>
    
    <item>
      <title>줄리아의 숏 서킷</title>
      <link>https://freshrimpsushi.github.io/posts/short-circuit-in-julia/</link>
      <pubDate>Tue, 28 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/short-circuit-in-julia/</guid>
      <description>개요 줄리아에서 &amp;amp;&amp;amp;과 ||는 논리곱, 논리합일 뿐만 아니라 숏-서킷 평가Short-circuit Evaluation을 수행한다.1 가령 A &amp;amp;&amp;amp; B는 A와 B가 모두 참일 때 참을 리턴하는데, 사실 A가 거짓이라면 B가 참인지 거짓인지 볼 것도 없이 A &amp;amp;&amp;amp; B는 거짓이다. 숏-서킷 평가는 그 볼 것도 없는 B를 실제로 안 보는 것이다.</description>
    </item>
    
    <item>
      <title>줄리아의 find 함수들</title>
      <link>https://freshrimpsushi.github.io/posts/find-functions-in-julia/</link>
      <pubDate>Fri, 24 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/find-functions-in-julia/</guid>
      <description>개요 줄리아의 기본 내장 함수들로써 알면 알수록 유용하다. 거두절미하고 예시를 보며 익히자. 코드 x = [3, 7, 4, 5, 10, 3, 12, 3, 2, 4] argmin(x) argmax(x) findmin(x) findmax(x) extrema(x) findfirst(x .== 3) findlast(x .== 3) findall(x .== 3) findnext(x .== 3, 5) findprev(x .== 3, 5) 최적해 argmin(),argmax(),findmin(),findmax(),extrema() 최적해를 찾는다. x = [3, 7, 4, 5, 10, 3, 12, 3, 2, 4] julia&amp;gt; argmin(x) 9 julia&amp;gt; argmax(x) 7 argmin(),argmax() 는 그냥 정확히 최적해, 즉 값이 가장 크고 작은 곳의 인덱스를 리턴한다. x = [3, 7, 4, 5, 10, 3, 12, 3, 2, 4] julia&amp;gt;</description>
    </item>
    
    <item>
      <title>줄리아의 느낌표 컨벤션</title>
      <link>https://freshrimpsushi.github.io/posts/bang-convention-in-julia/</link>
      <pubDate>Mon, 20 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/bang-convention-in-julia/</guid>
      <description>개요 1 줄리아에서 함수 이름의 가장 마지막에 느낌표Bang !을 넣는 것을 뱅 컨벤션이라 한다. 이러한 함수들은 입력받은 인수를 수정하는 특징을 가진다. 코드 function add_1!(x) x .+= 1 return x end foo = [2,5,-1] add_1!(foo) foo 예를 들어 위의 코드를 실행하면 다음과 같은 결과를 얻는다. julia&amp;gt; foo = [2,5,-1] 3-element Vector{Int64}: 2 5 -1 julia&amp;gt; add_1!(foo) 3-element Vector{Int64}: 3 6 0 julia&amp;gt; foo 3-element Vector{Int64}: 3 6 0 배열 foo는 함수 밖에서 정의되었고 add_1</description>
    </item>
    
    <item>
      <title>줄리아에서 부분배열 빠르게 참조하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-view-subarray-in-julia/</link>
      <pubDate>Sun, 12 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-view-subarray-in-julia/</guid>
      <description>개요 줄리아에서 view는 배열Array의 부분배열Subarray를 빠르게 참조하게끔 해주는 데이터 구조다. 1 실제로 쓰는 입장에서는 번거롭기만하고 차이가 없어보이지만 게으르게Lazily 참조되면서 더 가볍운 배열을 리턴한다. 따라서 아주 베이직한 수준에서까지 최적화된 줄리아 코드에서는 @views라는 매크로를 쉽게 찾아볼 수</description>
    </item>
    
    <item>
      <title>줄리아의 브로드캐스팅 문법</title>
      <link>https://freshrimpsushi.github.io/posts/syntax-for-broadcasting-in-julia/</link>
      <pubDate>Wed, 08 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/syntax-for-broadcasting-in-julia/</guid>
      <description>개요 브로드캐스팅Broadcasting은 줄리아에서 가장 중요한 개념으로, 벡터화된 코드를 작성함에 있어서 아주 편리한 문법이다.1 이항연산 앞에 .을 찍거나 함수 뒤에 .을 찍는 식으로 사용한다. 이는 점별Pointwise하게 함수를 적용시킨다는 의미에서 찰떡같은 표현이다. 프로그래밍적으로 브로드캐스팅은 맵과 리듀스에서 맵Ma</description>
    </item>
    
    <item>
      <title>줄리아에서 배열로 딕셔너리 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-dictionary-by-arrays-in-julia/</link>
      <pubDate>Wed, 24 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-dictionary-by-arrays-in-julia/</guid>
      <description>코드 1 julia&amp;gt; Dict([&amp;#34;a&amp;#34;, &amp;#34;bc&amp;#34;] .=&amp;gt; [2,8]) Dict{String, Int64} with 2 entries: &amp;#34;a&amp;#34; =&amp;gt; 2 &amp;#34;bc&amp;#34; =&amp;gt; 8 키Key와 밸류Value로 두고 싶은 두 배열이 주어져 있을 때, Dict(Key .=&amp;gt; Value)를 통해 딕셔너리를 만들 수 있다. 본질적으로 페어Pair를 만드는 연산자 =&amp;gt;의 브로드캐스팅Broadcasting에 지나지 않는다. 환경 OS: Windows julia: v1.7.0 https://discourse.julialang.org/t/create-a-dictionary-from-arrays-of-keys-and-values/13908/3&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>줄리아에서 복소수 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-complex-number-in-julia/</link>
      <pubDate>Sat, 20 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-complex-number-in-julia/</guid>
      <description>개요 줄리아에서는 기본적으로 R처럼 복소수를 지원한다. 코드 허수 im julia&amp;gt; z = 3 + 4im 3 + 4im im은 순허수 $i = \sqrt{-1}$ 를 나타낸다. 우리가 상식적으로 사용하는 사칙연산은 모두 사용할 수 있다. julia&amp;gt; typeof(z) Complex{Int64} julia&amp;gt; typeof(3.0 + 4.0im) ComplexF64 (alias for Complex{Float64}) 타입을 체크해보면 같은 복소수라도 어떤 복소수로 이루어져있는지가 다르다. 마치 추상대수에서 정수인 경우 $\mathbb{Z} [i]$, 혹은 실수인 경우 $\mathbb{R} [i]$ 로 구</description>
    </item>
    
    <item>
      <title>줄리아에서 조건문 짧게 쓰는 법</title>
      <link>https://freshrimpsushi.github.io/posts/shorthand-of-conditional-statement-in-julia/</link>
      <pubDate>Fri, 15 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/shorthand-of-conditional-statement-in-julia/</guid>
      <description>개요 줄리아에서 &amp;lt;condition&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;는 &amp;lt;condition&amp;gt;이 참일 때 &amp;lt;statement&amp;gt;가 실행된다. 함수로써는 참인 경우 &amp;lt;statement&amp;gt;의 결과가 반환되며, 거짓인 경우 &amp;lt;statement&amp;gt;가 아예 평가Evaluation조차 되지 않는다</description>
    </item>
    
    <item>
      <title>줄리아 데이터프레임에서 NaN을 0으로 바꾸는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-replace-nan-of-dataframe-to-0-in-julia/</link>
      <pubDate>Thu, 24 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-replace-nan-of-dataframe-to-0-in-julia/</guid>
      <description>개요 특정 값으로 바꾸는 방법은 한 열씩 바꾸기 때문에 불편하고, 데이터프레임 전체에서 NaN을 처리할 땐 더 좋은 트릭을 사용해봄직하다. 코드 julia&amp;gt; df = DataFrame(rand(1:9,3,3), :auto) ./ DataFrame(rand(0:1,3,3), :auto) 3×3 DataFrame Row │ x1 x2 x3 │ Float64 Float64 Float64 ─────┼─────────────────────────── 1 │ 5.0 Inf 7.0 2 │ Inf 8.0 Inf 3 │ 4.0 1.0 4.0 가령 위의 데이터 프레임에서 Inf를 0으로 대</description>
    </item>
    
    <item>
      <title>줄리아의 삼항연산자 ? :</title>
      <link>https://freshrimpsushi.github.io/posts/ternary-operator-in-julia/</link>
      <pubDate>Sun, 20 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/ternary-operator-in-julia/</guid>
      <description>개요 줄리아에서 A ? B : C는 이른바 삼항연산자Ternary Operator로써, A가 참이면 B, 거짓이면 C를 리턴하는 함수다. 수학적으로 이항연산이 함수로써 정의되듯, 삼항연산 역시 함수다. 조건문과 비슷하면서도 이러한 본질적 차이점이 있기 때문에 익숙해지면 아주 유용하게 쓸 수 있다. 다만 읽기 쉬운 코드와는 조금 멀어질 수 있기 때문에</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임 특정 값 변경하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-replace-element-of-dataframe-in-julia/</link>
      <pubDate>Wed, 16 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-replace-element-of-dataframe-in-julia/</guid>
      <description>개요 replace!() 메소드를 사용하면 된다.1 첫번째 인자로는 변경할 데이터프레임의 칼럼이 들어가고, 두번째 인자로는 페어 A =&amp;gt; B 가 들어간다. 여기서 데이터프레임의 칼럼이 들어간다는 게 중요하다. 코드 julia&amp;gt; WJSN 10×4 DataFrame Row │ member birth height unit │ String Int64 Int64 String ─────┼─────────────────────────────── 1 │ 다영 99 161 쪼꼬미 2 │</description>
    </item>
    
    <item>
      <title>줄리아에서 빈도수 계산하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-calculate-frequency-in-julia/</link>
      <pubDate>Sat, 12 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-calculate-frequency-in-julia/</guid>
      <description>개요 1 FreqTables.jl 패키지의 freqtable() 함수를 사용하면 된다. R에서의 freq() 함수와 유사한 기능을 한다. 코드 배열 julia&amp;gt; compartment = rand([&amp;#39;S&amp;#39;,&amp;#39;I&amp;#39;,&amp;#39;R&amp;#39;], 1000); julia&amp;gt; freqtable(compartment) 3-element Named Vector{Int64} Dim1 │ ──────┼──── &amp;#39;I&amp;#39; │ 316 &amp;#39;R&amp;#39; │ 342 &amp;#39;S&amp;#39; │ 342 위와 같이 그냥 배열을 넣으면 각 계급별로 카운트 해준다. 데이터프레임 freqtable()는 특히 데이터프레임에 유용하다. R에서의 질적변수를 포함한 회귀분석 예제와 마찬가</description>
    </item>
    
    <item>
      <title>줄리아에서 csv 파일 컬럼만 읽어들이는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-read-column-names-of-csv-file-only-in-julia/</link>
      <pubDate>Tue, 08 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-read-column-names-of-csv-file-only-in-julia/</guid>
      <description>가이드 가령 위와 같은 example.csv 파일이 있다고 하자. 이를 데이터프레임으로 불러들일 때, 데이터 전체가 아니라 열이름만 유지되어있고 텅 빈 데이터프레임을 만들고 싶을 때가 있다. 빈 데이터프레임이 필요한 경우가 있기 때문에 이런 경우도 반드시 있다. julia&amp;gt; using CSV, DataFrames julia&amp;gt; df = CSV.read(&amp;#34;example.csv&amp;#34;, DataFrame, limit = 1)[[false],:] 0×3 DataFrame 위 실행 결과에서 만들어진 데이터프레임은 3개의 열을 그대로 가지고 있지</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터 프레임 요약보는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-summarize-dataframe-in-julia/</link>
      <pubDate>Fri, 04 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-summarize-dataframe-in-julia/</guid>
      <description>가이드 1 using RDatasets iris = dataset(&amp;quot;datasets&amp;quot;, &amp;quot;iris&amp;quot;) describe(iris) describe() 함수를 사용하면 된다. iris 데이터를 요약해보자. julia&amp;gt; describe(iris) 5×7 DataFrame Row │ variable mean min median max nmissing eltype │ Symbol Union… Any Union… Any Int64 DataType ─────┼──────────────────────────────────────────────────────────────────────────────</description>
    </item>
    
    <item>
      <title>줄리아의 범주형 배열</title>
      <link>https://freshrimpsushi.github.io/posts/categorical-array-in-julia/</link>
      <pubDate>Mon, 31 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/categorical-array-in-julia/</guid>
      <description>개요 줄리아의 CategoricalArrays.jl 패키지는 R에서의 factor와 비슷한 역할을 한다. 코드 julia&amp;gt; A = [&amp;#34;red&amp;#34;, &amp;#34;blue&amp;#34;, &amp;#34;red&amp;#34;, &amp;#34;green&amp;#34;] 4-element Vector{String}: &amp;#34;red&amp;#34; &amp;#34;blue&amp;#34; &amp;#34;red&amp;#34; &amp;#34;green&amp;#34; julia&amp;gt; B = categorical(A) 4-element CategoricalArray{String,1,UInt32}: &amp;#34;red&amp;#34; &amp;#34;blue&amp;#34; &amp;#34;red&amp;#34; &amp;#34;green&amp;#34; julia&amp;gt; levels(B) 3-element Vector{String}: &amp;#34;blue&amp;#34; &amp;#34;green&amp;#34; &amp;#34;red&amp;#34; categorical() categorical() 함수로 일반 배열을 범주형 배열로 캐스트Cast 할 수 있다. levels() levels() 함수로는 계급을 볼 수 있다. 당연히 계급엔 중복이 없으며, 배열에서 해당 계급에 해당하는 원소가 없어도 계급 자체는 유지된다. julia&amp;gt; B[2] =</description>
    </item>
    
    <item>
      <title>줄리아에서 R에서 쓰던 내장데이터셋 불러오는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-load-datasets-in-r-in-julia/</link>
      <pubDate>Thu, 27 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-load-datasets-in-r-in-julia/</guid>
      <description>가이드 RDatasets.jl 패키지를 사용하면 된다. 다음은 제일 만만한 iris 데이터를 불러오는 예제다. 기본 내장 데이터셋 외에도 여러가지 데이터셋을 포함하고 있으니 깃허브를 참고하도록 하자. 1 julia&amp;gt; using RDatasets julia&amp;gt; iris = dataset(&amp;#34;datasets&amp;#34;, &amp;#34;iris&amp;#34;) 150×5 DataFrame Row │ SepalLength SepalWidth PetalLength PetalWidth Species │ Float64 Float64 Float64 Float64 Cat… ─────┼──────────────────────────────────────</description>
    </item>
    
    <item>
      <title>줄리아에서 패키지 버전 확인하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-check-version-of-package-in-julia/</link>
      <pubDate>Fri, 21 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-check-version-of-package-in-julia/</guid>
      <description>가이드 예로써 Plots.jl 패키지의 버전을 확인해보자. REPL에서 ] 키를 누르면 패키지 모드로 진입한다. 여기서 status foo을 입력하면 다음과 같이 foo 패키지의 버전을 확인할 수 있다. 환경 OS: Windows julia: v1.6.3</description>
    </item>
    
    <item>
      <title>줄리아에서 배열이 비어있는지 확인하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-check-that-array-is-empty-in-julia/</link>
      <pubDate>Mon, 17 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-check-that-array-is-empty-in-julia/</guid>
      <description>개요 isempty() 함수를 사용하면 된다. 코드 julia&amp;gt; isempty([]) true julia&amp;gt; isempty(Set()) true julia&amp;gt; isempty(&amp;#34;&amp;#34;) true 제목에서는 배열이라고 했지만 사실 배열이 아니라 집합이나 문자열이어도 된다. 최적화 물론 배열이 비어있는지는 length()가 $0$ 인지 확인해도 상관 없을 수 있다. julia&amp;gt; @time for t in 1:10^6 isempty([]) end 0.039721 seconds (1000.00 k allocations: 76.294 MiB, 27.85% gc time) julia&amp;gt; @time for t in 1:10^6 length([]) == 0 end 0.041762 seconds (1000.00 k allocations: 76.294 MiB, 19.18% gc time) 보다시피 빈 배열의 경우 두 방법은 성능</description>
    </item>
    
    <item>
      <title>줄리아에서 예외처리하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-handle-exception-in-julia/</link>
      <pubDate>Thu, 13 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-handle-exception-in-julia/</guid>
      <description>개요 지독한 외로움에 쩔쩔매본 사람은 알게되지 음 알게되지 코딩을 하다가 알수없는 에러에 고생해본 사람은 알게된다, 프로그래밍에 있어서 에러가 정말 중요하다는 사실을&amp;hellip; 줄리아에서는 error() 함수 혹은 @error 매크로를 통해 에러를 낼 수 있다. 내장 예외는 줄리아 v1.63을 기준으로 25가지가 정의되어 있다. 1 코드 julia&amp;gt; log(1 + 2im) 0.8047189562170501 + 1.1071487177940904im 가령 프로</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임 사이즈 확인하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-get-the-size-of-dataframe-in-julia/</link>
      <pubDate>Sun, 09 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-get-the-size-of-dataframe-in-julia/</guid>
      <description>개요 nrow(), ncol(), size() 등을 사용할 수 있다. R과 달리 length()는 에러를 낸다. 코드 julia&amp;gt; df = DataFrame(rand(100000,5), :auto) 100000×5 DataFrame Row │ x1 x2 x3 x4 x5 │ Float64 Float64 Float64 Float64 Float64 ────────┼───────────────────────────────────────────────────── 1 │ 0.474921 0.942137 0.0523668 0.588696 0.0176242 2 │ 0.842828 0.910385 0.216194 0.794668 0.664883 3 │ 0.0350312 0.96542 0.837923 0.920311 0.748409 4 │ 0.613249 0.731643 0.941826</description>
    </item>
    
    <item>
      <title>줄리아에서 변수이름을 칼럼명으로 가지는 데이터프레임 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-dataframe-with-variable-name-as-column-name/</link>
      <pubDate>Wed, 05 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-dataframe-with-variable-name-as-column-name/</guid>
      <description>개요 네임드 튜플을 사용하면 된다. 네임드 튜플을 만드는 방법은 왼쪽 괄호 바로 뒤에 세미콜론 ;을 붙이는 것이다. 가령 DataFrame(; x, y)이라고 하면 칼럼명이 :x, &amp;quot;y 이고 내용도 각각 x, y인 데이터프레임이 만들어진다. 코드 julia&amp;gt; MyCol7 = rand(5); B = 1:5; julia&amp;gt; DataFrame(; MyCol7, B) 5×2 DataFrame Row │ MyCol7 B │ Float64 Int64 ─────┼───────────────── 1 │ 0.911763 1 2 │ 0.93374 2 3 │ 0.116779 3 4 │ 0.467364</description>
    </item>
    
    <item>
      <title>줄리아의 네임드 튜플</title>
      <link>https://freshrimpsushi.github.io/posts/named-tuple-in-julia/</link>
      <pubDate>Sat, 01 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/named-tuple-in-julia/</guid>
      <description>개요 네임드 튜플Named Tuple은 일반적인 튜플과 달리 딕셔너리나 구조체Structure처럼 사용할 수 있는 튜플이다. 1 심볼Symbol의 배열을 키Key로 가지고 키로써 밸류Value에 접근할 수 있으면서도 튜플처럼 사용할 수 있다. 코드 x = rand(Bool, 5); y = rand(Bool, 5); z = (; x, y) typeof(z) z.x 위의 코드를 실행해서 네임드 튜플을 어떻게 사용하는지 확</description>
    </item>
    
    <item>
      <title>줄리아에서 명령줄 인수 넣는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-give-command-line-arguments-in-julia/</link>
      <pubDate>Tue, 16 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-give-command-line-arguments-in-julia/</guid>
      <description>코드 println(ARGS[1] * &amp;quot; + &amp;quot; * ARGS[2] * &amp;quot; = &amp;quot; * string(parse(Float64, ARGS[1]) + parse(Float64, ARGS[2]))) 위와 같이 한 줄로 이루어진 example.jl 파일이 있다고 해보자. 줄리아에서는 ARGS를 통해 커맨드라인에서의 인수를 배열로 받아줄 수 있다. 파이썬에서 sys.argv가 명령줄 인수의 배열로 들어오는 것과 유사하다. 작성된 코드는 숫자 두개를 받아서 그 합을 출력하는 프로그램이다. 실행 결과는 다음과 같다. 환경</description>
    </item>
    
    <item>
      <title>줄리아에서 외부 프로그램 실행하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-run-external-programs-in-julia/</link>
      <pubDate>Fri, 12 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-run-external-programs-in-julia/</guid>
      <description>코드 줄리아에서는 run() 함수를 통해 백틱Backtick `으로 감싸진 문자열을 실행한다. 파이썬으로 치자면 os 모듈의 os.system() 을 사용한것 비슷하다. julia&amp;gt; txt = &amp;#34;helloworld&amp;#34; &amp;#34;helloworld&amp;#34; julia&amp;gt; typeof(`echo $txt`) Cmd 위와 같이 백틱으로 감싸진 문자열은 Cmd라는 타입을 가지고, run() 함수로써 실행할 수 있다. julia&amp;gt; run(`cmd /C echo $txt`) helloworld Process(`cmd /C echo helloworld`, ProcessExited(0)) 이 예제로 한정했을 때, 윈도에서는 cmd에 있는 echo를 실행시</description>
    </item>
    
    <item>
      <title>줄리아에서 문자열 숫자로 바꾸는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-cast-string-to-number-in-julia/</link>
      <pubDate>Mon, 08 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-cast-string-to-number-in-julia/</guid>
      <description>코드 parse(type, str)를 사용하면 된다. 문자열 str을 type 타입의 숫자로 변경해준다. julia&amp;gt; parse(Int, &amp;#34;21&amp;#34;) 21 julia&amp;gt; parse(Float64, &amp;#34;3.14&amp;#34;) 3.14 환경 OS: Windows julia: v1.6.3</description>
    </item>
    
    <item>
      <title>줄리아에서 가변 인자 함수 정의하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-define-varargs-function-in-julia/</link>
      <pubDate>Tue, 18 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-define-varargs-function-in-julia/</guid>
      <description>개요 1 가변인자 함수란 보통 프로그래밍에서 Varargs Function이라 불리는 것으로, 복수의 인자가 제한 없이 들어올 수 있는 함수를 말한다. 줄리아에서는 간단히 변수 뒤에 ...을 찍는 것으로 가변 인자를 정할 수 있다. 예제 코드를 보고 이해해보자. 코드 아이작 뉴턴은 간단히 팩토리얼의 역수를 더하면 $e$ 에 수렴하는 다음의 정리를 발견했다. $$ e = {{ 1</description>
    </item>
    
    <item>
      <title>줄리아 컨테이너 내부 원소 타입 체크하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-check-type-of-element-in-container-in-julia/</link>
      <pubDate>Fri, 14 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-check-type-of-element-in-container-in-julia/</guid>
      <description>개요 eltype() 함수를 사용하면 된다. 아마 element type에서 나온 명명일 것이다. 코드 julia&amp;gt; set_primes = Set([2,3,5,7,11,13]) Set{Int64} with 6 elements: 5 13 7 2 11 3 julia&amp;gt; arr_primes = Array([2,3,5,7,11,13]) 6-element Vector{Int64}: 2 3 5 7 11 13 위와 같이 $13$ 까지의 소수를 원소로 가지는 두 가지의 컨테이너를 생각해보자. 솔직히 같은 데이터지만 위는 집합이고 아래는 배열이라는 차이만 있다. julia&amp;gt; typeof(set_primes) Set{Int64} julia&amp;gt; eltype(set_primes) Int64 julia&amp;gt; typeof(arr_primes) Vector{Int64} (alias for Array{Int64, 1}) julia&amp;gt; eltype(arr_primes) Int64 이 둘에 typeof()를 취</description>
    </item>
    
    <item>
      <title>줄리아 그림 기본 설정 바꾸는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-change-default-setting-of-plot-in-julia/</link>
      <pubDate>Mon, 10 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-change-default-setting-of-plot-in-julia/</guid>
      <description>코드 default() 함수를 사용하면 된다. using Plots default(size = (400,400), color = :red) default(:size, (400,400)) for key in [:size, :color], value in [(400,400), :red] default(key, value) end 일반 plot() 함수처럼 세팅하는 방법이 있고, 키와 밸류를 줘서 하나씩 바꾸는 방법이 있다. 보통은 위가 더 편하겠지만 세팅이 아주 복잡한 경우 반복문을 이용해 아래의 방법을 사용할 수도 있다. 초기화 모든 디폴트 세팅을 초기화 하고싶다면 default()를 사용하면 된다. 환</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임 특정 행만 제거하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-delete-some-column-of-dataframe-in-julia/</link>
      <pubDate>Thu, 06 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-delete-some-column-of-dataframe-in-julia/</guid>
      <description>개요 인덱싱할 때 Not() 함수를 사용하면 된다. 1 칼럼명 그대로의 심볼이나 심볼의 배열을 넣으면 그 칼럼들만 제외하고 인덱싱된다. 코드 using DataFrames WJSN = DataFrame( member = [&amp;quot;다영&amp;quot;,&amp;quot;다원&amp;quot;,&amp;quot;루다&amp;quot;,&amp;quot;소정&amp;quot;,&amp;quot;수빈&amp;quot;,&amp;quot;연정&amp;qu</description>
    </item>
    
    <item>
      <title>줄리아에서 그림에 수직선 수평선 넣는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-plot-horizon-line-and-vertical-line-in-julia/</link>
      <pubDate>Sun, 02 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-plot-horizon-line-and-vertical-line-in-julia/</guid>
      <description>개요 vline!(), hline!() 함수를 사용하면 된다. 코드 @time using Plots plot(rand(100)) hline!([0.5], linewidth = 2) vline!([25, 75], linewidth = 2) png(&amp;#34;result&amp;#34;) 선이 그어지는 위치는 배열로 넘겨준다. 배열의 요소가 여러개면 여러개의 선을 한 번에 그어준다. 환경 OS: Windows julia: v1.6.3</description>
    </item>
    
    <item>
      <title>줄리아에서 그림 양식 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-user-plot-template-in-julia/</link>
      <pubDate>Wed, 29 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-user-plot-template-in-julia/</guid>
      <description>개요 RecipesBase.jl은 유저가 직접 새로운 그림의 양식을 만들게 해주는 패키지다. R 프로그래밍 언어에서 ggplot이 그러하듯 원래의 줄리아와는 또 다른 독자적인 문법1이 있다. 예제를 통해 익혀보자. 코드 using Plots using DataFrames df = DataFrame(x = 1:10, y = rand(10)) plot(df) @userplot TimeEvolution @recipe function f(te::TimeEvolution) df = te.args[1] linealpha --&amp;gt; 0.5 column_names = names(df) for (column_index, column_name) ∈ enumerate(column_names) @series begin label --&amp;gt; column_name df[:,column_index] end end end timeevolution(df); png(&amp;quot;1&amp;quot;) timeevolution(df, legend = :left); png(&amp;quot;2&amp;quot;) 우선 위 코드</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임 그룹별로 나누고 계산하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-divide-dataframe-by-group-and-calculate-in-julia/</link>
      <pubDate>Sat, 25 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-divide-dataframe-by-group-and-calculate-in-julia/</guid>
      <description>개요 groupby()를 사용해 그룹별로 나누고 combine()을 사용해 계산하면 된다.1 groupby(df, :colname) :colname을 기준으로 GroupedDataFrame를 리턴한다. combine(gdf, :colname =&amp;gt; fun) gdf는 그룹별로 나뉜 GroupedDataFrame다. :colname =&amp;gt; fun은 계산할 값이 있는 열의 이름인 심볼 :colname과 계산할 함수 fun의</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임 중복된 행 삭제하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-drop-duplicated-rows-of-dataframe-in-julia/</link>
      <pubDate>Tue, 21 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-drop-duplicated-rows-of-dataframe-in-julia/</guid>
      <description>개요 unique()를 사용하면 된다. 정확하게는 중복된 행을 삭제한다기보단 하나만 남기는 것이다. 코드 using DataFrames WJSN = DataFrame( member = [&amp;quot;다영&amp;quot;,&amp;quot;다원&amp;quot;,&amp;quot;루다&amp;quot;,&amp;quot;소정&amp;quot;,&amp;quot;수빈&amp;quot;,&amp;quot;연정&amp;quot;,&amp;quot</description>
    </item>
    
    <item>
      <title>줄리아에서 레이아웃 주고 서브플랏 그리는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-give-layout-and-make-subplot-in-julia/</link>
      <pubDate>Fri, 17 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-give-layout-and-make-subplot-in-julia/</guid>
      <description>개요 줄리아에서 서브플랏에 관련된 옵션은 layout 옵션을 통해 제어할 수 있다. 정수를 입력하면 해당 수만큼의 그리드를 눈치껏 만들어준다. 정수의 2-튜플을 입력하면 정확히 주어진 대로의 그리드를 만들어준다. @layout 매크로를 통해 Plots.GridLayout 타입의 복잡한 레이아웃을 구성한다. 코드 using Plots left = plot(randn(100), color = :red) right = plot(randn(100), color = :blue) plot(left, right) png(&amp;quot;easyone&amp;quot;) data = rand(10, 6) plot(data, layout = 6) png(&amp;quot;easytwo&amp;quot;) plot(data, layout = (3,2)) png(&amp;quot;easygrid&amp;quot;) l = @layout [p1 ;</description>
    </item>
    
    <item>
      <title>줄리아에서 그림 범례 위치 조정하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-change-position-of-legend-in-julia-plot/</link>
      <pubDate>Mon, 13 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-change-position-of-legend-in-julia-plot/</guid>
      <description>개요 1 plot() 함수의 legend 옵션으로 범례의 위치를 자유롭게 조정할 수 있다. $0$ 부터 $1$ 사이의 값으로 이루어진 2-튜플을 주면 정확히 그 위치에 찍히고, 그 외에는 심볼로 제어할 수 있다. 심볼의 경우 top/bottom 과 left/right를 순서대로 연결해서 조합한다. 가장 앞에 outer를 붙이면 그림 바깥에 범례가 찍힌다. 조합으로 만들어지는 심볼의 예시로는 다음이</description>
    </item>
    
    <item>
      <title>줄리아 그림 가로세율 비율 조정하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-controll-ratio-of-plot-in-julia/</link>
      <pubDate>Thu, 09 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-controll-ratio-of-plot-in-julia/</guid>
      <description>개요 1 그림의 가로세로를 조절하기 위해서는 옵션에 ratio를 넣으면 된다. 추천하는 다른 가명으로는 aspect_ratios, axis_ratio가 있다. ratio = :none: 기본값으로, 그림의 사이즈에 비율이 맞춰진다. ratio = :equal: 그림의 사이즈에 상관없이 가로세로의 축이 일대일 비율로 맞춰진다. ratio = Number: Number대로 비율이 맞춰진다. Number는 ${{세로} \over {</description>
    </item>
    
    <item>
      <title>줄리아에서 CSV 출력 시 깨진 문자 해결법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-fix-broken-text-of-csv-in-julia/</link>
      <pubDate>Sun, 05 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-fix-broken-text-of-csv-in-julia/</guid>
      <description>에러 using DataFrames, CSV example = DataFrame(x = 1:10, 가 = &amp;quot;나다&amp;quot;) CSV.write(&amp;quot;example.csv&amp;quot;, example) 줄리아에서 CSV 파일로 출력하다보면 위와 같이 한글이 깨지는 현상을 볼 수가 있다. 원인 사실 한글이 깨지는 게 아니라 유니코드 인코딩의 문제로, 특히 UTF-8 인코딩의 BOMByte Order Mark 때문에 일어난다. 파이썬 등에서는 인코딩을 UTF-8-sig로 주는 식으로 해결할 수 있다. 해결법 1 CSV.write(&amp;quot;example.csv&amp;quot;, example, bom = true) C</description>
    </item>
    
    <item>
      <title>줄리아에서 텍스트 출력 꾸미는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-decorate-text-in-julia-console/</link>
      <pubDate>Wed, 01 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-decorate-text-in-julia-console/</guid>
      <description>개요 줄리아에서 텍스트 출력을 꾸미는 패키지로는 Crayons.jl이 알려져있다.1 코드 using Crayons print(Crayon(background = :red), &amp;quot;빨강&amp;quot;) print(Crayon(foreground = :blue), &amp;quot;파랑&amp;quot;) print(Crayon(bold = true), &amp;quot;볼드&amp;quot;) print(Crayon(italics = true), &amp;quot;이탤릭&amp;quot;) print(Crayon(bold = true, italics = true), &amp;quot;볼드 이탤릭&amp;quot;) 위 콘솔을 실행하면 다음</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임에 새로운 열 추가하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-add-new-column-to-dataframe-in-julia/</link>
      <pubDate>Tue, 31 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-add-new-column-to-dataframe-in-julia/</guid>
      <description>코드 우주소녀 데이터프레임이 아래와 같이 주어졌다고 하자. WJSN = DataFrame( member = [&amp;quot;다영&amp;quot;,&amp;quot;다원&amp;quot;,&amp;quot;루다&amp;quot;,&amp;quot;소정&amp;quot;,&amp;quot;수빈&amp;quot;,&amp;quot;연정&amp;quot;,&amp;quot;주연&amp;quot;,&amp;quot;지연&amp;quot</description>
    </item>
    
    <item>
      <title>줄리아 그림에 선분 넣는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-put-line-segment-in-julia-plot/</link>
      <pubDate>Sat, 28 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-put-line-segment-in-julia-plot/</guid>
      <description>코드 using Plots scatter(rand(100), randn(100)) plot!([0,1],[0,1]) png(&amp;quot;example1&amp;quot;) plot!([.00,.25,.50],[-2,0,-2]) png(&amp;quot;example2&amp;quot;) θ = 0:0.01:2π plot!(.5 .+ cos.(θ)/3, 1.5sin.(θ)) png(&amp;quot;example3&amp;quot;) 위 코드를 실행해 그림에 선분을 넣는 방법을 알아보자. 선분 plot!([0,1],[0,1]) 그냥 선분 하나를 긋든 다른 걸 긋든 방식은 똑같다. 선분에는 두 개의 점이 필요하므로 x좌표의 배열과 y좌표의 배열을 주면 된다. 여러 선분 plot!([.00,.25,.50],[-2,0,-2]) y2는 한번에 두 개의 선분을 그려낸 것이다. 선</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임 정렬하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-sort-dataframe-in-julia/</link>
      <pubDate>Tue, 24 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-sort-dataframe-in-julia/</guid>
      <description>코드 using DataFrames Unit1 = DataFrame( member = [&amp;quot;다영&amp;quot;,&amp;quot;루다&amp;quot;,&amp;quot;수빈&amp;quot;,&amp;quot;진숙&amp;quot;], birth = [99,97,96,99], height = [161,157,159,162] ) Unit2 = DataFrame( member = [&amp;quot;소정&amp;quot;,&amp;quot;주연&amp;quot;,&amp;quot;지연&amp;quot;,&amp;quot;현정&amp;quot;], birth = [95,98,95,94], height =</description>
    </item>
    
    <item>
      <title>줄리아에서 데이터프레임에 새 행 넣는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-add-new-row-to-dataframe-in-julia/</link>
      <pubDate>Fri, 20 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-add-new-row-to-dataframe-in-julia/</guid>
      <description>코드 using DataFrames Unit1 = DataFrame( member = [&amp;quot;다영&amp;quot;,&amp;quot;루다&amp;quot;,&amp;quot;수빈&amp;quot;,&amp;quot;진숙&amp;quot;], birth = [99,97,96,99], height = [161,157,159,162] ) Unit2 = DataFrame( member = [&amp;quot;소정&amp;quot;,&amp;quot;주연&amp;quot;,&amp;quot;지연&amp;quot;,&amp;quot;현정&amp;quot;], birth = [95,98,95,94], height =</description>
    </item>
    
    <item>
      <title>줄리아에서 무한대 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-infinity-in-julia/</link>
      <pubDate>Mon, 16 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-infinity-in-julia/</guid>
      <description>개요 Infinities.jl은 줄리아에서 무한대 기호를 사용하게 도와주는 패키지다.1 과학계산에 관련된 코딩에 있어서 무한대는 의외로 유용하다. 코드 julia&amp;gt; 8 &amp;lt; Inf true 개요에서 무한대를 사용하는 게 아니라 무한대 기호를 사용하게 도와준다고 한 이유는 사실 패키지 없이도 사용할 수 있기 때문이다. julia&amp;gt; using Infinities julia&amp;gt; 8 &amp;lt; ∞ true julia&amp;gt; -∞ &amp;lt; 8 true julia&amp;gt; max(∞, 10,</description>
    </item>
    
    <item>
      <title>줄리아에서 패키지 특정 버전으로 설치하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-install-package-specific-version-in-julia/</link>
      <pubDate>Thu, 12 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-install-package-specific-version-in-julia/</guid>
      <description>가이드 1 (@v1.6) pkg&amp;gt; status JuMP Status `C:\Users\rmsms\.julia\environments\v1.6\Project.toml` [4076af6c] JuMP v0.20.0 REPL에서 ] 키를 누르면 패키지 모드로 진입한다. 예로써 위와 같이 버전이 v0.20.0인 패키지를 v0.21로 버전업하고 싶다면, 다음과 같이 패키지 뒤에 @x.yy를 붙여서 설치하면 된다. (@v1.6) pkg&amp;gt; add JuMP@0.21 Resolving package versions... ... (@v1.6) pkg&amp;gt; status JuMP Status `C:\Users\rmsms\.julia\environments\v1.6\Project.toml` [4076af6c] JuMP v0.21.4 다시 버전을 확인해보면 정상적으로 패키지의 버전이 변경된 것을 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>줄리아에서 빈 데이터프레임 만드는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-make-empty-dataframe-in-julia/</link>
      <pubDate>Sun, 08 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-make-empty-dataframe-in-julia/</guid>
      <description>개요 많은 언어에서 데이터프레임을 지원함에도 의외로 할 때마다 새롭고 짜증나는 게 빈 배열 생성이다. 코드 타입 지정 julia&amp;gt; using DataFrames julia&amp;gt; df1 = DataFrame(x = Int64[], y = String[]) 0×2 DataFrame 실제로 빈 배열을 데이터로써 넣어주면 된다. 이 때 타입을 지정하게 되는데, 데이터가 전혀 없을 땐 칼럼 이름과 타입도 보이지 않는다. julia&amp;gt; push!(df1, [3, &amp;#34;three&amp;#34;]) 1×2 DataFrame │ Row │ x │ y │ │ │ Int64 │ String │ ├─────┼─</description>
    </item>
    
    <item>
      <title>줄리아에서 계층적 군집화하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-hierarchical-cluster-in-julia/</link>
      <pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-hierarchical-cluster-in-julia/</guid>
      <description>설명 Clustering.jl 패키지의 hclust() 함수를 사용하면 된다. hclust(d::AbstractMatrix; [linkage], [uplo], [branchorder]) 거리행렬을 입력으로 받아 계층적 군집화 결과를 반환한다. 군집간의 거리는 단일 연결이 기본이다. 덴드로그램을 그리려면 Plots.jl이 아니라 StatsPlots.jl을 사용해야한다. 코드 using StatsPlots using Clustering using Distances using Distributions a = rand(Uniform(-1,1), 2, 25) scatt = scatter(a[1,:], a[2,:], label=false) savefig(scatt, &amp;quot;julia_hclust_scatter.png&amp;quot;) D_a = pairwise(Euclidean(), a, a) SL = hclust(D_a, linkage=:single) plot_SL = plot(SL) p = plot(scatt, plot_SL, size=(800,400)) savefig(p, &amp;quot;julia_hclust.png&amp;quot;)</description>
    </item>
    
    <item>
      <title>줄리아 문자열에서 특정 패턴 위치 찾는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-find-some-pattern-of-string-in-julia/</link>
      <pubDate>Sat, 30 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-find-some-pattern-of-string-in-julia/</guid>
      <description>코드 julia&amp;gt; findfirst(&amp;#34;li&amp;#34;, &amp;#34;multicolinearlity&amp;#34;) 8:9 julia&amp;gt; findlast(&amp;#34;li&amp;#34;, &amp;#34;multicolinearlity&amp;#34;) 14:15 julia&amp;gt; findnext(&amp;#34;l&amp;#34;, &amp;#34;multicolinearlity&amp;#34;, 1) 3:3 julia&amp;gt; findnext(&amp;#34;l&amp;#34;, &amp;#34;multicolinearlity&amp;#34;, 4) 8:8 julia&amp;gt; findnext(&amp;#34;l&amp;#34;, &amp;#34;multicolinearlity&amp;#34;, 9) 14:14 julia&amp;gt; findfirst(r&amp;#34;t.+t&amp;#34;, &amp;#34;multicolinearlity&amp;#34;) 4:16 findfirst(pattern, A) 문자열 A에서 pattern과 일치하는 구간을 Range로 리턴한다. 패턴에는 정규표현식이 들어갈 수 있다. 마지막 예시에서는 첫번째 t부터 마지막 t까지의 구간을 찾아서 리턴했다. 환경 OS: Windows julia: v1.6.2</description>
    </item>
    
    <item>
      <title>줄리아에서 덴드로그램 그리는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-plot-dendrogram-in-julia/</link>
      <pubDate>Fri, 29 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-plot-dendrogram-in-julia/</guid>
      <description>설명 주어진 데이터를 hclust()로 계층적 군집화하여 덴드로그램을 그리려고 plot() 함수를 쓰면 다음과 같은 오류가 난다. using Clustering using Distances using Plots a = rand(2, 10) D_a = pairwise(Euclidean(), a, a) SL = hclust(D_a, linkage=:single) dendrogram = plot(SL) ERROR: LoadError: Cannot convert Hclust{Float64} to series data for plotting 덴드로그램을 그리려면 Plots.jl이 아니라 StatsPlots.jl을 사용해야한다. using StatsPlots dendrogram = plot(SL) savefig(dendrogram, &amp;quot;julia_dendrogram.png&amp;quot;)</description>
    </item>
    
    <item>
      <title>줄리아에서 특정 문자열 포함 여부 확인하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-check-some-string-included-in-julia/</link>
      <pubDate>Tue, 26 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-check-some-string-included-in-julia/</guid>
      <description>코드 julia&amp;gt; contains(&amp;#34;qwerty&amp;#34;, &amp;#34;er&amp;#34;) true julia&amp;gt; contains(&amp;#34;qwerty&amp;#34;, &amp;#34;et&amp;#34;) false julia&amp;gt; contains(&amp;#34;qwerty&amp;#34;, r&amp;#34;q?&amp;#34;) true contains(haystack::AbstractString, needle) haystack에 needle이 포함되었는지 확인해 불리언으로 리턴한다. needle에는 r&amp;quot;...&amp;quot;와 같이 정규표현식이 들어갈 수 있다. 환경 OS: Windows julia: v1.6.2</description>
    </item>
    
    <item>
      <title>줄리아에서 소인수분해 및 소수관련 함수 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-factorization-in-julia/</link>
      <pubDate>Fri, 22 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-factorization-in-julia/</guid>
      <description>개요 Primes.jl은 소수에 관련된 함수 및 소인수분해를 다루는 패키지다. 해석적 정수론에 관련된 함수에 대한 구현은 아직 미비한 편이다. 패키지의 모든 기능을 정리한 것은 아니고 유용할만한 것만 추렸으니 자세한 것은 리파지터리를 확인하자. 1 타입 소인수분해 Primes.Factorization julia&amp;gt; factor(12) 2^2 * 3 julia&amp;gt; factor(12)[1] 0 julia&amp;gt; factor(12)[2] 2 julia&amp;gt; factor(12)[3] 1 julia&amp;gt; factor(12)[4] 0 소인수분해는 밑과 지수가 구분되어서 독자</description>
    </item>
    
    <item>
      <title>줄리아에서 다항함수 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-polynomials.jl-in-julia/</link>
      <pubDate>Mon, 18 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-polynomials.jl-in-julia/</guid>
      <description>개요 Polynomials.jl은 다항 함수의 표현 및 계산 등을 포함한 패키지다. 다항함수라는 게 수학적으로 쉬워서 그런지 코딩도 간단하게 생각하는 경우가 있는데 막상 필요한 기능들을 구현하다보면 꽤 번거롭다. 물론 엄청 어려운 건 아닌데, 어지간하면 패키지를 사용하도록 하자. 패키지의 모든 기능을 정리한 것은 아니고 유용할만한 것만 추렸으니</description>
    </item>
    
    <item>
      <title>줄리아에서 문자열 합치는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-concatenate-strings-in-julia/</link>
      <pubDate>Thu, 14 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-concatenate-strings-in-julia/</guid>
      <description>코드 문자열 합치기 * julia&amp;gt; &amp;#34;oh&amp;#34; * &amp;#34;my&amp;#34; * &amp;#34;girl&amp;#34; &amp;#34;ohmygirl&amp;#34; 파이썬의 +에 해당한다. 여러 문자열 합치기 string() julia&amp;gt; string(&amp;#34;oh&amp;#34;,&amp;#34;my&amp;#34;, &amp;#34;girl&amp;#34;) &amp;#34;ohmygirl&amp;#34; R의 paste0()에 해당한다. 문자열의 리스트의 아이템으로써 합치기 join() julia&amp;gt; OMG = [&amp;#34;oh&amp;#34;,&amp;#34;my&amp;#34;, &amp;#34;girl&amp;#34;] 3-element Vector{String}: &amp;#34;oh&amp;#34; &amp;#34;my&amp;#34; &amp;#34;girl&amp;#34; julia&amp;gt; join(OMG) &amp;#34;ohmygirl&amp;#34; 파이썬의 join()에 해당한다. 같은 문자열 반복하기 ^ julia&amp;gt; &amp;#34;=-&amp;#34; ^ 10 &amp;#34;=-=-=-=-=-=-=-=-=-=-&amp;#34; 파이썬의 *에 해당한다. 거듭제곱으로 반복을 표현한 것은 전혀 우연이 아닌</description>
    </item>
    
    <item>
      <title>줄리아 그림에서 특정 데이터만 라벨 숨기는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-hide-some-lables-in-julia-plot/</link>
      <pubDate>Sun, 10 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-hide-some-lables-in-julia-plot/</guid>
      <description>코드 1 using Plots x = rand(30) y = rand(30) z = rand(30) plot(x) plot!(y) plot!(z) png(&amp;quot;result1&amp;quot;) 위와 같이 세 데이터에 대한 라벨 중 특정 데이터만 범례에서 나타나지 않게 하고 싶을 수 있다. label = &amp;quot;&amp;quot; plot(x, label = &amp;quot;&amp;quot;) plot!(y) png(&amp;quot;result2&amp;quot;) 그럴 땐 위와 같이 label = &amp;quot;&amp;quot;을 옵션으로 주면 된다. 첫번째 데이터가 그림에선 출력되지만 범례에서는 나타나지 않는 것을 볼 수 있다. primary = false plot!(z, primary = false) png(&amp;quot;result3&amp;quot;) 다른 방법으로는 primary = fal</description>
    </item>
    
    <item>
      <title>줄리아 그림에 텍스트 넣는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-put-text-in-julia-plot/</link>
      <pubDate>Wed, 06 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-put-text-in-julia-plot/</guid>
      <description>코드 1 annotate!()를 사용하면 된다. 다음 코드는 브라운 모션에서 최대점과 최소점을 표시한 그림을 그려주는 코드다. using Plots cd(@__DIR__) data = cumsum(randn(100)) plot(data, color = :black, legend = :none) annotate!(argmax(data), maximum(data), &amp;quot;max\n&amp;quot;) annotate!(argmin(data), minimum(data), &amp;quot;\nmin&amp;quot;) png(&amp;quot;result&amp;quot;) 환경 OS: Windows julia: v1.7.0 https://discourse.julialang.org/t/plots-annotate/37784&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>줄리아 그림에 한글 넣는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-korean-in-julia-plot/</link>
      <pubDate>Sat, 02 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-korean-in-julia-plot/</guid>
      <description>환경 OS: Windows julia: v1.6.2 에러 julia&amp;gt; plot(data, color = :black, label = &amp;#34;값&amp;#34;, title = &amp;#34;브라운모션&amp;#34;) GKS: glyph missing from current font: 48652 GKS: glyph missing from current font: 46972 GKS: glyph missing from current font: 50868 GKS: glyph missing from current font: 47784 GKS: glyph missing from current font: 49496 원인 한글 폰트를 못 찾아서 그렇다. 해결법 두 방법 별로 좋지만은 않으며, 대안이 있다면 언제든지 제보 바란다. 줄리아를 사용하는 일이라면 한국어가 많이 필요하지 않</description>
    </item>
    
    <item>
      <title>줄리아에서 파이썬처럼 문자열 다루는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-handle-strings-like-python-in-julia/</link>
      <pubDate>Sat, 19 May 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-handle-strings-like-python-in-julia/</guid>
      <description>코드 1 2 3 julia&amp;gt; replace(&amp;#34;qwerty&amp;#34;, &amp;#34;q&amp;#34;=&amp;gt;&amp;#34;Q&amp;#34;) &amp;#34;Qwerty&amp;#34; julia&amp;gt; join(&amp;#34;qwerty&amp;#34;, &amp;#34;,&amp;#34;) &amp;#34;q,w,e,r,t,y&amp;#34; julia&amp;gt; split(&amp;#34;qwerty&amp;#34;, &amp;#34;&amp;#34;) 6-element Vector{SubString{String}}: &amp;#34;q&amp;#34; &amp;#34;w&amp;#34; &amp;#34;e&amp;#34; &amp;#34;r&amp;#34; &amp;#34;t&amp;#34; &amp;#34;y&amp;#34; 줄리아는 문자열 처리에 특출난 언어는 아니지만, 그 때문인지 파이썬을 많이 따라해서 쉽고 빠르게 배울 수 있다. 대부분 다 알던 기능들이 구현되어 있어 모듈인지 아닌지 하는 부분만 빼면 사용법이 거의 비슷하다. 참고로 replace()를 쓸 때 &amp;quot;q&amp;quot;=&amp;gt;&amp;quot</description>
    </item>
    
    <item>
      <title>줄리아에서 근사값 체크하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-check-approximate-value-in-julia/</link>
      <pubDate>Tue, 15 May 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-check-approximate-value-in-julia/</guid>
      <description>코드 비교연산자로써 $\approx$ 를 사용하면 두 값이 충분히 비슷할 때만 참을 반환한다. ≈ 는 $\TeX$에서와 마찬가지로 \approx 을 입력하고 탭(Tab)을 치면 쓸 수 있다. julia&amp;gt; π ≈ 3.141592653 true julia&amp;gt; π ≈ 3.14159265 true julia&amp;gt; π ≈ 3.1415926 false julia&amp;gt; π ≈ 3.141592 false 환경 OS: Windows julia: v1.7.0</description>
    </item>
    
    <item>
      <title>줄리아에서 딕셔너리와 페어</title>
      <link>https://freshrimpsushi.github.io/posts/dictionary-and-pair-in-julia/</link>
      <pubDate>Fri, 11 May 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/dictionary-and-pair-in-julia/</guid>
      <description>코드 1 julia&amp;gt; d = Dict(&amp;#34;A&amp;#34;=&amp;gt;1, &amp;#34;B&amp;#34;=&amp;gt;2) Dict{String, Int64} with 2 entries: &amp;#34;B&amp;#34; =&amp;gt; 2 &amp;#34;A&amp;#34; =&amp;gt; 1 julia&amp;gt; push!(d,(&amp;#34;C&amp;#34;,3)) ERROR: MethodError: no method matching push!(::Dict{String, Int64}, ::Tuple{String, Int64}) julia&amp;gt; push!(d,&amp;#34;C&amp;#34; =&amp;gt; 3) Dict{String, Int64} with 3 entries: &amp;#34;B&amp;#34; =&amp;gt; 2 &amp;#34;A&amp;#34; =&amp;gt; 1 &amp;#34;C&amp;#34; =&amp;gt; 3 julia&amp;gt; typeof(&amp;#34;C&amp;#34; =&amp;gt; 3) Pair{String, Int64} 줄리아의 딕셔너리Dictionary는 여타 프로그래밍 언어에서 쉽게 찾아볼 수 있는 키Key와 밸류Value로 묶인 자료형이다. 줄리아에서 약간 다른 점은 딕셔너리를 각 페어Pair의 모임으로 본다는 것이다. 위의</description>
    </item>
    
    <item>
      <title>줄리아에서 .mat처럼 데이터를 저장하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-save-data-like-matlab-mat-file/</link>
      <pubDate>Mon, 07 May 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-save-data-like-matlab-mat-file/</guid>
      <description>코드 1 JLD는 줄리아를 사용하면서 생기는 임시 데이터들을 저장할 수 있도록 해주는 패키지다. 퓨어 줄리아 프로젝트를 하면서 데이터의 입출력이 번거롭다면 유용하게 쓸 수 있다. using JLD cd(@__DIR__); pwd() numpad = reshape(1:9, 3,3) cube = zeros(Int64, 3,3,3) save(&amp;quot;mydata.jld&amp;quot;, &amp;quot;numpad&amp;quot;,numpad, &amp;quot;cube&amp;quot;,cube) mydata = load(&amp;quot;mydata.jld&amp;quot;) mydata[&amp;quot;numpad&amp;quot;] mydata[&amp;quot;cube&amp;quot;] 실행결과 julia&amp;gt; numpad = reshape(1:9, 3,3) 3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64: 1 4 7 2 5 8 3 6 9 julia&amp;gt; cube = zeros(Int64, 3,3,3) 3×3×3 Array{Int64, 3}: [:, :, 1] = 0 0 0 0 0 0 0 0 0 [:, :,</description>
    </item>
    
    <item>
      <title>줄리아의 반복문에서 인덱스와 값을 동시에 참조하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/julia-enumerate-equivalent-to-enumerate-in-python/</link>
      <pubDate>Thu, 03 May 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/julia-enumerate-equivalent-to-enumerate-in-python/</guid>
      <description>코드 1 Base.Iterators.enumerate() 는 파이썬과 같이 배열의 인덱스와 값을 동시에 참조할 수 있는 반복자Iterator를 반환한다. julia&amp;gt; x = [3,5,4,1,2] 5-element Vector{Int64}: 3 5 4 1 2 julia&amp;gt; for (idx, value) in enumerate(x) println(&amp;#34;x[$idx]: $value&amp;#34;) end x[1]: 3 x[2]: 5 x[3]: 4 x[4]: 1 x[5]: 2 julia&amp;gt; typeof(enumerate(x)) Base.Iterators.Enumerate{Vector{Int64}} https://docs.julialang.org/en/v1/base/iterators/#Base.Iterators.enumerate&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>줄리아에서의 심볼</title>
      <link>https://freshrimpsushi.github.io/posts/sysbols-in-julia/</link>
      <pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/sysbols-in-julia/</guid>
      <description>개요 줄리아를 처음 접하면서 적잖이 당황할 수 있는 것이 바로 심볼Symbol 자료형이다. 심볼은 맨 앞에 :을 붙여서 사용하며, 어떤 내부 데이터도 없이 그 이름 그 자체로써 기능한다. 주로 이름이나 라벨, 딕셔너리 키 등으로 사용된다.1 설명 여타 프로그래밍 언어에서는 함수에 옵션을 줄 때 숫자로 주거나 의미를 정확히 하기 위해 문자열로 주곤 한다. 가령</description>
    </item>
    
    <item>
      <title>줄리아에서 배열의 원소들이 어떤 리스트에 속하는지 체크하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-check-that-elements-in-array-are-in-some-list/</link>
      <pubDate>Wed, 25 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-check-that-elements-in-array-are-in-some-list/</guid>
      <description>가이드 1 julia&amp;gt; x = rand(&amp;#39;a&amp;#39;:&amp;#39;c&amp;#39;, 10) 10-element Vector{Char}: &amp;#39;a&amp;#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase) &amp;#39;a&amp;#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase) &amp;#39;b&amp;#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;b&amp;#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;b&amp;#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase) &amp;#39;b&amp;#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase) 위와 같은 배열이 있다고 하자. 예제에서 우리의 목표는 &#39;a&#39; 와 &#39;b&#39; 를 모두 골라내는 것이라고 하자. 상식적으로는 포함기호 $\in$로 브로드캐스트하면 될 것 같지만</description>
    </item>
    
    <item>
      <title>줄리아에서 고차원 배열 직접 정의하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-directly-define-a-high-dimensional-array-in-julia/</link>
      <pubDate>Sun, 22 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-directly-define-a-high-dimensional-array-in-julia/</guid>
      <description>설명 1차원 배열(벡터)은 다음과 같이 정의한다. julia&amp;gt; A = [1; 2; 3] 3-element Vector{Int64}: 1 2 3 여기서 ;는 첫번째 차원을 기준으로 다음 성분으로 넘어간다는 의미를 갖는다. 이의 일반화로 ;;는 두번째 차원을 기준으로 다음 성분으로 넘어가는 의미를 갖는다. julia&amp;gt; A = [1; 2; 3;; 4; 5; 6] 3×2 Matrix{Int64}: 1 4 2 5 3 6 같은 방법으로 3차원 이상의 배열을 정의할 수 있다. 참고로 이 코드는</description>
    </item>
    
    <item>
      <title>줄리아에서 우아한 반복문을 사용하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-write-elegant-loop-in-julia/</link>
      <pubDate>Sat, 21 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-write-elegant-loop-in-julia/</guid>
      <description>가이드 while while 문은 여타 언어들과 다를 게 없다. julia&amp;gt; while x &amp;lt; 10 x += 1 print(&amp;#34;$x- &amp;#34;) end 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - for julia&amp;gt; for i in 1:10 print(&amp;#34;$i- &amp;#34;) end 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - julia&amp;gt; for i = 1:10 print(&amp;#34;$i- &amp;#34;) end 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - julia&amp;gt; for i ∈ 1:10 print(&amp;#34;$i- &amp;#34;) end 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 줄리아에서 메이저하게 쓰이는 반복</description>
    </item>
    
    <item>
      <title>줄리아 패키지 관리 모드에서 사용가능한 명령어 목록</title>
      <link>https://freshrimpsushi.github.io/posts/list-of-command-in-package-management-mode-in-julia/</link>
      <pubDate>Tue, 10 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/list-of-command-in-package-management-mode-in-julia/</guid>
      <description>설명 줄리아 REPL에서 오른쪽 각괄호 ]를 입력하면 패키지 관리 모드로 전환할 수 있다. 패키지 관리 모드에서 사용가능한 명령어는 다음과 같다. 명령어 기능 add foo foo 패키지를 추가한다. free foo pin을 해제한다. help, ? 이 명령어들을 보여준다. pin foo foo 패키지의 버전을 고정한다. remove foo, rm foo foo 패키지를 제거한다. test foo foo 패키지를 테스트 실행한다. status, st 설</description>
    </item>
    
    <item>
      <title>줄리아에서 npy 파일 불러오는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-load-npy-file-in-julia/</link>
      <pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-load-npy-file-in-julia/</guid>
      <description>설명 위 사진은 파이썬에서 팬텀 $f$의 라돈 변환 $\mathcal{R}f$를 계산하고, 이를 *.npy 파일로 저장하는 과정을 찍은 것이다. 줄리아에서 이 파일을 불러오려면 PyCall.jl 패키지를 이용하면 된다. using PyCall np = pyimport(&amp;#34;numpy&amp;#34;) 위 코드는 파이썬에서 import numpy as np를 실행한 것과 같다. 그러면 파이썬 넘파이에서 쓰는 코드 그대로 $f$와 $\mathcal{R}f$</description>
    </item>
    
    <item>
      <title>줄리아에서 히트맵 위에 플랏 겹쳐서 그리는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-plot-on-heatmap-in-julia/</link>
      <pubDate>Mon, 02 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-plot-on-heatmap-in-julia/</guid>
      <description>코드 우리가 $(5,5)$ 배열의 히트맵 위에 $0$부터 $2\pi$까지의 사인 곡선을 그리고 싶다고 하자. 다음과 같은 코드로 짜고 싶겠지만 그림에서 보이듯 원하는 대로 출력되지 않는다. using Plots A = rand(Bool, 5,5) heatmap(A, color=:greens) x = range(0, 2pi, length=100) y = sin.(x) plot!(x, y, color=:red, width=3) 이는 배열 $A$의 가로, 세로의 범위가 $1$에서 $5$까지로 인식되기 때문이다. 이를 해결하기 위해 아래과 같은 코드로 $</description>
    </item>
    
    <item>
      <title>줄리아에서 plot에 tex 사용하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-use-tex-in-julia-plot/</link>
      <pubDate>Fri, 30 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-use-tex-in-julia-plot/</guid>
      <description>코드 1 LaTeXStrings 라이브러리를 부르고 L&amp;quot;...&amp;quot; 과 같이 문자열 앞에 L을 적어주면 된다. @time using Plots @time using LaTeXStrings plot(0:0.1:2π, sin.(0:0.1:2π), xlabel = L&amp;#34;x&amp;#34;, ylabel = L&amp;#34;y&amp;#34;) title!(L&amp;#34;\mathrm{TeX\,representation:\,} y = \sin x , x \in [0, 2 \pi]&amp;#34;) 주의해야할 것은 패키지 이름의 대소문자가 정확히 LaTeXStrings 이라는 점과 일반 텍스트는 \text{} 가 먹히지 않으니 \mathrm{} 를 사용해야 한다는 점이다. 띄어쓰기는 \, 으로 한다. 환경</description>
    </item>
    
    <item>
      <title>줄리아에서 서로 다른 크기의 벡터 성분 별로 연산하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-elementwise-operate-two-vectors-of-different-size/</link>
      <pubDate>Wed, 21 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-elementwise-operate-two-vectors-of-different-size/</guid>
      <description>설명 julia&amp;gt; x = [1 2 3] 1×3 Matrix{Int64}: 1 2 3 julia&amp;gt; y = [1 2 3 4] 1×4 Matrix{Int64}: 1 2 3 4 julia&amp;gt; x .+ y ERROR: DimensionMismatch 위와 같이 크기가 다른 두 벡터는 기본적으로 점별 연산을 할 수 없다. 이를 직접 구현하려면 이중 for 문을 써야하겠지만, 다행히도 다음과 같이 간단하게 계산할 수 있다. 하나를 행벡터, 하나를 열벡터로 주면 다음과 같이 성분별로 연산한 2차원 배열을 반환한다. 이는 매트랩이</description>
    </item>
    
    <item>
      <title>줄리아에서 그림 배경 투명하게 출력하는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-plot-transparent-background-in-julia/</link>
      <pubDate>Fri, 16 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-plot-transparent-background-in-julia/</guid>
      <description>코드 1 브라우저를 다크모드로 보면 확실히 배경이 투명하게 출력되었음을 확인할 수 있다. background_color 옵션에 :transparent 심볼을 넣어주면 된다. *.png로는 잘 저장하지만 *.pdf로는 저장이 잘 되지 않는다고 한다. using Plots plot(rand(10), background_color = :transparent) png(&amp;quot;example&amp;quot;) 옵션 이름에서 예상할 수 있듯 컬러 심볼을 넣어주면 해당 색으로 출력된다. 예를 들어 노란색인 :yellow 로 뽑은 그림은 다음과 같다. 환경 OS: Windows julia:</description>
    </item>
    
    <item>
      <title>줄리아에서 곡선에서부터 특정한 값까지/두 곡선 사이/폐곡선 내부 색칠하는 방법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-fill-area-between-curve-and-fixed-value-in-julia/</link>
      <pubDate>Tue, 13 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-fill-area-between-curve-and-fixed-value-in-julia/</guid>
      <description>특정한 값까지 칠하기1 plot()의 속성으로 fillrange=a, fillalpha=b, fillcolor=:color를 사용하면, 플랏된 곡선에서부터 값 a까지 :color색깔을 b의 투명도로 칠한다. fill=(a,b,:color)로 써도 같은 기능을 한다. 즉 다음의 두 코드는 같다. plot(x,y, fillrange=a, fillalpha=b, fillcolor=:color) plot(x,y, fill=(a,b,:color)) 버그인 것 같은데 fillrange의 값을 $(0,1)$에서</description>
    </item>
    
    <item>
      <title>줄리아에서 ==과 ===의 차이점</title>
      <link>https://freshrimpsushi.github.io/posts/how-different-and-in-julia/</link>
      <pubDate>Sun, 12 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-different-and-in-julia/</guid>
      <description>코드 1 ==는 값이 같은지를 비교하고, ===는 비교할 값이 가변Mutable인지 아닌지에 따라 다르게 작동한다. Mutable: 두 항이 같은 오브젝트인지 확인한다. 다시 말해, 프로그래밍적으로 두 변수가 구분될 수 있는지 없는지를 리턴한다. Immutable: 두 항의 타입이 같은지 체크하고, 두 항의 스트럭쳐가 같은지 체크하고, 그 각각의 요소가 ===하게 같은지 재귀적</description>
    </item>
    
    <item>
      <title>줄리아에서 비트 배열 반전시키는 법</title>
      <link>https://freshrimpsushi.github.io/posts/how-to-get-negation-of-bit-array/</link>
      <pubDate>Fri, 27 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/how-to-get-negation-of-bit-array/</guid>
      <description>코드 1 아주 간단한데 부정 연산 !과 ~을 그냥 단항 연산이 아니라 함수로 보고 !. 혹은 ~.을 취하는 실수를 많이 한다. .!이나 .~으로 쓰면 된다. julia&amp;gt; a = rand(1,10) .&amp;lt; 0.5 1×10 BitMatrix: 1 1 0 0 1 0 1 0 0 0 julia&amp;gt; .!(a) 1×10 BitMatrix: 0 0 1 1 0 1 0 1 1 1 julia&amp;gt; .~(a) 1×10 BitMatrix: 0 0 1 1 0 1 0 1 1 1 환경 OS: Windows julia: v1.6.0 https://discourse.julialang.org/t/negation-of-boolean-array/16159/2&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
  </channel>
</rss>
