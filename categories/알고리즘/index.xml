<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>알고리즘 on 생새우초밥집</title>
    <link>https://freshrimpsushi.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
    <description>Recent content in 알고리즘 on 생새우초밥집</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Thu, 22 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>스탈린 정렬</title>
      <link>https://freshrimpsushi.github.io/posts/stalin-sort/</link>
      <pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/stalin-sort/</guid>
      <description>알고리즘 1 길이가 $n$ 인 배열이 주어져있다고 하자. 배열을 처음부터 뒤로 읽어가면서 뒤쪽이 앞쪽보다 크면 제거하는 것을 반복하면 &amp;lsquo;순서대로는&amp;rs</description>
    </item>
    
    <item>
      <title>스미스-워터맨 정렬: 국소 서열 정렬</title>
      <link>https://freshrimpsushi.github.io/posts/smith-waterman-alignment/</link>
      <pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/smith-waterman-alignment/</guid>
      <description>개요 두 염기서열에서 가장 비슷한 부분의 정렬을 찾는 것을 국소 정렬Local Alignment이라 하는데, 그 방법으로 가장 널리 쓰이는 스미스-워터맨 알고리</description>
    </item>
    
    <item>
      <title>니들맨-분쉬 알고리즘: 전역 서열 정렬</title>
      <link>https://freshrimpsushi.github.io/posts/needleman-wunsch-algorithm/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/needleman-wunsch-algorithm/</guid>
      <description>개요 두 염기서열의 공통 부분이 가장 많아지는 정렬을 찾는 것을 전역 정렬Global Alignment이라 하는데, 그 방법으로 가장 널리 쓰이는 니들맨-분쉬 알</description>
    </item>
    
    <item>
      <title>서열정렬 점수와 갭 페널티</title>
      <link>https://freshrimpsushi.github.io/posts/sequence-alignment-score-and-gap-penalty/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/sequence-alignment-score-and-gap-penalty/</guid>
      <description>정의 레퍼런스 서열과 쿼리 서열이 주어져 있다고 하자. 서열정렬 점수Sequence Alignment Score란 두 서열을 비교했을 때 얼마나 일치하는지를 수치화하는 것과 그</description>
    </item>
    
    <item>
      <title>서열정렬에서의 치환행렬</title>
      <link>https://freshrimpsushi.github.io/posts/substitution-matrix/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/substitution-matrix/</guid>
      <description>정의 서열정렬 점수를 매길 때 매치와 미스매치의 기준이 되는 행렬을 치환행렬Substitution Matrix이라 한다. 예시 using BioAlignments EDNAFULL BLOSUM45 PAM30 거두절미하고 예시</description>
    </item>
    
    <item>
      <title>서열정렬이란?</title>
      <link>https://freshrimpsushi.github.io/posts/what-is-sequence-alignment/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/what-is-sequence-alignment/</guid>
      <description>정의 염기서열 간의 유사도를 근거로 나열하는 것을 서열정렬Sequence Alignment이라 한다. 1 설명 생명정보공학에서 유전체의 길이는 무척 길기 때</description>
    </item>
    
    <item>
      <title>문자열의 편집 거리</title>
      <link>https://freshrimpsushi.github.io/posts/edit-distance-of-strings/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/edit-distance-of-strings/</guid>
      <description>빌드업 1 문자열에는 다음과 같이 네가지 작용이 있다: 삽입: 문자열에 새로운 문자를 끼워넣는다. 제거: 문자열에서 문자 하나를 없앤다. 교체: 문자열에서 문자 하</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 유전체와 유전자</title>
      <link>https://freshrimpsushi.github.io/posts/genome-and-gene-in-bioinformatics/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/genome-and-gene-in-bioinformatics/</guid>
      <description>정의 한 개체의 염기서열을 모두 모은 것을 유전체Genome라고 한다. 유전체의 일부를 차지하는 구간으로, 유전 형질의 단위가 되는 것을 유전자Gene라고 한다</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 인트론과 엑손</title>
      <link>https://freshrimpsushi.github.io/posts/intron-and-exon-in-bioinformatics/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/intron-and-exon-in-bioinformatics/</guid>
      <description>정의 진핵 생물의 DNA에서 실제로 단백질의 합성에 관여하는 부분을 엑손Exon, 그렇지 않은 부분을 인트론Intron이라고 한다. 설명 원핵 생물과 진핵 생물</description>
    </item>
    
    <item>
      <title>염기서열의 상류와 하류</title>
      <link>https://freshrimpsushi.github.io/posts/upstream-and-downstream-of-nucleic-sequence/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/upstream-and-downstream-of-nucleic-sequence/</guid>
      <description>빌드업 1 염기서열의 방향은 위의 그림처럼 오탄당의 탄소 원자 위치에 따라 번호를 부여함으로써 나타낼 수 있다. RNA와 DNA는 구체적으로 3번 탄소 $3&amp;rsq</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 코돈과 아미노산 유전 부호</title>
      <link>https://freshrimpsushi.github.io/posts/codon-amino-acid-genetic-code/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/codon-amino-acid-genetic-code/</guid>
      <description>정의 DNA의 염기 3개를 순서쌍으로 묶은 단위를 트리플렛 코드Triplet Code라 한다. 센트럴 도그마에 따라 전사된 mRNA의 트리플렛 코드를 코돈Co</description>
    </item>
    
    <item>
      <title>분자생물학의 중심원리</title>
      <link>https://freshrimpsushi.github.io/posts/central-dogma-of-molecular-biology/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/central-dogma-of-molecular-biology/</guid>
      <description>원리 분자생물학의 중심원리 혹은 센트럴 도그마Central Dogma란 유전 정보는 DNA에서 RNA로, RNA에서 단백질로 전달된다는 가설로써 다음과 같</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 주요 염기와 염기쌍</title>
      <link>https://freshrimpsushi.github.io/posts/canonical-base-and-pair/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/canonical-base-and-pair/</guid>
      <description>정의 다음의 다섯가지 염기를 주요 염기Canonical Base라고 한다. 퓨린 염기: 아데닌Adenin $A$, 구아닌Guanine $G$ 피리미딘 염기: 사이토</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 염기서열</title>
      <link>https://freshrimpsushi.github.io/posts/nucleic-sequence-in-bioinformatics/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/nucleic-sequence-in-bioinformatics/</guid>
      <description>빌드업 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 DNA, RNA, 염색체</title>
      <link>https://freshrimpsushi.github.io/posts/dna-rna-chromosome-in-bioinformatics/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/dna-rna-chromosome-in-bioinformatics/</guid>
      <description>빌드업 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 원핵 생물과 진핵 생물</title>
      <link>https://freshrimpsushi.github.io/posts/prokaryotes-and-eukaryotes/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/prokaryotes-and-eukaryotes/</guid>
      <description>정의 핵막이 없는 생물을 원핵 생물Prokaryotes이라 한다. 핵막이 있는 핵으로 이루어진 생물을 진핵 생물Eukaryotes이라 한다. 설명 진핵 생물</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://freshrimpsushi.github.io/posts/greedy-algorithm/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/greedy-algorithm/</guid>
      <description>정의 그리디 알고리즘 이란 어떤 선택을 할 때 그 순간만을 고려해서 가장 좋은 경우를 고르는 방법이다. 설명 그리드 알고리즘은 탐욕Greed이라는 이름대로 길게 보지</description>
    </item>
    
    <item>
      <title>레벤슈타인 알고리즘</title>
      <link>https://freshrimpsushi.github.io/posts/levensteins-algorithm/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/levensteins-algorithm/</guid>
      <description>알고리즘 Input 문자열 $A,B$ 를 $A=[a_{i}]=(a_{1}, a_{2} , \cdots, a_{n})$ 과 $B=[b_{j}]=(b_{1}, b_{2} , \cdots, b_{m})$ 로 표현하자. Step 1. 초기화 행렬 $M_{(n+1) \times (m+1)} = [m_{x y }]$ 를 만들고 $M_{11} ← 0$ 을 대입한다. 그리고 $1$행과 $1$열을 다음과</description>
    </item>
    
    <item>
      <title>기수 정렬</title>
      <link>https://freshrimpsushi.github.io/posts/radix-sort/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/radix-sort/</guid>
      <description>알고리즘 자리수가 $k$ 로 제한된 $n$ 개의 자연수로 이루어진 데이터가 주어져있다고 하자. 그러면 데이터는 다음의 알고리즘에 따라 정렬되며 그 시간 복잡도는 $O (n)$ 이다.</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘 시간 복잡도의 하한</title>
      <link>https://freshrimpsushi.github.io/posts/lower-bound-of-time-complexity-of-comparison-sort-algorithms/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/lower-bound-of-time-complexity-of-comparison-sort-algorithms/</guid>
      <description>정리 비교 정렬 알고리즘의 시간복잡도는 아무리 좋아도 $\Omega ( n \log n )$ 이다. 설명 알고리즘이 원래 신기한 것이지만, 삽입 정렬과 같은 효율적인 알고리즘도 퀵 정렬에 밀</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘들의 시간 복잡도</title>
      <link>https://freshrimpsushi.github.io/posts/time-complexity-of-comparison-sort-algorithms/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/time-complexity-of-comparison-sort-algorithms/</guid>
      <description>정리 $n$ 개의 데이터가 주어져 있을 때, 비교 정렬 알고리즘들의 시간 복잡도는 다음과 같다. [1] 버블 정렬: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [2] 선택 정렬: $$ \Theta ( n^2 ) \\ O ( n^2</description>
    </item>
    
    <item>
      <title>동적 프로그래밍</title>
      <link>https://freshrimpsushi.github.io/posts/dynamic-programing/</link>
      <pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/dynamic-programing/</guid>
      <description>빌드업 문제를 풀 때, 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 최적 부분 구조Optimal Substructure를 가진다고 한다. 최적 부</description>
    </item>
    
    <item>
      <title>재귀함수를 쓸 때 주의해야하는 이유</title>
      <link>https://freshrimpsushi.github.io/posts/why-you-watch-out-when-you-using-recurrence/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/why-you-watch-out-when-you-using-recurrence/</guid>
      <description>주의 프로그래밍을 처음 배우면 그것이 어떤 언어든지 &amp;lsquo;재귀함수는 조심해서 써야한다&amp;rsquo;는 경고가 함께한다. 사실 재귀함수라는 게 그렇게</description>
    </item>
    
    <item>
      <title>시간복잡도와 공간복잡도</title>
      <link>https://freshrimpsushi.github.io/posts/time-complexity-and-space-complexity/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/time-complexity-and-space-complexity/</guid>
      <description>정의 주어진 문제를 풀 때의 걸리는 시간을 시간복잡도Time Complexity, 메모리 소요를 공간복잡도Space Complexity라고 한다. 예시 점근적 표기법은 이들을</description>
    </item>
    
    <item>
      <title>알고리즘의 비용에 대한 점근적 표기법</title>
      <link>https://freshrimpsushi.github.io/posts/asymptotic-notation/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/asymptotic-notation/</guid>
      <description>정의 크기가 $n$ 인 데이터에 대해 알고리즘의 비용을 다음과 같이 나타낸다. $O$ 표기법: $$ O(g(n)) := \left\{ f(n) \ | \ \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \le c g(n) \right\} $$ $\Omega$ 표기법: $$ \Omega</description>
    </item>
    
    <item>
      <title>지프의 법칙</title>
      <link>https://freshrimpsushi.github.io/posts/zipfs-law/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/zipfs-law/</guid>
      <description>법칙 코퍼스에서 $k$ 번째로 자주 나타나는 단어의 상대빈도를 $f_{k}$ 라고 하면 $$ f_{k} = {{C} \over {k}} $$ 설명 여기서 $C$ 는 $\displaystyle \sum_{k} f_{k} = 1$ 이 되도록하는 정규화계수다. 히스토그램으로 나</description>
    </item>
    
    <item>
      <title>힙스의 법칙</title>
      <link>https://freshrimpsushi.github.io/posts/heaps-law/</link>
      <pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/heaps-law/</guid>
      <description>법칙 코퍼스에서 어휘의 갯수를 $M$, 토큰의 갯수를 $T$ 라고 하면 $$ M = kT^{b} $$ 설명 코퍼스가 영어일 경우 보통 상수 $k,b$ 는 $10 \le k \le 100$, 그리고 $b = 0.5$ 정도로 나타난다고 한다. 힙</description>
    </item>
    
    <item>
      <title>n-그램과 자카드 계수</title>
      <link>https://freshrimpsushi.github.io/posts/n-gram-and-jaccard-coefficient/</link>
      <pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/n-gram-and-jaccard-coefficient/</guid>
      <description>정의 n-그램n-gram이란 어떠한 문자열을 n개씩 끊어서 자른 것을 말한다. 자카드 계수Jaccard Coefficient란 두 집합이 얼마나 비슷한지</description>
    </item>
    
  </channel>
</rss>
