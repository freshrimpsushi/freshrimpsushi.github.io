<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>알고리즘 on 생새우초밥집</title>
    <link>https://freshrimpsushi.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
    <description>Recent content in 알고리즘 on 생새우초밥집</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Sat, 08 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>스미스-워터맨 정렬: 국소 서열 정렬</title>
      <link>https://freshrimpsushi.github.io/posts/smith-waterman-alignment/</link>
      <pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/smith-waterman-alignment/</guid>
      <description>개요 두 염기서열에서 가장 비슷한 부분의 정렬을 찾는 것을 국소 정렬Local Alignment이라 하는데, 그 방법으로 가장 널리 쓰이는 스미스-워터맨 알고리즘Smith-Waterman Algorithm을 소개한다. 서열정렬에는 너무나 많은 경우의 수가 있기 때문에 다이내믹 프로그래밍 을 통해 효율적이고 빠르게 계산할 필요가 있다.</description>
    </item>
    
    <item>
      <title>니들맨-분쉬 알고리즘: 전역 서열 정렬</title>
      <link>https://freshrimpsushi.github.io/posts/needleman-wunsch-algorithm/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/needleman-wunsch-algorithm/</guid>
      <description>개요 두 염기서열의 공통 부분이 가장 많아지는 정렬을 찾는 것을 전역 정렬Global Alignment이라 하는데, 그 방법으로 가장 널리 쓰이는 니들맨-분쉬 알고리즘Needleman-Wunsch Algorithm을 소개한다. 서열정렬에는 너무나 많은 경우의 수가 있기 때문에 다이내믹 프로그래밍 을 통해 효율적이고 빠르게 계산할 필요</description>
    </item>
    
    <item>
      <title>서열정렬 점수와 갭 페널티</title>
      <link>https://freshrimpsushi.github.io/posts/sequence-alignment-score-and-gap-penalty/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/sequence-alignment-score-and-gap-penalty/</guid>
      <description>정의 레퍼런스 서열과 쿼리 서열이 주어져 있다고 하자. 서열정렬 점수Sequence Alignment Score란 두 서열을 비교했을 때 얼마나 일치하는지를 수치화하는 것과 그 방법을 말한다. 점수화는 다음과 같은 사항들에 가중치를 주어 계산된다. Match: 두 서열이 일치하는 횟수다. Mismatch: 두 서열이 일치하지 않는 횟수다. 예시 예로써 위와 같은 두 염기서열이 있다고 하자.</description>
    </item>
    
    <item>
      <title>서열정렬에서의 치환행렬</title>
      <link>https://freshrimpsushi.github.io/posts/substitution-matrix/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/substitution-matrix/</guid>
      <description>정의 서열정렬 점수를 매길 때 매치와 미스매치의 기준이 되는 행렬을 치환행렬Substitution Matrix이라 한다. 예시 using BioAlignments EDNAFULL BLOSUM45 PAM30 거두절미하고 예시부터 보자. 줄리아에서는 BioAlignments라는 패키지가 나와있고 손쉽게 원하는 치환행렬을 불러들일 수 있다. DNA 분석에 자주 사용되는 EDNAFULL나 단백질 서열에 쓰이</description>
    </item>
    
    <item>
      <title>서열정렬이란?</title>
      <link>https://freshrimpsushi.github.io/posts/what-is-sequence-alignment/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/what-is-sequence-alignment/</guid>
      <description>정의 염기서열 간의 유사도를 근거로 나열하는 것을 서열정렬Sequence Alignment이라 한다. 1 설명 생명정보공학에서 유전체의 길이는 무척 길기 때문에 이를 데이터화하는 것부터가 엄청난 일이다. 상상하기에는 우리도 중합효소처럼 DNA의 상류부터 하류까지 순서대로 읽으면서 저장하면 좋을 것 같지만, 현실적으로는 그렇게 할 수가 없</description>
    </item>
    
    <item>
      <title>문자열의 편집 거리</title>
      <link>https://freshrimpsushi.github.io/posts/edit-distance-of-strings/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/edit-distance-of-strings/</guid>
      <description>빌드업 1 문자열에는 다음과 같이 네가지 작용이 있다: 삽입: 문자열에 새로운 문자를 끼워넣는다. 제거: 문자열에서 문자 하나를 없앤다. 교체: 문자열에서 문자 하나를 다른 문자로 바꾼다. 전치: 두 문자의 위치를 서로 바꾼다. 정의 편집 거리는 문자열간의 거리 함수로써 편집 방법을 허용하거나 금지함으로써 다음과 같은 타입들로 구분된다: (1) Hamming distance: 해밍</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 유전체와 유전자</title>
      <link>https://freshrimpsushi.github.io/posts/genome-and-gene-in-bioinformatics/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/genome-and-gene-in-bioinformatics/</guid>
      <description>정의 한 개체의 염기서열을 모두 모은 것을 유전체Genome라고 한다. 유전체의 일부를 차지하는 구간으로, 유전 형질의 단위가 되는 것을 유전자Gene라고 한다. 특히 진핵생물에서는 인트론과 엑손으로 이루어져있다. 설명 사실 genome에 대해 유전체라는 순화는 거의 쓰이지 않고, 게놈 혹은 지놈으로 부르는게 보통이다. 지놈과 유전자는, 특</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 인트론과 엑손</title>
      <link>https://freshrimpsushi.github.io/posts/intron-and-exon-in-bioinformatics/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/intron-and-exon-in-bioinformatics/</guid>
      <description>정의 진핵 생물의 DNA에서 실제로 단백질의 합성에 관여하는 부분을 엑손Exon, 그렇지 않은 부분을 인트론Intron이라고 한다. 설명 원핵 생물과 진핵 생물은 세포핵에 핵막이 있냐 없느냐로 구분되지만, 생명정보공학의 관점에서 중요한 차이점은 센트럴 도그마에 의해 mRNA가 전사되고 난 뒤의 스플라이싱Splicing이라는 과정이 있느</description>
    </item>
    
    <item>
      <title>염기서열의 상류와 하류</title>
      <link>https://freshrimpsushi.github.io/posts/upstream-and-downstream-of-nucleic-sequence/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/upstream-and-downstream-of-nucleic-sequence/</guid>
      <description>빌드업 1 염기서열의 방향은 위의 그림처럼 오탄당의 탄소 원자 위치에 따라 번호를 부여함으로써 나타낼 수 있다. RNA와 DNA는 구체적으로 3번 탄소 $3&#39;$와 5번 탄소 $5&#39;$가 인산에스터 결합Phosphodiester Bond을 형성함으로써 사슬 구조를 이룬다. 가령 네 개의 염기가 다음과 같이 탄소 위치와 함께 주어져 있다고 하자. $$ 3&amp;rsquo;C5&#39;</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 코돈과 아미노산 유전 부호</title>
      <link>https://freshrimpsushi.github.io/posts/codon-amino-acid-genetic-code/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/codon-amino-acid-genetic-code/</guid>
      <description>정의 DNA의 염기 3개를 순서쌍으로 묶은 단위를 트리플렛 코드Triplet Code라 한다. 센트럴 도그마에 따라 전사된 mRNA의 트리플렛 코드를 코돈Codon이라 한다. 화학적으로 아미노기와 카복시기를 포함한 분자로, 단백질의 구성 단위를 아미노산Amino Acid이라 부른다. 코돈의 순열에 따라 아미노산의 대응관계를 유전 부호</description>
    </item>
    
    <item>
      <title>분자생물학의 중심원리</title>
      <link>https://freshrimpsushi.github.io/posts/central-dogma-of-molecular-biology/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/central-dogma-of-molecular-biology/</guid>
      <description>원리 분자생물학의 중심원리 혹은 센트럴 도그마Central Dogma란 유전 정보는 DNA에서 RNA로, RNA에서 단백질로 전달된다는 가설로써 다음과 같은 세 가지 현상으로 이루어져있다. 복제: DNA는 스스로 복제된다. 전사: DNA와 같은 정보를 담은 RNA가 만들어진다. 번역: RNA의 정보에 따라 단백질이 합성된다. 설명 센트럴</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 주요 염기와 염기쌍</title>
      <link>https://freshrimpsushi.github.io/posts/canonical-base-and-pair/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/canonical-base-and-pair/</guid>
      <description>정의 다음의 다섯가지 염기를 주요 염기Canonical Base라고 한다. 퓨린 염기: 아데닌Adenin $A$, 구아닌Guanine $G$ 피리미딘 염기: 사이토신Cytosine $C$, 티민Thymine $T$, 유라실Uracil $U$ 설명 티민은 DNA에서만 사용되며, 유라실은 RNA에서만 사용된다. 따라서 데이터에서 $T$ 와 $U$ 중 어느 것이 쓰이는</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 염기서열</title>
      <link>https://freshrimpsushi.github.io/posts/nucleic-sequence-in-bioinformatics/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/nucleic-sequence-in-bioinformatics/</guid>
      <description>빌드업 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화학식은 $H_{3}PO_{4}$이다. 5개의 탄소 원자를 갖는 단당류를 오탄당Pentose이라 한다. 유전 정보의 기본단위로써 기능하는 분자를 질소 염기Nitrogenou</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 DNA, RNA, 염색체</title>
      <link>https://freshrimpsushi.github.io/posts/dna-rna-chromosome-in-bioinformatics/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/dna-rna-chromosome-in-bioinformatics/</guid>
      <description>빌드업 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화학식은 $H_{3}PO_{4}$이다. 5개의 탄소 원자를 갖는 단당류를 오탄당Pentose이라 한다. 유전 정보의 기본단위로써 기능하는 분자를 질소 염기Nitrogenou</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 원핵 생물과 진핵 생물</title>
      <link>https://freshrimpsushi.github.io/posts/prokaryotes-and-eukaryotes/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/prokaryotes-and-eukaryotes/</guid>
      <description>정의 핵막이 없는 생물을 원핵 생물Prokaryotes이라 한다. 핵막이 있는 핵으로 이루어진 생물을 진핵 생물Eukaryotes이라 한다. 설명 진핵 생물에서는 유전 물질을 지니는 부분인 세포핵Nucleus과 각종 대사가 일어나는 세포질Cytoplasm이 핵막Nuclear Envelope에 의해 구분되지만 원핵 세포는 핵양체</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://freshrimpsushi.github.io/posts/greedy-algorithm/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/greedy-algorithm/</guid>
      <description>정의 그리디 알고리즘 이란 어떤 선택을 할 때 그 순간만을 고려해서 가장 좋은 경우를 고르는 방법이다. 설명 그리드 알고리즘은 탐욕Greed이라는 이름대로 길게 보지 않고 그 순간만을 생각한다. 좋게 말하면 항상 최선을 다하는 것이지만, 크게 보았을 때 이는 현명하지 못할 수도 있다. 다음의 예시를 보자: 왼쪽 0에서 시작해 오른쪽 1에 도착하는 경로를 찾는</description>
    </item>
    
    <item>
      <title>레벤슈타인 알고리즘</title>
      <link>https://freshrimpsushi.github.io/posts/levensteins-algorithm/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/levensteins-algorithm/</guid>
      <description>알고리즘 Input 문자열 $A,B$ 를 $A=[a_{i}]=(a_{1}, a_{2} , \cdots, a_{n})$ 과 $B=[b_{j}]=(b_{1}, b_{2} , \cdots, b_{m})$ 로 표현하자. Step 1. 초기화 행렬 $M_{(n+1) \times (m+1)} = [m_{x y }]$ 를 만들고 $M_{11} ← 0$ 을 대입한다. 그리고 $1$행과 $1$열을 다음과 같이 채운다. $$ M_{(i+1) 1} ← i \\ M_{ 1 (j+1)} ← j $$ Step 2. 동적 계획법 for $i = 1, 2, \cdots , n$ and $j=1,2, \cdots , m$ if $a_{i}==b_{j}$ $M_{i,j} ← M_{(i-1)(j-1)}$ else $M_{i,j} ← \min \left\{ M_{(i-1)(j)}, M_{(i)(j-1)}, M_{(i-1)(j-1)}\right\} + 1 $ Output $A$, $B$ 의 최소 수정 거리는 $m_{nm}$ 이다. 설명 편집 거리 란 두 문자열</description>
    </item>
    
    <item>
      <title>기수 정렬</title>
      <link>https://freshrimpsushi.github.io/posts/radix-sort/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/radix-sort/</guid>
      <description>알고리즘 자리수가 $k$ 로 제한된 $n$ 개의 자연수로 이루어진 데이터가 주어져있다고 하자. 그러면 데이터는 다음의 알고리즘에 따라 정렬되며 그 시간 복잡도는 $O (n)$ 이다. $i = 1 , \cdots , k$ 번째 자리수들끼리 비교해서 정렬한다. 설명 기수 정렬Radix Sort은 자리수의 제한이 있기 때문에 부동소수점이 있는 데이터에 적용할 수는 없으나, 정렬할 때 데이터</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘 시간 복잡도의 하한</title>
      <link>https://freshrimpsushi.github.io/posts/lower-bound-of-time-complexity-of-comparison-sort-algorithms/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/lower-bound-of-time-complexity-of-comparison-sort-algorithms/</guid>
      <description>정리 비교 정렬 알고리즘의 시간복잡도는 아무리 좋아도 $\Omega ( n \log n )$ 이다. 설명 알고리즘이 원래 신기한 것이지만, 삽입 정렬과 같은 효율적인 알고리즘도 퀵 정렬에 밀리는 것을 보면 그 이상의 알고리즘도 있지 않을까 궁금할 수밖에 없다. 다행인지 아닌지는 모르겠으나, 이 증명에 따라 그보다 효율적인 알고리즘을 생각할 필요는 없다.물론 일반적인 비교 알고</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘들의 시간 복잡도</title>
      <link>https://freshrimpsushi.github.io/posts/time-complexity-of-comparison-sort-algorithms/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/time-complexity-of-comparison-sort-algorithms/</guid>
      <description>정리 $n$ 개의 데이터가 주어져 있을 때, 비교 정렬 알고리즘들의 시간 복잡도는 다음과 같다. [1] 버블 정렬: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [2] 선택 정렬: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [3] 삽입 정렬: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [4] 힙 정렬: $$ \Theta ( n \log n ) \\ O ( n \log n ) $$ [5] 합병 정렬: $$ \Theta ( n \log n ) \\ O ( n \log n ) $$ [6] 퀵 정렬: $$ \Theta ( n \log n ) \\ O ( n^2 ) $$ 설명</description>
    </item>
    
    <item>
      <title>동적 프로그래밍</title>
      <link>https://freshrimpsushi.github.io/posts/dynamic-programing/</link>
      <pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/dynamic-programing/</guid>
      <description>빌드업 문제를 풀 때, 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 최적 부분 구조Optimal Substructure를 가진다고 한다. 최적 부분 구조를 갖춘 문제의 예로써 가장 쉬운 것이 바로 피보나치 수를 구하는 것이다. $n$ 번째 피보나치 수는 $a_{n} = a_{n-1} + a_{n-2}$ 와 같이 구해지므로, 큰 문제 $a_{n}$ 에 작은 문제 $a_{n-1}$, $a_{n-2}$ 가 포함되어 있기 때문이다. 이</description>
    </item>
    
    <item>
      <title>재귀함수를 쓸 때 주의해야하는 이유</title>
      <link>https://freshrimpsushi.github.io/posts/why-you-watch-out-when-you-using-recurrence/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/why-you-watch-out-when-you-using-recurrence/</guid>
      <description>주의 프로그래밍을 처음 배우면 그것이 어떤 언어든지 &amp;lsquo;재귀함수는 조심해서 써야한다&amp;rsquo;는 경고가 함께한다. 사실 재귀함수라는 게 그렇게 빈번하게 사용되는 테크닉이 아니기 때문에 그 이유는 설명하지 않는 경우가 많은데, 배우는 입장에선 이 좋은 걸 왜 꺼리는지 이해가 잘 되지 않을 수 있다. 예시를 통해 알아보자. 예시 def fibo1(n) : if n==1</description>
    </item>
    
    <item>
      <title>시간복잡도와 공간복잡도</title>
      <link>https://freshrimpsushi.github.io/posts/time-complexity-and-space-complexity/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/time-complexity-and-space-complexity/</guid>
      <description>정의 주어진 문제를 풀 때의 걸리는 시간을 시간복잡도Time Complexity, 메모리 소요를 공간복잡도Space Complexity라고 한다. 예시 점근적 표기법은 이들을 표현하는데에 굉장히 유용한 수단이 된다. 시간복잡도에 대한 예시를 살펴보자. 상수 시간 $O(1)$ $n$ 에 관계없이 끝낼 수 있는 알고리즘으로, 사실상 시간이 걸리지 않는 것이다. 가령 $\mathbb{x} = [4,3,8,-1,-9,0,5,7,2,6]$ 에서 세</description>
    </item>
    
    <item>
      <title>알고리즘의 비용에 대한 점근적 표기법</title>
      <link>https://freshrimpsushi.github.io/posts/asymptotic-notation/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/asymptotic-notation/</guid>
      <description>정의 크기가 $n$ 인 데이터에 대해 알고리즘의 비용을 다음과 같이 나타낸다. $O$ 표기법: $$ O(g(n)) := \left\{ f(n) \ | \ \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \le c g(n) \right\} $$ $\Omega$ 표기법: $$ \Omega (g(n)) := \left\{ f(n) \ | \ \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \ge c g(n) \right\} $$ $\Theta$ 표기법: $$ \Theta (g(n)) := O (g(n)) \cap \Omega (g(n)) $$ 설명 점근적 표기법은 알고리즘의 비용을 수리적으로 나타내는 것으로, 엡실론-델타 논법을</description>
    </item>
    
    <item>
      <title>지프의 법칙</title>
      <link>https://freshrimpsushi.github.io/posts/zipfs-law/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/zipfs-law/</guid>
      <description>법칙 코퍼스에서 $k$ 번째로 자주 나타나는 단어의 상대빈도를 $f_{k}$ 라고 하면 $$ f_{k} = {{C} \over {k}} $$ 설명 여기서 $C$ 는 $\displaystyle \sum_{k} f_{k} = 1$ 이 되도록하는 정규화계수다. 히스토그램으로 나타내보면 대략 위와 같은 모양이되 넓이의 합이 정확하게 $1$ 이 되도록 스케일을 조정해준 것이다. 오른쪽에 생기는 두꺼운 꼬리 모양을 롱테일이라고 부른다. 힙스의 법칙과 마찬가지로 경험적으</description>
    </item>
    
    <item>
      <title>힙스의 법칙</title>
      <link>https://freshrimpsushi.github.io/posts/heaps-law/</link>
      <pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/heaps-law/</guid>
      <description>법칙 코퍼스에서 어휘의 갯수를 $M$, 토큰의 갯수를 $T$ 라고 하면 $$ M = kT^{b} $$ 설명 코퍼스가 영어일 경우 보통 상수 $k,b$ 는 $10 \le k \le 100$, 그리고 $b = 0.5$ 정도로 나타난다고 한다. 힙스의 법칙은 수학적인 근거를 두고 유도된 것이 아니라 경험적으로 얻어진 법칙이다. 수식은 언뜻 굉장히 복잡해 보이지만 양변에 로그를 취하면 $\log M = \log k + b \log T$ 가 되고, 다음과 같이 선형적</description>
    </item>
    
    <item>
      <title>n-그램과 자카드 계수</title>
      <link>https://freshrimpsushi.github.io/posts/n-gram-and-jaccard-coefficient/</link>
      <pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/posts/n-gram-and-jaccard-coefficient/</guid>
      <description>정의 n-그램n-gram이란 어떠한 문자열을 n개씩 끊어서 자른 것을 말한다. 자카드 계수Jaccard Coefficient란 두 집합이 얼마나 비슷한지에 대한 척도로써 $0$ 부터 $1$ 사이의 값을 가진다. 수식으로 표현하면 다음과 같다. $$ JC(A,B) = {{| A \cap B|} \over {| A \cup B| }} = {{| A \cap B|} \over { |A|+ |B| -| A \cap B| }} $$ 예시 예를 들어 &amp;lsquo;오마이갓&amp;</description>
    </item>
    
  </channel>
</rss>
