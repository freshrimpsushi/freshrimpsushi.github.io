<!DOCTYPE html>
<html class="blog">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    
    

    
    <meta name="NaverBot" content="All" />
    <meta name="NaverBot" content="index,follow" />
    <meta name="Yeti" content="All" />
    <meta name="Yeti" content="index,follow" />

    
    
    <link rel="icon" href="https://freshrimpsushi.github.io/ko/logo/favicon.ico">
    <meta name="msapplication-TileColor" content="#FFFFFF">
    <meta name="msapplication-TileImage" content="logo/basic.png">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.css"
        integrity="sha512-vJqxkZ+Sugf/6WRlpcxN01qVfX/29hF6qc33eHF1va3NgoV+U+wCi+uTAsQ10sDoGyBxHLdaHvGwDlV3yVYboA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href=https://freshrimpsushi.github.io/en/css/style.css rel="preload" as="style" onload="this.rel='stylesheet'">
    <link href=https://freshrimpsushi.github.io/en/css/comment.css rel="preload" as="style" onload="this.rel='stylesheet'">

    
    <style type="text/css">
        .thmbox {
            background: rgb(245, 245, 245);
             
            border-radius: 20px;
            padding: 20px;
        }
    </style>

    
    <script data-ad-client="ca-pub-4751085325232621" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

    
    <meta name="google-site-verification" content="KYAokS7-6C5YuXOjatJQsiK1T0O8x4YncYFIF4tneYI" />
    <meta name="naver-site-verification" content="e5651d6f97899061897203413efc84994f04bbba" />

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NLV8Y9PRK1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-NLV8Y9PRK1');
    </script>

    <title>Paper Review: Physics-Informed Neural Networks</title>

    
</head>

<meta name="title" content="Paper Review: Physics-Informed Neural Networks">
<meta name="description"Content="국내 최대의 수학, 물리학, 통계학 블로그">
<meta property="og:title" content="Paper Review: Physics-Informed Neural Networks"/>
<meta property="og:description" content="[Review]Physics-Informed Neural Networks"/>
<meta property="og:image" content=https://freshrimpsushi.github.io/en/logo/basic.png/>


<link rel="canonical" href="https://freshrimpsushi.github.io/ko/"/>
<link rel="alternate" hreflang="en" href="https://freshrimpsushi.github.io/en/"/>
<link rel="alternate" hreflang="jp" href="https://freshrimpsushi.github.io/jp/"/>






<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "articleSection": "j_",
    "name": "Paper Review: Physics-Informed Neural Networks",
    "headline": "Paper Review: Physics-Informed Neural Networks",
    "alternativeHeadline": "",
    "description": "[Review]Physics-Informed Neural Networks",
    "inLanguage": "en",
    "isFamilyFriendly": "true",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/freshrimpsushi.github.io\/en\/posts\/3313\/"
    },
    "author" : {
        "@type": "Person",
        "name": "전기현"
    },
    "creator" : {
        "@type": "Person",
        "name": "전기현"
    },
    "accountablePerson" : {
        "@type": "Person",
        "name": "전기현"
    },
    "copyrightHolder" : "FreshrimpRestaurant",
    "copyrightYear" : "2022",
    "dateCreated": "2022-10-19T00:00:00.00Z",
    "datePublished": "2022-10-19T00:00:00.00Z",
    "dateModified": "2022-10-19T00:00:00.00Z",
    "publisher":{
        "@type":"Organization",
        "name": "FreshrimpRestaurant",
        "url": "https://freshrimpsushi.github.io/en/",
        "logo": {
            "@type": "ImageObject",
            "url": "https:\/\/freshrimpsushi.github.io\/en\/logo\/basic.png",
            "width":"32",
            "height":"32"
        }
    },
    "image": "https://freshrimpsushi.github.io/en/logo/basic.png",
    "url" : "https:\/\/freshrimpsushi.github.io\/en\/posts\/3313\/",
    "wordCount" : "3868",
    "genre" : [ ],
    "keywords" : [ ]
}
</script>


<script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>


<script src="https://use.fontawesome.com/releases/v6.5.1/js/all.js"></script>

<script src=https://freshrimpsushi.github.io/en/js/common.js></script>

<body class="main">
  <header>
    <a href= https://freshrimpsushi.github.io/en/ rel="home">
        <p style="text-align:center; font-size: 1rem; color: black;">
            
                <img src=https://freshrimpsushi.github.io/en/logo/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D.png style="height: auto; max-width: 16%;">
            
            
            
        </p>
    </a>
</header>

   
<script type="text/javascript">
    var goIndex = function(){
        var idx = document.getElementsByName("idx")[0].value;
        var local_idx = 'https:\/\/freshrimpsushi.github.io\/en\/' + "posts/" + idx;
        location.replace(local_idx)
    }
</script>



  <script>
  document.addEventListener("DOMContentLoaded", () => {
    fetch('https://api64.ipify.org?format=json')
      .then(res => res.json())
      .then(data => {
        return data.ip
      })
      .then(ip => {
        const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/ip_checker.php';
        return postFetch(url, { user_ip: ip });
      })
      .then(res => res.json())
      .then(data => {
        if (!data.ok) {
          alert('차단된 IP입니다.\nContact:\nfreshrimpsushi@gmail.com')
          window.location.href = 'https://google.com';
        }
      })
      .catch(err => console.error(err));
  });
</script>
  <form method="get" action="/en/search" style="border: 1px; text-align: center;">
    <div class="field">
    <input type="text" id="searchtext" placeholder = "🔍︎" class="input_text" name="s"
    style="background-color: #EEEEEE; text-align: center; width: 200px; font-size: 1.5rem;
    border: 1px; border-radius: 5px; padding-top:5px; padding-bottom:5px; margin-bottom: 1.5rem">
    </div>
</form>
  <div style="text-align: center;">
    
    <a href="javascript:void(0);" onclick="changeLanguage('ko')">한국어</a> |
    <a href="javascript:void(0);" onclick="changeLanguage('en')">English</a> |
    <a href="javascript:void(0);" onclick="changeLanguage('jp')">日本語</a>
</div>

<script>
    function changeLanguage(languageCode) {
        
        var currentUrl = window.location.href;

        var newUrl = currentUrl.replace(/\/(ko|en|jp)\//i, '/' + languageCode + '/');
        
        if (currentUrl.includes('localhost')) {
            
            var port;
            switch (languageCode) {
                case 'ko':
                    port = 1313;
                    break;
                case 'en':
                    port = 1314;
                    break;
                case 'jp':
                    port = 1315;
                    break;
                default:
                    port = 1313; 
            }

            

            
            newUrl = 'http://localhost:' + port + '/' + languageCode + '/' + newUrl.split('/' + languageCode + '/')[1];
        }
        window.location.href = newUrl;
    }
</script>
  
  
  <div class="wrapper">
    <div class="content">
      <div class="content-box">
        
<title>Paper Review: Physics-Informed Neural Networks</title>




        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <a href="https://freshrimpsushi.github.io/en/categories/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"
            style="background-color: rgba(0, 0, 0, 0.8); color: orange;
            border-radius:10px; padding: 5px;">
            📂MachineLearning</a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        


<h1>Paper Review: Physics-Informed Neural Networks</h1>


<aside>
  <div class="innerheader">
    <div class="innertoc">
      <b>Table of Contents</b>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#0-abstract">0. Abstract</a></li>
    <li><a href="#1-introduction">1. Introduction</a></li>
    <li><a href="#2-problem-setup">2. Problem setup</a></li>
    <li><a href="#3-data-driven-solutions-of-partial-differential-equations">3. Data-driven solutions of partial differential equations</a>
      <ul>
        <li><a href="#31-continuous-time-models">3.1. Continuous time models</a></li>
        <li><a href="#32-discrete-time-models">3.2. Discrete time models</a></li>
      </ul>
    </li>
    <li><a href="#4-data-driven-discovery-of-partial-differential-equations">4. Data-driven discovery of partial differential equations</a>
      <ul>
        <li><a href="#41-continuous-time-models">4.1. Continuous time models</a></li>
      </ul>
    </li>
    <li><a href="#5-conclusions">5. Conclusions</a></li>
  </ul>
</nav>
    </div>    
  </div>
</aside>

<h2 id="overview">Overview</h2>
<ul>
<li>The notation and numbering of references and formulas follow the conventions of the original paper.</li>
</ul>
<p>Physics-informed neural networks (referred to as PINN<sup>[pronounced &lsquo;pin&rsquo;]</sup>) are artificial neural networks designed to <a href="../../categories/numerical-analysis/">numerically solve</a> differential equations, introduced in the 2018 Journal of Computational Physics paper <a href="https://www.sciencedirect.com/science/article/pii/S0021999118307125">Physics-informed neural networks: A deep learning framework for solving forward and inverse problems involving nonlinear partial differential equations</a>. The authors of the paper are M. Raissi, P. Perdikaris, and G.E. Karniadakis from the departments of Applied Mathematics and Mechanical Engineering.</p>
<p>The <strong>physics information</strong> mentioned in this paper, although it may sound grandiose, simply refers to the given <strong>differential equations</strong> themselves. In other words, using the given differential equations when solving them with artificial neural networks is essentially the same as saying &lsquo;using physics information&rsquo; in this context. When reading machine learning papers, one should be cautious not to be swayed by such <strong>seemingly impressive</strong> terminology.</p>
<p>The reason PINN is receiving significant attention in the numerical solution of differential equations is likely due to the simplicity and ease of understanding of the idea behind the loss function, as well as its straightforward implementation. In fact, the paper introduces a very simple DNN as an example.</p>
<p>Commonly, the model introduced in Section 3.1 is referred to as PINN.</p>
<h2 id="0-abstract">0. Abstract</h2>
<p>The authors describe PINN as &lsquo;an artificial neural network trained to solve supervised learning problems while satisfying a given nonlinear partial differential equation&rsquo;. The two main issues addressed in this paper are the &lsquo;data-driven solution and data-driven discovery of partial differential equations&rsquo;. To evaluate performance, problems in fluid mechanics, quantum mechanics, and diffusion equations were solved.</p>
<h2 id="1-introduction">1. Introduction</h2>
<p>Although recent advances in machine learning and data analysis have led to innovative results in scientific fields such as image recognition, cognitive science, and genomics, there is a challenge in complex physical, biological, and engineering systems to yield desired results with limited information (due to the high cost of data collection). In such a <em>small data regime</em>, the convergence of advanced technologies like DNNs, CNNs, and RNNs is not guaranteed.</p>
<p>Studies on methods to learn physics information efficiently (i.e., solve differential equations with minimal data) were conducted in [4-6]. The extension to nonlinear problems was proposed in subsequent studies by Raissi, one of the authors of this paper, in [8,9].</p>
<h2 id="2-problem-setup">2. Problem setup</h2>
<p>The function represented by an artificial neural network is determined by its input values (coordinates $x, t$ of the solution $u$ in a partial differential equation) and parameters. <strong>Automatic differentiation</strong> is utilized to differentiate these two types of variables.</p>
<blockquote>
<p>Such neural networks are constrained to respect any symmetries, invariances, or conservation principles originating from the physical laws that govern the observed data, as modeled by general time-dependent and nonlinear partial differential equations.</p>
</blockquote>
<p>This sentence from the paper might seem complex, but simply put, it means that the proposed artificial neural network, PINN, must satisfy the given differential equations. This is because the condition of satisfying the differential equations is used as a loss function, as will be discussed later.</p>
<p>The aim of this paper is to present a new modeling and computational paradigm to advance deep learning in mathematical physics. To this end, as mentioned earlier, this paper mainly addresses two issues. One is the <strong>data-driven solution</strong> of partial differential equations, and the other is the <strong>data-driven discovery</strong> of partial differential equations. All the codes and datasets used can be found at <a href="https://github.com/maziarraissi/PINNs">https://github.com/maziarraissi/PINNs</a>. In this paper, a simple MLP using hyperbolic tangent as the activation function is used without any regularization such as $L1$, $L2$, or <a href="../1004">dropout</a>, as introduced in the <a href="../1807">regularization</a> section. The structure of the neural network, optimizer, <a href="../987">learning rate</a>, etc., are specifically introduced in each example.</p>
<p>This paper deals with the general form of parameterized and nonlinear partial differential equations as follows:</p>
<p>$$
\begin{equation}
u_{t} + \mathcal{N}[u; \lambda] = 0,\quad x \in \Omega,\quad t \in [0,T]
\end{equation}
$$</p>
<p>Here, $u=u(t,x)$ is the hidden (i.e., not given or unknown) function, the solution of $(1)$ that we seek, and $\mathcal{N}[\cdot; \lambda]$ is a nonlinear operator parameterized by $\lambda$, with $\Omega \subset \mathbb{R}^{D}$. Many problems in mathematical physics can be represented in this form. For instance, consider the one-dimensional viscous <a href="../532">Burgers&rsquo; equation</a>:</p>
<p>$$
u_{t} + uu_{x} = \nu u_{xx}
$$</p>
<p>This corresponds to the case in $(1)$ where $\mathcal{N}[u; \lambda] = \lambda_{1} uu_{x} - \lambda_{2}u_{xx}$ and $\lambda = (\lambda_{1}, \lambda_{2})$. The two problems addressed for the given equation $(1)$ are as follows:</p>
<ul>
<li><strong>data-driven solution of PDEs:</strong> For a fixed $\lambda$, what is the solution $u(t,x)$ of the system?</li>
<li><strong>data-driven discovery of PDEs:</strong> What are the parameters $\lambda$ that best describe the observed data?</li>
</ul>
<h2 id="3-data-driven-solutions-of-partial-differential-equations">3. Data-driven solutions of partial differential equations</h2>
<p>Section 3 discusses the problem of finding data-driven solutions for partial differential equations of the following form:</p>
<p>$$
\begin{equation}
u_{t} + \mathcal{N}[u] = 0,\quad x \in \Omega,\quad t \in [0,T]
\end{equation}
$$</p>
<p>This corresponds to the situation in $(1)$ where the parameter $\lambda$ is fixed. Section 3.1 and Section 3.2 will cover continuous time models and discrete time models respectively. The problem of finding the equations will be addressed in Section 4. The meaning of &lsquo;data&rsquo; mentioned here will be explained in detail below.</p>
<h3 id="31-continuous-time-models">3.1. Continuous time models</h3>
<p>Assuming $(t,x) \in \mathbb{R} \times \mathbb{R}$, then $u : \mathbb{R}^{2} \to \mathbb{R}$. This will be approximated using an artificial neural network, employing a simple MLP implemented as follows. In Julia, it would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Flux
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>u <span style="color:#f92672">=</span> Chain(
</span></span><span style="display:flex;"><span>    Dense(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>, relu),
</span></span><span style="display:flex;"><span>    Dense(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, relu),
</span></span><span style="display:flex;"><span>    Dense(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    )
</span></span></code></pre></div><p>In PyTorch, it would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> torch
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> torch.nn <span style="color:#66d9ef">as</span> nn
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> torch.nn.functional <span style="color:#66d9ef">as</span> F
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>layers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">network</span>(nn<span style="color:#f92672">.</span>Module):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        super(network, self)<span style="color:#f92672">.</span>__init__()
</span></span><span style="display:flex;"><span>        layer_list <span style="color:#f92672">=</span> [nn<span style="color:#f92672">.</span>Linear(layers[i], layers[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(layers)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>linears <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>ModuleList(layer_list)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, tx):
</span></span><span style="display:flex;"><span>        u <span style="color:#f92672">=</span> tx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(layers)<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>            u <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>linears[i](u)
</span></span><span style="display:flex;"><span>            u <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>relu(u)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        u <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>linears[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>](u)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> u
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>u <span style="color:#f92672">=</span> network()
</span></span></code></pre></div><p>Now, $u$ represents the artificial neural network we&rsquo;ve defined, with $2$ input nodes and $1$ output node. Let&rsquo;s define the left-hand side of $(2)$ as a function $f = f(t,x; u)$ as follows:</p>
<p>$$
\begin{equation}
f := u_{t} + \mathcal{N}[u]
\end{equation}
$$</p>
<p>Since $u$ is an artificial neural network, $f$ also becomes a sort of artificial neural network with hidden layer parameters. The $f$ defined in this way is called a <strong>physics-informed neural network (PINN)</strong>, which is, in essence, <strong>the given partial differential equation itself</strong>. The differentiation included in $f$ is implemented through automatic differentiation and shares the same parameters as $u$. If the artificial neural network $u$ accurately approximates the solution to $(2)$, the function values of $f$ should be zero everywhere. We can infer that we will train the artificial neural network in a direction where $ f \to 0$.</p>
<p>Let&rsquo;s say $(t_{u}^{i}, x_{u}^{i})$ are points in the domain where the initial and boundary conditions are defined:
$$
(t_{u}^{i}, x_{u}^{i}) \in( \Omega \times \left\{ 0 \right\}) \cup (\partial \Omega \times [0, T])
$$
If $u_{\ast}$ is the actual solution, having initial and boundary conditions means that the following values are given:</p>
<p>$$
\left\{ t_{u}^{i}, x_{u}^{i}, u^{i} \right\}_{i=1}^{N_{u}},\quad u^{i} = u_{\ast} (t_{u}^{i}, x_{u}^{i})
$$</p>
<p>Theoretically, we would have an infinite number of such values, but in numerical problems, we can only handle a finite number of points, so let&rsquo;s say we have $N_{u}$ points. The artificial neural network $u$ should output $u^{i}$ when given $(t_{u}^{i}, x_{u}^{i})$ as input, making these pairs the inputs and corresponding labels:</p>
<p>$$
\text{input} = (t_{u}^{i}, x_{u}^{i}),\qquad \text{label} = u^{i}
$$</p>
<p>This is precisely the <b>&lsquo;data&rsquo;</b> to be learned in PINN. We can now consider the following as the loss function:</p>
<p>$$
MSE_{u} = \dfrac{1}{N_{u}} \sum\limits_{i=1}^{N_{u}} \left| u(t_{u}^{i},x_{u}^{i}) - u^{i} \right|^{2}
$$</p>
<p>Additionally, $f$ should satisfy $(2)$ at appropriate points (ideally at all points where the solution $u_{\ast}$ is defined, but numerically we can only handle a finite number of points) $\left\{ t_{f}^{i}, x_{f}^{i} \right\}_{i=1}^{N_{f}}$. In the paper, these points are referred to as <strong>collocation points</strong>. We set the following as the loss function for the collocation points:</p>
<p>$$
MSE_{f} = \dfrac{1}{N_{f}}\sum\limits_{i=1}^{N_{f}} \left| f(t_{f}^{i}, x_{f}^{i}) \right|^{2}
$$</p>
<p>In other words, $MSE_{f}$ getting closer to $0$ means satisfying the physical information (the partial differential equation). Therefore, the final loss function for training the artificial neural network $u$ is as follows:</p>
<p>$$
MSE = MSE_{u} + MSE_{f}
$$</p>
<p>The paper explains that using $MSE_{f}$ as a constraint for physical information, as done here, was first researched in [15, 16]. However, in the PINN paper, it was reviewed using modern computational tools and applied to more challenging dynamic systems.</p>
<p>The term <strong>physics-informed machine learning</strong> was first used in Wang&rsquo;s study [17] on turbulence modeling. However, prior to PINN, studies simply employed machine learning algorithms like <a href="../2402">support vector machines</a>, random forests, and FNNs. PINN is distinguished from these previous approaches by considering not only the derivatives with respect to the parameters commonly used in machine learning</p>
<p>but also the derivatives with respect to the coordinates $x, t$ of the solution. That is, if the solution approximated by an artificial neural network with parameter $w$ is denoted as $u(t,x; w)$, while previously proposed methods only utilized the partial derivatives $u_{w}$, PINN also uses $u_{t}$, $u_{x}$, etc., to find the solution. It explains that this approach allows for finding the solution well even with a small amount of data.</p>
<blockquote>
<p>Despite the fact that there is no theoretical guarantee that this procedure converges to a global minimum, our empirical evidence indicates that, if the given partial differential equation is well-posed and its solution is unique, our method is capable of achieving good prediction accuracy given a sufficiently expressive neural network architecture and a sufficient number of collocation points $N_{f}$.</p>
</blockquote>
<p>The paper notes that although there is no theoretical guarantee for the convergence of the proposed method, empirical evidence suggests that if the given partial differential equation is well-posed and has a unique solution, and if there are a sufficient number of points, then high prediction accuracy can be achieved.</p>
<h4 id="311-example-schrodinger-equation">3.1.1. Example (Schrodinger Equation)</h4>
<p>This example focuses on verifying the effectiveness of the proposed method for solutions with periodic boundary conditions and complex values. As an example, the <a href="../1598">Schrodinger Equation</a> with the following initial and boundary conditions is considered:</p>
<p>$$
\begin{align*}
ih_{t} + 0.5h_{xx} + \left| h \right|^{2}h &amp;= 0,\quad x\in [-5, 5], t\in[0, \pi/2], \\
h(0,x) &amp;= 2\operatorname{sech} (x), \\
h(t,-5) &amp;= h(t,5), \\
h_{x}(t,-5) &amp;= h_{x}(t,5)
\end{align*}
$$</p>
<p>The solution to the problem, $h_{\ast}(t,x)$, is a function with complex-valued function outputs, namely $h_{\ast} : [0, \pi/2] \times [-5, 5] \to \mathbb{C}$. However, instead of defining an artificial neural network that outputs complex numbers, we define it to output a 2-dimensional vector consisting of $u(t,x)$ representing the real part and $v(t,x)$ representing the imaginary part. In simple terms, it is defined as an MLP with 2 input nodes and 2 output nodes:</p>
<p>$$
h(t,x) = \begin{bmatrix} u(t,x) \\[0.5em] v(t,x) \end{bmatrix}
$$</p>
<p>In this problem, the PINN $f$ is defined as:</p>
<p>$$
f := ih_{t} + 0.5h_{xx} + \left| h \right|^{2} h
$$</p>
<p>The parameters of $h(t,x)$ and $f(t,x)$ are trained to minimize the loss for initial values $MSE_{0}$, the loss for boundary values $MSE_{b}$, and the loss for physical information $MSE_{f}$.</p>
<p>$$
MSE = MSE_{0} + MSE_{b} + MSE_{f}
$$</p>
<p>$$
\begin{align*}
\text{where } MSE_{0} &amp;= \dfrac{1}{N_{0}}\sum_{i=1}^{N_{0}} \left| h(0, x_{0}^{i}) - h_{0}^{i} \right|^{2} \qquad (h_{0}^{i} = 2\operatorname{sech} (x_{0}^{i})) \\
MSE_{b} &amp;= \dfrac{1}{N_{b}}\sum_{i=1}^{N_{b}} \left( \left| h(t_{b}^{i}, -5) - h(t_{b}^{i}, 5) \right|^{2} + \left| h_{x}(t_{b}^{i},-5) - h_{x}(t_{b}^{i},5) \right|^{2} \right) \\
MSE_{f} &amp;= \dfrac{1}{N_{f}} \sum\limits_{i=1}^{N_{f}} \left| f(t_{f}^{i}, x_{f}^{i}) \right|^{2}
\end{align*}
$$</p>
<ul>
<li>Be aware that there is a typo in the formula for $MSE_{b}$ in the paper.</li>
</ul>
<p>Here, $\left\{ x_{0}^{i}, h_{0}^{i} \right\}_{i=1}^{N_{0}}$ are the initial value data, $\left\{ t_{b}^{i} \right\}_{i=1}^{N_{b}}$ are the collocation points at the boundary, and $\left\{ t_{f}^{i}, x_{f}^{i} \right\}_{i=1}^{N_{f}}$ are the collocation points for $f$.</p>
<p>For data generation, traditional spectral methods were used. The number of initial value data $N_{0} = 50$ and the number of boundary value data $N_{b} = 50$ were chosen randomly. Additionally, the number of collocation points for $f$ is $N_{f} = 20,000$. The artificial neural network was constructed by stacking</p>
<p>5 linear layers each with 100 nodes, and hyperbolic tangent $\tanh$ was used as the activation function between layers.</p>
<p><img src="figure1.png#center" alt="figure1.png"></p>
<p align=middle> Figure 1.</p>
<p>In Figure 1, the upper image shows the heatmap of the predicted solution $\left| h(t, x) \right|$. The lower images show how well the predicted solution matches the actual solution at times $t = 0.59, 0.79, 0.98$, respectively. The relative $L_{2}$-norm is $0.00197 = 1.97 \cdot 10^{-3}$, which means the predicted solution differs by about $0.02\%$ when compared to the accurate solution. Therefore, PINN can accurately capture the nonlinear behavior of the Schrodinger equation even with a small amount of initial data.</p>
<p>The continuous time model being discussed works well even with a few initial values but has a potential limitation in that a large number of collocation points $N_{f}$ are needed. This is not a significant issue when the spatial dimension is 2 or less, but in higher dimensions, the required number of collocation points can increase exponentially, which can be problematic. Therefore, in the next section, a more structured neural network that does not require many collocation points is presented, utilizing the classical Runge–Kutta time-stepping schemes.</p>
<h3 id="32-discrete-time-models">3.2. Discrete time models</h3>
<p>In Section 3.1, we approximated the solution over continuous time. In that case, the artificial neural network is trained simultaneously over the entire domain, providing an output for any arbitrary point $(x,t)$. In this section, unlike Section 3.1, we deal with discrete time. In other words, we will describe how to approximate the value at $t_{n+1}$ using an artificial neural network, given the value at $t_{n}$. Applying a $q$-stage <a href="../3319">Runge-Kutta method</a> to $(2)$ yields the following:
$$
u(t_{n+1}, x) = u(t_{n}, x) - \Delta t \sum_{j=1}^{q} b_{j}\mathcal{N}\left[ u(t_{n}+c_{j} \Delta t, x) \right]
$$</p>
<p>If we denote $u^{n}(x) = u(t_{n}, x)$ and $u^{n+c_{j}} = u(t_{n} + c_{j}\Delta t, x)$, then:</p>
<p>$$
\begin{equation}
\begin{aligned}
u^{n+1} &amp;= u^{n} - \Delta t \sum_{j=1}^{q} b_{j}\mathcal{N}\left[ u^{n+c_{j}}\right] \\
\text{where } u^{n+c_{j}} &amp;= u^{n} - \Delta t \sum_{i=1}^{q} a_{j,i}\mathcal{N}\left[ u^{n+c_{i}}\right] \quad j=1,\dots,q
\end{aligned}\tag{7}
\end{equation}
$$</p>
<p>In the $q+1$ equations above, let&rsquo;s move all the $\sum$ terms on the right-hand side to the left-hand side. Then, denote the left-hand side as $u_{i}^{n}$.</p>
<p>$$
\begin{equation}
\begin{aligned}
u_{q+1}^{n} &amp;:= u^{n+1} + \Delta t \sum_{j=1}^{q} b_{j}\mathcal{N}\left[ u^{n+c_{j}}\right] = u^{n} \\
\\
u_{1}^{n} &amp;:= u^{n+c_{1}} + \Delta t \sum_{i=1}^{q} a_{1,i}\mathcal{N}\left[ u^{n+c_{i}}\right] = u^{n} \\
u_{2}^{n} &amp;:= u^{n+c_{2}} + \Delta t \sum_{i=1}^{q} a_{2,i}\mathcal{N}\left[ u^{n+c_{i}}\right] = u^{n} \\
&amp;\vdots \\
u_{q}^{n} &amp;:= u^{n+c_{q}} + \Delta t \sum_{i=1}^{q} a_{q,i}\mathcal{N}\left[ u^{n+c_{i}}\right] = u^{n}
\end{aligned}\tag{9}
\end{equation}
$$</p>
<p>From this, we can see that all these values should be equal to $u^{n}$.</p>
<p>$$
u^{n} = u_{1}^{n} = u_{2}^{n} = \cdots = u_{q+1}^{n}
\tag{8}
$$</p>
<p>Therefore, the physics information mentioned in Section 3.2 refers to the given initial &amp; boundary conditions and $(8)$. Now, to compute $u(t_{n+1}, x)$, we define two artificial neural networks. The artificial neural network used in Section 3.1 was $u$ which is expected to converge to the exact solution $u_{\ast}$ and the differential equation $f$ that $u$ must satisfy, but here it&rsquo;s slightly different. First, let&rsquo;s define the artificial neural network $U$ as the following function:</p>
<p>$$
U : \mathbb{R} \to \mathbb{R}^{q+1}
$$</p>
<p>That is, it&rsquo;s a neural network with $1$ input node and $q+1$ output nodes. Let&rsquo;s assume the output of this network is as follows:</p>
<p>$$
U(x) = \begin{bmatrix}
u^{n+c_{1}}(x) \\[0.5em]
u^{n+c_{2}}(x) \\
\vdots \\[0.5em]
u^{n+c_{q}}(x) \\[0.5em]
u^{n+1}(x)
\end{bmatrix}
\tag{10}
$$</p>
<p>This network corresponds to the <code>neural_net</code> defined within the <code>PhysicsInformedNN</code> class in the attached code.</p>
<p>In the learning process below, the last component of the output of $U$ is expected to converge to $u(t_{n+1}, x)$. The second neural network is defined using the output of $U$ and the definition in $(7)$ as follows.</p>
<h4 id="321-example-allencahn-equation">3.2.1. Example (Allen–Cahn equation)</h4>
<p>The example for the discrete time model deals with the Allen-Cahn equation, given the following initial condition and periodic boundary conditions:</p>
<p>$$
\begin{equation}
\begin{aligned}
&amp;u_{t} - 0.0001u_{xx} + 5 u^{3} - 5u = 0,\qquad x\in [-1, 1], t\in[0, 1], \\
&amp;u(0,x) = x^{2} \cos (\pi x), \\
&amp;u(t,-1) = u(t,1), \\
&amp;u_{x}(t,-1) = u_{x}(t,1)
\end{aligned}\tag{12}
\end{equation}
$$</p>
<p>In this example, the nonlinear operator included in $(9)$ is as follows:</p>
<p>$$
\mathcal{N}[u^{n+c_{j}}] = -0.0001u_{xx}^{n+c_{j}} + 5(u^{n+c_{j}})^{3} - 5u^{n+c_{j}}
$$</p>
<p>Let&rsquo;s denote the value of $u$ at time step $t^{n}$ as $u^{n,i}$:</p>
<p>$$
u^{n,i} = u^{n}(x^{n,i}) = u(t^{n}, x^{n,i}),\qquad i=1,\dots,N_{n}
$$</p>
<p>Since our problem is to compute $u^{n+1}$ given $u^{n}$, $\left\{ x^{n,i}, u^{n,i} \right\}_{i=1}^{N_{n}}$ is our given dataset. According to $(8)$, the following must hold for this dataset:</p>
<p>$$
u^{n,i} = u_{1}^{n}(x^{n,i}) = \cdots = u_{q+1}^{n}(x^{n,i})
$$</p>
<p>So, let&rsquo;s set the following loss function, the sum of squared error (SSE), for this:</p>
<ul>
<li>It&rsquo;s unclear why $MSE$ is not used here, but $SSE$ is used for the discrete time model. The paper uses $MSE$ for continuous time models and $SSE$ for discrete time models, which suggests there might be a reason (even if experimental).</li>
</ul>
<p>$$
SSE_{n} = \sum\limits_{j=1}^{q+1} \sum\limits_{i=1}^{N_{n}} \left| u_{j}^{n} (x^{n,i}) - u^{n,i} \right|^{2}
$$</p>
<p>Each $u_{j}^{n}$ is computed according to $(9)$, with the calculations involving $u^{n+1}$ and $u^{n+c_{j}}$ being the output of the neural network $U$. This loss corresponds to <code>net_U0</code> defined within the <code>PhysicsInformedNN</code> class in the attached code. Since the output of $U$ must satisfy the boundary conditions of $(12)$, we set the following loss function:</p>
<p>$$
\begin{align*}
SSE_{b}
&amp;= \sum\limits_{i=1}^{q} \left| u^{n+c_{i}}(-1) - u^{n+c_{i}}(1) \right|^{2} + \left| u^{n+1}(-1) - u^{n+1}(1) \right|^{2} \\
&amp;\quad+ \sum\limits_{i=1}^{q} \left| u_{x}^{n+c_{i}}(-1) - u_{x}^{n+c_{i}}(1) \right|^{2} + \left| u_{x}^{n+1}(-1) - u_{x}^{n+1}(1) \right|^{2} \\
\end{align*}
$$</p>
<p>The final loss is the sum of these two:</p>
<p>$$
SSE = SSE_{n} + SSE_{b}
$$</p>
<p><img src="figure2.png#center" alt="figure2.png"></p>
<p align=middle> Figure 2.</p>
<p>In Fig. 2, the upper image shows the heatmap of the exact solution. The lower image shows the predicted values at $t=0.9$, given the $u$ at $t=0.1$. In the lower left image, the blue line represents the exact solution, and $\color{red}\mathsf{X</p>
<p>}$ marks the points used as data. In the lower right image, the blue line is the exact solution, and the red line is the predicted solution.</p>
<p>In <a href="../3319">Implicit Runge-Kutta methods (IRK)</a>, solving simultaneous equations for all $j$ is required to compute $u^{n+c_{j}}$, meaning that the computational cost increases significantly as $q$ increases. However, the paper explains that the proposed method does not incur much additional cost even if $q$ increases. It also explains that while IRK may not be able to make accurate predictions with large time steps $\Delta t$ when $q$ is small, PINN can still make accurate predictions even with large $\Delta t$.</p>
<h2 id="4-data-driven-discovery-of-partial-differential-equations">4. Data-driven discovery of partial differential equations</h2>
<p>This chapter deals with the problem of finding the parameters $\lambda$ of the partial differential equation $(1)$ when observational data is available. The details are explained below with examples.</p>
<h3 id="41-continuous-time-models">4.1. Continuous time models</h3>
<p>Let&rsquo;s define $f$ as the left-hand side of $(1)$:</p>
<p>$$
f = u_{t} + \mathcal{N}[u; \lambda]
$$</p>
<p>The difference from $(3)$ in Section 3 is that $\lambda$ is no longer a fixed constant but an unknown parameter that needs to be learned.</p>
<h4 id="411-example-navierstokes-equation">4.1.1. Example (Navier–Stokes equation)</h4>
<p>Section 4.1.1 introduces an example related to real data of an incompressible fluid described by the Navier-Stokes equation. Consider the following 2-dimensional Navier-Stokes equation:</p>
<p>$$
\begin{equation}
\begin{aligned}
u_{t} + \lambda_{1}(uu_{x} + vu_{y}) &amp;= -p_{x} + \lambda_{2}(u_{xx} + u_{yy}) \\
v_{t} + \lambda_{1}(uv_{x} + vv_{y}) &amp;= -p_{y} + \lambda_{2}(v_{xx} + v_{yy})
\end{aligned}
\tag{15}
\end{equation}
$$</p>
<p>Here, $u(t,x,y)$ is the $x$ component of the fluid&rsquo;s velocity vector, $v(t,x,y)$ is the $y$ component. And $p(t,x,y)$ is the pressure, $\lambda = (\lambda_{1}, \lambda_{2})$ are unknown parameters. The solution to the Navier-Stokes equation satisfies the condition that the <a href="../1777">divergence</a> is $0$, hence the following holds:</p>
<p>$$
\begin{equation}
u_{x} + v_{y} = 0 \tag{17}
\end{equation}
$$</p>
<p>Let&rsquo;s assume some latent function $\psi (t, x, y)$ such that:</p>
<p>$$
u = \psi_{y},\quad v = -\psi_{x}
$$</p>
<p>In other words, the fluid&rsquo;s velocity vector is set as $\begin{bmatrix} \psi_{y} &amp; -\psi_{x}\end{bmatrix}$. This naturally satisfies $(17)$ since $u_{x} + v_{y} = \psi_{yx} - \psi_{xy} = 0$. Instead of obtaining $u$ and $v$ individually, we approximate $\psi$ with an artificial neural network and derive $u, v$ as its partial derivatives. Let&rsquo;s assume that the following measured information is available for the actual velocity vector field:</p>
<p>$$
\left\{ t^{i}, x^{i}, y^{i}, u^{i}, v^{i} \right\}_{i=1}^{N}
$$</p>
<p>From this, we set the loss function as follows, remembering that $u = \psi_{y}$ and $v = -\psi_{x}$:</p>
<p>$$
\dfrac{1}{N} \sum\limits_{i=1}^{N} \left( \left| u(t^{i}, x^{i}, y^{i}) - u^{i} \right|^{2} + \left| v(t^{i}, x^{i}, y^{i}) - v^{i} \right|^{2} \right)
$$</p>
<p>And let&rsquo;s rearrange the right-hand side of $(15)$ to the left-hand side and define them as $f$ and $g$, respectively.</p>
<p>$$
\begin{equation}
\begin{aligned}
f &amp;:= u_{t} + \lambda_{1}(uu_{x} + vu_{y}) + p_{x} - \lambda_{2}(u_{xx} + u_{yy}) \\
g &amp;:= v_{t} + \lambda_{1}(uv_{x} + vv_{y}) + p_{y} - \lambda_{2}(v_{xx} + v_{yy})
\end{aligned}\tag{18}
\end{equation}
$$</p>
<p>Then the values of $f, g$ are expressed with $\psi$ as follows. (Note that $p$ will also be approximated by a neural network)</p>
<p>$$
\begin{align*}
f &amp;= \psi_{yt} + \lambda_{1}(\psi_{y} \psi_{yx} - \psi_{x}\psi_{yy}) + p_{x} -\lambda_{2}(\psi_{yxx} + \psi_{yyy}) \\
g &amp;= -\psi_{xt} + \lambda_{1}(-\psi_{y} \psi_{xx} + \psi_{x}\psi_{xy}) + p_{y} + \lambda_{2}(\psi_{xxx} + \psi_{xyy}) \\
\end{align*}
$$</p>
<p>Add the information that $f(t^{i}, x^{i}, y^{i}) = 0 = g(t^{i}, x^{i}, y^{i})$ to the loss function, and finally set it as follows:</p>
<p>$$
\begin{aligned}
MSE &amp;:= \dfrac{1}{N} \sum\limits_{i=1}^{N} \left( \left| u(t^{i}, x^{i}, y^{i}) - u^{i} \right|^{2} + \left| v(t^{i}, x^{i}, y^{i}) - v^{i} \right|^{2} \right) \\
&amp;\qquad + \dfrac{1}{N} \sum\limits_{i=1}^{N} \left( \left| f(t^{i}, x^{i}, y^{i}) \right|^{2} + \left| g(t^{i}, x^{i}, y^{i}) \right|^{2} \right)
\end{aligned} \tag{19}
$$</p>
<p>Now let&rsquo;s define an artificial neural network with $3$ input nodes and $2$ output nodes. Let&rsquo;s assume its output to be $\begin{bmatrix} \psi (t, x, y) &amp; p(t, x, y) \end{bmatrix}$. Then, the above loss function can be computed.</p>
<p>Experiments were conducted for cases with and without noise in the data, and in both cases, it was reported that $\lambda_{1}, \lambda_{2}$ could be predicted with high accuracy. It was also demonstrated that even if data for the pressure $p$ was not provided, the neural network could accurately approximate the parameters and $p$. The specific experimental settings, results, and how the reference solutions were obtained are detailed in the paper.</p>
<h2 id="5-conclusions">5. Conclusions</h2>
<p>In this paper, we introduced the physics-informed neural network, a new structure of neural networks that is capable of encoding the physical laws satisfied by given data and can be described by partial differential equations. This result has revealed that deep learning can learn about physical models, which could be applied to various physical simulations.</p>
<p>However, the authors note that the proposed method should not be considered as a replacement for traditional methods of solving partial differential equations, such as the finite element method or spectral methods. In fact, <a href="../796">Runge-Kutta methods</a> were utilized in conjunction with PINN in <a href="#32-discrete-time-models">Section 3.2.</a>.</p>
<p>The authors also attempted to address questions about the hyperparameters required to implement PINN, such as how deep the neural network should be and how much data is needed. However, they observed that what is effective for one equation might not be effective for another.</p>


<aside style="text-align: right;">
    2022-10-19&emsp;
    전기현&emsp;
    
    <a href="../1117">🎲 3313</a>
</aside>



<script>
  document.addEventListener('DOMContentLoaded', () => {
    
    const contentBox = document.querySelector('.content-box');
    if (contentBox) {
      renderKaTex(contentBox);
    }
    const tex = document.querySelector('.tex');
    if (tex) {
      renderKaTex(tex);
    }

    var title = 'Paper Review: Physics-Informed Neural Networks';
    var link = 'https:\/\/freshrimpsushi.github.io\/en\/posts\/3313\/';
    var arr = new Array();
    var obj = {
      "title": title,
      "link": link
    };
    var postList = JSON.parse(localStorage.getItem('latelyViewPostList'));
    if (postList == '' || postList == null || postList == undefined || postList == 0 || postList == NaN) {
      arr.push(obj);
      localStorage.setItem('latelyViewPostList', JSON.stringify(arr));
    } else {
      var listSize = postList.length;
      for (var i = 0; i < listSize; i++) {
        if (title == postList[i].title) {
          postList.splice(i, 1);
          break;
        }
      }
      arr = postList;
      arr.push(obj);
      if (arr.length > 5) {
        arr.shift();
      }
      localStorage.setItem('latelyViewPostList', JSON.stringify(arr));
    }
  });
</script>

      </div>
      <aside>
<h2>Comment</h2>
<div class="area-reply">
  <div class="list-reply">
  </div>
</div>


<div class="write-box">
  <div class="write-author-info box-account">
    <input type="hidden" name="cmt_idx" />
    <input class="ai-author" type="text" value="" placeholder="Name" />
    <input class="ai-password" type="password" value="" maxlength="20" placeholder="Password" />
  </div>
  <div class="write-content">
    <textarea class="ai-content" value="" placeholder='Feel free to ask in english' style="IME-MODE:active;"></textarea>
 
  </div>
  
  <a href="javascript:void(0);" onclick="write_comment();">
    <div class="write-button">
      <i class='fa-solid fa-paper-plane'></i>
    </div>
  </a>
  <aside class="tex"> 
    $\TeX$ is also applied to comments.
    </aside>
</div>
</aside>

<script>
  let commentRows = [];
  const listReply = document.querySelector('.list-reply');

  document.addEventListener('DOMContentLoaded', () => {
    get_all_comment();
  });

  function get_all_comment() {
    fetch('https://api64.ipify.org?format=json')
      .then(res => res.json())
      .then(data => {return data.ip})
      .then(ip => {
        const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=getAllComment';
        return postFetch(url, {
                board_idx: '3313',
                user_ip: ip
              });
      })
      .then(res => res.json())
      .then(data => {
        if (data.ok) {
          commentRows = data.rows;
          render_comment(commentRows);
        }
      })
      .catch(err => console.error(err));
  }

  function render_comment(rows) {
    const badgeExceptionArr = ['류대식', '전기현', 'ㅇㅇ', '질문'];
    const adminExceptionArr = ['류대식', '전기현'];
    render_blank();
    let html = '';
    rows.map(row => {
      html += `<div id="comment${row.cmt_idx}" class="parents">`;
      html += `<div class="content-info">`;
      
      let badge = '';
      if (row.cmt_cnt > 125) {
        badge = '🥇';
      } else if (row.cmt_cnt > 25) {
        badge = '🥈';
      } else if (row.cmt_cnt > 5) {
        badge = '🥉';
      } else { }

      if (badgeExceptionArr.includes(row.author)) {
        badge = '';
      }

      let ipAddress = '';
      if (row.ip_address == null) {
        ipAddress = '(-)';
      } else {
        ipAddress = `(${row.ip_address})`;
      }

      if(adminExceptionArr.includes(row.author)) {
        ipAddress = '';
      }
      
      html += `<div class="list-author">${badge} ${row.author} ${ipAddress}</div>`;
      
      html += `<sup class="list-date">${row.datetime.slice(2, -3)}</sup>`;
      html += `<div class="list-button">`;
      html += `<div class="list-update-button" onclick="update_comment('${row.cmt_idx}', 'parents');"><i class="fa-solid fa-pen-to-square"></i></div>`; 
      html += `<div class="list-delete-button" onclick="delete_comment('${row.cmt_idx}', 'parents');"><i class="fa-solid fa-trash"></i></div>`; 
      html += `</div>`; 
      html += `</div>`; 
      if(!row.approve) {html += `<div style="text-align: right;"><i class="fa-solid fa-hourglass-start"></i> Waiting for approvement</div>`;}
      let content = row.content;
      content = content.replace(/\n/g, '<br />');
      html += `<div class="content-text">${content} <span class="re-comment-button" onclick="re_comment('${row.cmt_idx}');"><i class="fa-solid fa-reply"></i></span></div>`;
      html += `<div class="re-comment"></div>`; 
      html += `</div>`;

      row.child.map(child => {
        html += `<div id="comment${child.cmt_idx}" class="child">`;
        html += `<div class="content-info">`;
        
        let badge = '';
        if (child.cmt_cnt > 5) {
          badge = '🥉';
        } else if (child.cmt_cnt > 25) {
          badge = '🥈';
        } else if (child.cmt_cnt > 125) {
          badge = '🥇';
        } else { }

        if (badgeExceptionArr.includes(child.author)) {
          badge = '';
        }

        let ipAddress = '';
        if (child.ip_address == null) {
          ipAddress = '(-)';
        } else {
          ipAddress = `(${child.ip_address})`;
        }

        if(adminExceptionArr.includes(child.author)) {
          ipAddress = '';
        }

        html += `<div class="list-author">${badge} ${child.author} ${ipAddress}</div>`;
        
        html += `<sup class="list-date">${row.datetime.slice(2, -3)}</sup>`;
        html += `<div class="list-button">`;
        html += `<div class="list-update-button" onclick="update_comment('${child.cmt_idx}', 'child');"><i class="fa-solid fa-pen-to-square"></i></div>`; 
        html += `<div class="list-delete-button" onclick="delete_comment('${child.cmt_idx}', 'child');"><i class="fa-solid fa-trash"></i></div>`; 
        html += `</div>`; 
        html += `</div>`; 
        if(!child.approve) {html += `<div style="text-align: right;"><i class="fa-solid fa-hourglass-start"></i> Waiting for approvement</div>`;}
        let content = child.content;
        content = content.replace(/\n/g, '<br />');
        html += `<div class="content-text">${content}</div>`;
        html += `</div>`;
      });
    });
    listReply.innerHTML = html;
    renderKaTex(listReply);
    if(location.href.indexOf('#') != -1) {
      location.href=location.href.substr(location.href.indexOf('#'));
  }
  }

  function render_blank() {
    listReply.innerHTML = '';
  }

  
  function write_comment() {
    const inputAuthor = document.querySelector('.ai-author');
    const inputPassword = document.querySelector('.ai-password');
    const inputContent = document.querySelector('.ai-content');

    const author = inputAuthor.value;
    const password = inputPassword.value;
    const content = inputContent.value;

    if (author === '' || password === '' || content === '') {
      alert('빈칸을 채워주세요');
      return;
    }
    const idx = '3313';
    const board_slug = 'physics-informed-neural-networks';
    const board_title = 'Paper Review: Physics-Informed Neural Networks';

    fetch('https://api64.ipify.org?format=json')
      .then(res => res.json())
      .then(data => {return data.ip})
      .then(ip => {
        const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=writeComment';
        return postFetch(url, {
                board_idx: idx,
                board_slug: board_slug,
                board_title: board_title,
                author: author.replace(/\+/g, "%2B"),
                password: password,
                content: content.replace(/\+/g, "%2B"),
                user_ip: ip
              });
      })
      .then(res => res.json())
      .then(data => {
        if (data.ok) {
          commentRows.push(data.row);
          render_comment(commentRows);
          inputAuthor.value = '';
          inputPassword.value = '';
          inputContent.value = '';
        } else {
          if (data.status === 606) {
            Swal.fire('Warning!\n지속적인 도배 시도시\nIP가 차단될 수 있습니다.');
            inputAuthor.value = '';
            inputPassword.value = '';
            inputContent.value = '';
          } else if (data.status === 607) {
            alert('지나친 댓글 도배를 확인하여\n접근을 차단합니다.');
            window.location.href = 'https://google.com';
          } else {}
        }
      })
      .catch(err => console.error(err));
  }

  
  async function update_comment(cmt_idx, type) {
    const { value: password } = await Swal.fire({
      title: '댓글 수정',
      input: 'password',
      inputPlaceholder: '글 작성 시 입력했던 패스워드를 입력하세요',
      inputAttributes: {
        maxlength: 20,
        autocapitalize: 'off',
        autocorrect: 'off'
      }
    });

    if (password) {
      const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=checkPassword';
      postFetch(url, {
        cmt_idx: cmt_idx,
        password: password
      })
        .then(res => res.json())
        .then(data => {
          if (data.ok) {
            const commnetHtml = document.querySelector(`#comment${cmt_idx}`);
            const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=getComment';
            postFetch(url, {
              cmt_idx: cmt_idx
            })
              .then(res => res.json())
              .then(data => {
                if (data.ok) {
                  const row = data.row;
                  const author = row.author;
                  const content = row.content;
                  let html = '';
                  html += `<div class="update-author-info">`;
                  html += `<input class="update-author" type="text" value="${author}" placeholder="이름" />`;
                  html += `<input class="update-password" type="password" value="${password}" placeholder="비밀번호" disabled />`;
                  html += '</div>';
                  html += `<textarea class="update-content" value="" style="IME-MODE:active;">${content}</textarea>`;
                  html += `<input class="update_comment-button" type="submit" value="수정" onclick="update_comment_click(${cmt_idx}, '${type}')" />`;
                  html += `<input class="update_comment-button" type="submit" value="취소" onclick="cancel_click(${cmt_idx})" />`;
                  commnetHtml.innerHTML = html;
                }
              })
              .catch(err => console.error(err));
          } else {
            Swal.fire('패스워드 일치 오류');
          }
        })
        .catch(err => console.error(err));
    }
  }

  
  async function delete_comment(cmt_idx, type) {
    const { value: password } = await Swal.fire({
      title: '댓글 삭제',
      text: "삭제하면 되돌릴 수 없습니다.",
      input: 'password',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      inputPlaceholder: '글 작성 시 입력했던 패스워드를 입력하세요',
      inputAttributes: {
        maxlength: 20,
        autocapitalize: 'off',
        autocorrect: 'off'
      }
    });

    if (password) {
      const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=checkPassword';
      postFetch(url, {
        cmt_idx: cmt_idx,
        password: password
      })
        .then(res => res.json())
        .then(data => {
          if (data.ok) {
            const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=deleteComment';
            postFetch(url, {
              cmt_idx: cmt_idx
            })
              .then(res => res.json())
              .then(data => {
                Swal.fire('삭제되었습니다.');
                if (type === 'parents') {
                  commentRows = commentRows.filter((row) => row.cmt_idx !== cmt_idx);
                } else if (type === 'child') {
                  commentRows.map((row) => {
                    row.child = row.child.filter((childRow) => childRow.cmt_idx !== cmt_idx);
                    row.child_cnt = row.child.length;
                  });
                } else { }
                render_comment(commentRows);
              })
              .catch(err => console.error(err));
          } else {
            Swal.fire('패스워드 일치 오류');
          }
        })
        .catch(err => console.error(err));
    }
  }

  
  function update_comment_click(cmt_idx, type) {
    const inputAuthor = document.querySelector(`#comment${cmt_idx} .update-author`);
    const inputPassword = document.querySelector(`#comment${cmt_idx} .update-password`);
    const inputContent = document.querySelector(`#comment${cmt_idx} .update-content`);

    const author = inputAuthor.value;
    const password = inputPassword.value;
    const content = inputContent.value;

    if (author === '' || password === '' || content === '') {
      alert('빈칸을 채워주세요');
    }

    const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=updateComment';
    postFetch(url, {
      cmt_idx: cmt_idx,
      author: author.replace(/\+/g, "%2B"),
      password: password,
      content: content.replace(/\+/g, "%2B")
    })
      .then(res => res.json())
      .then(data => {
        if (data.ok) {
          Swal.fire('수정되었습니다.');
          if (type === 'parents') {
            commentRows.map((row) => {
              if (row.cmt_idx == cmt_idx) {
                row.author = data.author;
                row.content = data.content;
              }
            });
          } else if (type === 'child') {
            commentRows.map((row) => {
              if (row.cmt_idx == data.parent_cmt_idx) {
                row.child.map((child) => {
                  if (child.cmt_idx == cmt_idx) {
                    child.author = data.author;
                    child.content = data.content;
                  }
                });
              }
            });
          } else { }
          render_comment(commentRows);
          recentRows.map((row) => {
            if (row.cmt_idx == cmt_idx) {
              row.author = data.author;
              row.content = data.content;
            }
          });
          render_recent_comment(recentRows);
        }
      })
      .catch(err => console.error(err));
  }

  
  function cancel_click() {
    render_comment(commentRows);
  }

  
  function re_comment(cmt_idx) {
    const reComment = document.querySelector(`#comment${cmt_idx} .re-comment`);
    let html = '';
    html += '<div class="re-comment-box">';
    html += '<div class="re-comment-author-info">';
    html += '<input class="re-comment-author" type="text" value="" placeholder="이름" />';
    html += '<input class="re-comment-password" type="password" value="" placeholder="비밀번호" />';
    html += '</div>';
    html += '<textarea class="re-comment-content" placeholder="내용" value="" style="IME-MODE:active;"></textarea>';
    
    
    html += `<a href="javascript:void(0);" onclick="cancel_click(${cmt_idx});"><div class="write-button"><i class="fa-solid fa-ban"></i></i></div></a>`; 
    html += `<a href="javascript:void(0);" onclick="re_comment_click(${cmt_idx});"><div class="write-button"><i class='fa-solid fa-paper-plane'></i></div></a>`; 
    html += '</div>';
   
    reComment.innerHTML = html;
  }

  function re_comment_click(cmt_idx) {
    const inputAuthor = document.querySelector(`#comment${cmt_idx} .re-comment-author`);
    const inputPassword = document.querySelector(`#comment${cmt_idx} .re-comment-password`);
    const inputContent = document.querySelector(`#comment${cmt_idx} .re-comment-content`);

    const author = inputAuthor.value;
    const password = inputPassword.value;
    const content = inputContent.value;

    if (author === '' || password === '' || content === '') {
      alert('빈칸을 채워주세요');
      return;
    }

    const board_idx = '3313';
    const board_slug = 'physics-informed-neural-networks';
    const board_title = 'Paper Review: Physics-Informed Neural Networks';

    fetch('https://api64.ipify.org?format=json')
      .then(res => res.json())
      .then(data => {return data.ip})
      .then(ip => {
        const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/comment.php?action=writeReComment';
        return postFetch(url, {
                board_idx: board_idx,
                board_slug: board_slug,
                board_title: board_title,
                cmt_idx: cmt_idx,
                author: author.replace(/\+/g, "%2B"),
                password: password,
                content: content.replace(/\+/g, "%2B"),
                user_ip: ip
              });
      })
      .then(res => res.json())
      .then(data => {
        if (data.ok) {
          commentRows.map((row) => {
            if (row.cmt_idx == cmt_idx) {
              row.child.push(data.row);
            }
          });
          render_comment(commentRows);
        } else {
          if (data.status == 606) {
            Swal.fire('Warning!\n지속적인 도배 시도시\nIP가 차단될 수 있습니다.');
            inputAuthor.value = '';
            inputPassword.value = '';
            inputContent.value = '';
          } else if (data.status === 607) {
            alert('지나친 댓글 도배를 확인하여\n접근을 차단합니다.');
            window.location.href = 'https://google.com';
          } else {}
        }
      })
      .catch(err => console.error(err));
  }

</script>
    </div>
    <aside>
<div class="sidebar">

<div class="category">
</div>

<div style="display:flex;">

Click ● to highlight only you interested.

      <div class="resetmute">
        <button class="sb-btn btnReset"
          style = "border-radius:5px; border:0px">reset</button>
        <button class="sb-btn btnMute"
          style = "border-radius:5px; border:0px">mute</button>
      </div>
</div>


 

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  



<script>
  const color = {green: '#33cc33', yellow: '#ffcc00', red: '#ff3333', black: '#000000'};
  const categoryRows = [
    [
      { idx: 1, name: '함수', color: color.red, show: '함수', size: '112'},
      { idx: 2, name: '보조정리', color: color.red, show: '보조정리', size: '29'},
      { idx: 3, name: '집합론', color: color.green, show: 'SetTheory', size: '47'},
      { idx: 4, name: '정수론', color: color.green, show: 'NumberTheory', size: '89'},
      { idx: 5, name: '기하학', color: color.red, show: '기하학', size: '147'},
      { idx: 6, name: '행렬대수', color: color.red, show: '행렬대수', size: '91'},
      { idx: 7, name: '선형대수', color: color.red, show: '선형대수', size: '92'},
      { idx: 8, name: '추상대수', color: color.green, show: 'AbstractAlgebra', size: '92'},
      { idx: 9, name: '위상수학', color: color.green, show: 'Topology', size: '64'},
      { idx: 10, name: '그래프이론', color: color.green, show: 'GraphTheory', size: '57'}
    ],
    [
      { idx: 1, name: '해석개론', color: color.red, show: '해석개론', size: '97'},
      { idx: 2, name: '다변수벡터해석', color: color.red, show: '다변수벡터해석', size: '22'},
      { idx: 3, name: '복소해석', color: color.green, show: 'ComplexAnaylsis', size: '71'},
      { idx: 4, name: '측도론', color: color.green, show: 'MeasureTheory', size: '53'},
      { idx: 5, name: '푸리에해석', color: color.red, show: '푸리에해석', size: '52'},
      { idx: 6, name: '초함수론', color: color.red, show: '초함수론', size: '23'},
      { idx: 7, name: '단층촬영', color: color.red, show: '단층촬영', size: '19'},
    ],
    [
      { idx: 1, name: '거리공간', color: color.green, show: 'MetricSpace', size: '38'},
      { idx: 2, name: '바나흐공간', color: color.green, show: 'BanachSpace', size: '37'},
      { idx: 3, name: '힐베르트공간', color: color.red, show: '힐베르트공간', size: '31'},
      { idx: 4, name: '르벡공간', color: color.red, show: '르벡공간', size: '33'}
    ],
    [
      { idx: 1, name: '상미분방정식', color: color.red, show: '상미분방정식', size: '58'},
      { idx: 2, name: '편미분방정식', color: color.red, show: '편미분방정식', size: '58'},
      { idx: 3, name: '확률미분방정식', color: color.green, show: 'SDE', size: '25'}
    ],
    [
      { idx: 1, name: '매트랩', color: color.green, show: 'MATLAB', size: '16'},
      { idx: 2, name: '수치해석', color: color.green, show: 'NumericalAnalysis', size: '55'},
      { idx: 3, name: '최적화이론', color: color.green, show: 'Optimization', size: '37'}
    ],
    [
      { idx: 1, name: '물리학', color: color.red, show: '물리학', size: '17'},
      { idx: 2, name: '수리물리', color: color.red, show: '수리물리', size: '70'},
      { idx: 3, name: '고전역학', color: color.red, show: '고전역학', size: '44'},
      { idx: 4, name: '전자기학', color: color.red, show: '전자기학', size: '51'},
      { idx: 5, name: '양자역학', color: color.red, show: '양자역학', size: '37'},
      { idx: 6, name: '열물리학', color: color.red, show: '열물리학', size: '29'}
    ],
    [
      { idx: 1, name: 'R', color: color.green, show: 'R', size: '53'},
      { idx: 2, name: '데이터확보', color: color.green, show: 'DataSets', size: '22'},
      { idx: 3, name: '데이터과학', color: color.green, show: 'DataScience', size: '24'},
      { idx: 4, name: '통계적검정', color: color.green, show: 'StatisticalTest', size: '22'},
      { idx: 5, name: '통계적분석', color: color.green, show: 'StatisticalAnalysis', size: '71'},
      { idx: 6, name: '수리통계학', color: color.green, show: 'MathematicalStatistics', size: '110'},
      { idx: 7, name: '확률분포론', color: color.green, show: 'ProbabilityDistribution', size: '72'},
      { idx: 8, name: '확률론', color: color.green, show: 'ProbabilityTheory', size: '74'},
      { idx: 9, name: '위상데이터분석', color: color.green, show: 'TDA', size: '40'}
    ],
    [
      { idx: 1, name: '줄리아', color: color.green, show: 'Julia', size: '191'},
      { idx: 2, name: '프로그래밍', color: color.red, show: 'Programming', size: '55'},
      { idx: 3, name: '알고리즘', color: color.green, show: 'Algorithm', size: '28'},
      { idx: 4, name: '머신러닝', color: color.green, show: 'MachineLearning', size: '79'},
      { idx: 5, name: '세이버메트릭스', color: color.green, show: 'Sabermetrics', size: '191', size: '12'},
      { idx: 6, name: '논문작성', color: color.green, show: 'Writing', size: '20'},
      { idx: 7, name: '교과과정', color: color.green, show: 'HighschoolMath', size: '54'},
      { idx: 8, name: '생새우초밥지', color: color.black , show: 'JOF', size: '3'}
    ]
  ];

  document.addEventListener('DOMContentLoaded', () => {
    const blindList = JSON.parse(localStorage.getItem('blindList'));
    if (blindList == '' || blindList == null || blindList == undefined || blindList == 0 || blindList == NaN) {
      localStorage.setItem('blindList', null);
    }
    render_category(categoryRows);

    blind_category(blindList);

    const btnReset = document.querySelector('.btnReset');
    btnReset.addEventListener('click', () => {
      let arr = new Array();
      localStorage.setItem('blindList', JSON.stringify(arr));
      blind_category(arr);
    });

    const btnMute = document.querySelector('.btnMute');
    btnMute.addEventListener('click', () => {
      let arr = new Array();
      for(let i = 0; i < categoryRows.length; i++) {
        categoryRows[i].map(row => {
          const data = {mainIdx: i, subIdx: row.idx};
          arr.push(data);
        });
      }
      localStorage.setItem('blindList', JSON.stringify(arr));
      blind_category(arr);
    });
  });

  function render_category(rows)
  {
    const category = document.querySelector('.category');
    let html = '';
    for(let i = 0; i < rows.length; i++) {
      rows[i].map(row => {
        html += `<span id="cate${i}-${row.idx}" class="cate etewsert">`;
        html += `<span onclick="check_blind(${i}, ${row.idx});" style="cursor: pointer; color: ${row.color}">●</span>`;
        html += `<a href="https:\/\/freshrimpsushi.github.io\/en\/categories/${row.name.toLowerCase()}/">`; 
        html += ` ${row.show} (${row.size})</a>`;
        html += '</span>';
        if(screen.width > 954) {html += '<br>'} else {html += ' '}
      });
      html += '<hr>';
    }

    category.innerHTML = html;
  }

   
  function check_blind(mainIdx, subIdx)
  {
    const cateDiv = document.querySelector(`#cate${mainIdx}-${subIdx}`);
    let arr = new Array();
    const data = {mainIdx, subIdx};
    let blindList = JSON.parse(localStorage.getItem('blindList'));
    if (blindList == '' || blindList == null || blindList == undefined || blindList == 0 || blindList == NaN) {
      arr.push(data);
      localStorage.setItem('blindList', JSON.stringify(arr));
      cateDiv.className += ' blind';
    } else {
      arr = blindList;
      let tempArr = null;
      for(let i = 0; i < arr.length; i++) {
        if(arr[i].mainIdx == mainIdx && arr[i].subIdx == subIdx) {
          tempArr = arr.filter(a => a.mainIdx != mainIdx || a.subIdx != subIdx);
          break;
        }
      }
      
      if(tempArr === null) {
        arr.push(data);
        localStorage.setItem('blindList', JSON.stringify(arr));
        cateDiv.className += ' blind';
      } else {
        localStorage.setItem('blindList', JSON.stringify(tempArr));
        cateDiv.className = 'cate';
      }
    }
  }

   
  function blind_category(blindList)
  {
    const cateDiv = document.querySelectorAll('.cate');
    cateDiv.forEach(div => {
      div.className = 'cate';
    });
    if(blindList !== null) {
      blindList.map(list => {
        const blindDiv = document.querySelector(`#cate${list.mainIdx}-${list.subIdx}`);
        blindDiv.className += ' blind';
      });
    }
  }
</script>
<br>
<b>Viewed posts</b>

<div class="lately-viewed-list" style="padding-left: 4px;">
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const postList = JSON.parse(localStorage.getItem('latelyViewPostList'));

    const list = document.querySelector('.lately-viewed-list');
    let html = '';
    if (postList == '' || postList == null || postList == undefined || postList == 0 || postList == NaN) {
      localStorage.setItem('latelyViewPostList', null);
      html += '<div class="lv-list">';
      html += ' · 열람한 포스트가 없습니다.';
      html += '</div>';
      list.innerHTML = html;
    } else {
      for (let i = (postList.length - 1); i >= 0; i--) {
        html += '<div class="lv-list">';
        html += `<a href="${postList[i].link}"> · ${postList[i].title}</a>`;
        html += '</div>';
      }
      list.innerHTML = html;
    }
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    
    const contentBox = document.querySelector('.content-box');
    if (contentBox) {
      renderKaTex(contentBox);
    }
    const tex = document.querySelector('.tex');
    if (tex) {
      renderKaTex(tex);
    }

    var title = 'Paper Review: Physics-Informed Neural Networks';
    var link = 'https:\/\/freshrimpsushi.github.io\/en\/posts\/3313\/';
    var arr = new Array();
    var obj = {
      "title": title,
      "link": link
    };
    var postList = JSON.parse(localStorage.getItem('latelyViewPostList'));
    if (postList == '' || postList == null || postList == undefined || postList == 0 || postList == NaN) {
      arr.push(obj);
      localStorage.setItem('latelyViewPostList', JSON.stringify(arr));
    } else {
      var listSize = postList.length;
      for (var i = 0; i < listSize; i++) {
        if (title == postList[i].title) {
          postList.splice(i, 1);
          break;
        }
      }
      arr = postList;
      arr.push(obj);
      if (arr.length > 5) {
        arr.shift();
      }
      localStorage.setItem('latelyViewPostList', JSON.stringify(arr));
    }
  });
</script>

<br>
<b>Recent comment</b>
<div class="current-reply">
</div>

<script>
  const url = 'https:\/\/freshrimpsushi.com\/blog\/ajax/recent_comment.php?action=getCurrentComment';
  let recentRows = []; 
  fetch(url)
    .then(res => res.json())
    .then(data => {
      if (data.ok) {
        recentRows = data.rows;
        render_recent_comment(recentRows);
      }
    })
    .catch(err => console.error(err));

  
  function render_recent_comment(rows) {
    const currentReply = document.querySelector('.current-reply');
    let html = '';
    rows.map(row => {
      let link = 'https:\/\/freshrimpsushi.github.io\/en\/';
      if (row.board_idx > -1) {
        
        
        link += `posts/${row.board_idx}#comment${row.cmt_idx}`;
      } else if (row.board_idx == -1) {
        link += `#comment${row.cmt_idx}`;
      } else {
        link += `categories/${row.board_title}#comment${row.cmt_idx}`;
      }
      html += '<div class="current-reply-list">';
      html += `<a href="${link}">`;
      html += `<b> - ${row.author}</b>: `;
      html += `${row.content}`;
      html += `</a>`;
      html += `</div>`;
    });
    currentReply.innerHTML = html;
    renderKaTex(currentReply);
  }
</script>
</div>
</aside>
  </div>
  
  <footer>
  <aside>
    <div>
      <p style="text-align: center">© FreshrimpRestaurant / Powered by 류대식, 전기현
      <br><img src=https://freshrimpsushi.github.io/en/logo/gmail.png width=16px> Contact:
        freshrimpsushi@gmail.com
      </p>
    </div>

    
    
    <link rel="stylesheet" href=https://freshrimpsushi.github.io/en/css/codefence.css>
    <script src=https://freshrimpsushi.github.io/en/js/highlight.min.js></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    
  </aside>
</footer>

  

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.js"
  integrity="sha512-5ufNcHqOYgilGEHPfuRIQ5B/vDS1M8+UC+DESZ5CwVgGTg+b2Ol/15rYL/GiCWJ/Sx8oVo0FPFok1dPk8U9INQ=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js"
  integrity="sha512-ZA/RPrAo88DlwRnnoNVqKINnQNcWERzRK03PDaA4GIJiVZvGFIWQbdWCsUebMZfkWohnfngsDjXzU6PokO4jGw=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
  
  function renderKaTex(target) {
    renderMathInElement(target, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
      ],
      trust: true,
      trust: (context) =>
        ["\\htmlId", "\\href", "\\includegraphics"].includes(context.command),
      macros: {
        "\\eqref": "(\\text{#1})",
        "\\ref": "\\href{###1}{\\text{#1}}",
        "\\label": "\\htmlId{#1}{}",
        "\\sech": "\\operatorname{sech}",
        "\\sgn": "\\operatorname{sgn}",
        "\\sign": "\\operatorname{sign}",
        "\\sinc": "\\operatorname{sinc}",
        "\\diag": "\\operatorname{diag}",
        "\\diam": "\\operatorname{diam}",
        "\\Tr": "\\operatorname{Tr}",
        "\\tr": "\\operatorname{tr}",
        "\\Re": "\\operatorname{Re}",
        "\\Im": "\\operatorname{Im}",
        "\\Var": "\\operatorname{Var}",
        "\\Poi": "\\operatorname{Poi}",
        "\\Cov": "\\operatorname{Cov}",
        "\\span": "\\operatorname{span}",
        "\\supp": "\\operatorname{supp}",
        "\\rank": "\\operatorname{rank}",
        "\\nullity": "\\operatorname{nullity}",
        "\\Ric": "\\operatorname{Ric}",
        "\\i": "\\mathrm{i}",
        "\\d": "\\mathrm{d}",
        "\\cR": "\\includegraphics[height=0.6em]{https://freshrimpsushi.com/community/data/editor/2202/2615581243_1645770096.5863.png}",
        "\\acR": "\\includegraphics[height=0.6em]{https://freshrimpsushi.com/community/data/editor/2304/2175452104_1680634690.4371.png}",
        "\\bcR": "\\includegraphics[height=0.6em]{https://freshrimpsushi.com/community/data/editor/2202/2615581243_1645770096.5899.png}",
        "\\abcR": "\\includegraphics[height=0.6em]{https://freshrimpsushi.com/community/data/editor/2304/2175452104_1680634690.0596.png}",
        "\\crH": "\\includegraphics[height=0.8em]{https://freshrimpsushi.com/community/data/editor/2304/2175452104_1680622958.7632.png}",
        "\\smallcrH": "\\includegraphics[height=0.6em]{https://freshrimpsushi.com/community/data/editor/2304/2175452104_1680622958.7632.png}",
        "\\acrH": "\\includegraphics[height=0.8em]{https://freshrimpsushi.com/community/data/editor/2304/2175452104_1680634690.8386.png}",
        "\\smallacrH": "\\includegraphics[height=0.6em]{https://freshrimpsushi.com/community/data/editor/2304/2175452104_1680634690.8386.png}",
      },
      throwOnError: false,
    });
  }
</script>
</body>

</html>