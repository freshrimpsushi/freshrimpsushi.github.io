<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Julia on FreshrimpRestaurant</title><link>https://freshrimpsushi.github.io/en/categories/%EC%A4%84%EB%A6%AC%EC%95%84/</link><description>Recent content in Julia on FreshrimpRestaurant</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 15 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/en/categories/%EC%A4%84%EB%A6%AC%EC%95%84/index.xml" rel="self" type="application/rss+xml"/><item><title>How to View Folder Tree Structures in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3704/</link><pubDate>Mon, 15 Sep 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3704/</guid><description>Code A function to output the folder tree structure is not provided by default. You can use the FileTree(path) function provided by the FileTrees.jl package. Environment OS: Windows11 Version: Julia 1.11.3, FileTrees v0.3.10</description></item><item><title>How to Browse Files and Paths in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3703/</link><pubDate>Sat, 13 Sep 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3703/</guid><description>Code The function used to traverse a folder and obtain a list of subfolders and files is walkdir(path). Suppose a folder structure is as follows. A/ ├─ B/ │ ├─ BB/ │ │ └─ bbb.py │ ├─ b.py │ └─ bb.csv ├─ C/ │ ├─ CC/ │ │ └─ c.txt │ └─ c.jl ├─ a.txt └─ aa.py With the</description></item><item><title>Comprehensive Summary of Julia String Syntax and Functions</title><link>https://freshrimpsushi.github.io/en/posts/3691/</link><pubDate>Wed, 20 Aug 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3691/</guid><description>Overview This document provides a brief overview of the syntax and functions related to characters/strings used in Julia. The version reference is Julia v1.11.5. Official Documentation Manual&amp;gt;Strings: https://docs.julialang.org/en/v1/manual/strings/ Base&amp;gt;Strings: https://docs.julialang.org/en/v1/base/strings/ Summary Definition 'x' &amp;quot;x&amp;quot; repr(foo) Char(decimal) Char(hex) Operations &amp;quot;foo&amp;quot; &amp;lt; &amp;quot;bar&amp;quot; &amp;quot;foo&amp;quot; &amp;gt; &amp;quot;bar&amp;quot; &amp;quot;foo&amp;quot; == &amp;quot;bar&amp;quot; &amp;quot;foo&amp;quot; != &amp;quot;bar&amp;quot; isless(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;) Predicates isspace(' ') isletter('x') isuppercase('X') islowercase('x') isdigit('1') isxdigit('x') isnumeric('1') ispunct('!') isascii(&amp;quot;foo&amp;quot;) iscntrl('x') isprint('x') General length(&amp;quot;foo bar&amp;quot;) sizeof(&amp;quot;foo bar&amp;quot;)</description></item><item><title>How to Add a New Column to the First Column in a Julia DataFrame</title><link>https://freshrimpsushi.github.io/en/posts/2654/</link><pubDate>Sun, 25 May 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2654/</guid><description>Code Adding a new column itself is not particularly difficult, but it can be tricky to add it at a specific position. insertcols! julia&amp;gt; df = DataFrame(a = 1:3, b = 4:6) 3×2 DataFrame Row │ a b │ Int64 Int64 ─────┼────────────── 1 │ 1 4 2 │ 2</description></item><item><title>How to Recursively Retrieve a List of Files under a Specific Path in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2652/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2652/</guid><description>Code walkdir julia&amp;gt; walkdir(&amp;#34;D:\\U\\B&amp;#34;) Channel{Tuple{String, Vector{String}, Vector{String}}}(0) (1 item available) julia&amp;gt; collect(walkdir(&amp;#34;D:\\U\\B&amp;#34;)) 2-element Vector{Tuple{String, Vector{String}, Vector{String}}}: (&amp;#34;D:\\U\\B&amp;#34;, [&amp;#34;b&amp;#34;], [&amp;#34;alpha.txt&amp;#34;, &amp;#34;beta.txt&amp;#34;]) (&amp;#34;D:\\U\\B\\b&amp;#34;, [], [&amp;#34;m.txt&amp;#34;]) walkdir is a built-in function that explores all files under a given path. By itself, it is an iterator containing tuples with file information, which can be accessed as an array through functions like collect. However, dealing with this function without any knowledge can be quite tricky,</description></item><item><title>Tricks for Concatenating Arrays of Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2650/</link><pubDate>Sat, 17 May 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2650/</guid><description>Overview In Julia, although you can concatenate arrays using functions like append!, the bang convention implies that the original array is modified as a side effect. To avoid this, we introduce a trick using the splat operator .... Code Merging Arrays of Different Lengths julia&amp;gt; y = [[3, 1, 4], [1, 5], [9, 2]] 3-element Vector{Vector{Int64}}: [3, 1, 4] [1, 5] [9, 2] julia&amp;gt; [y...;] 7-element Vector{Int64}: 3 1 4</description></item><item><title>How to Check the Integrated Development Environment (IDE) for Running Julia</title><link>https://freshrimpsushi.github.io/en/posts/2646/</link><pubDate>Fri, 09 May 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2646/</guid><description>Guide When executing code in an IDE (Integrated Development Environment) such as vscode, it&amp;rsquo;s common to change settings based on the development stage. To check this, you can refer to environment variables like ENV[&amp;quot;TERM_PROGRAM&amp;quot;] == &amp;quot;vscode&amp;quot;. Precautions When executed directly in the terminal, no indication of a program is present, leading to an error being raised as shown above. Hence, when development and execution must be combined, it is advisable</description></item><item><title>How to View the First and Last Parts of a DataFrame in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2644/</link><pubDate>Mon, 05 May 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2644/</guid><description>Overview In Julia, DataFrames do not have head or tail functions. Although it&amp;rsquo;s a bit annoying because it requires an extra step compared to other languages, you can use the first and last functions. Why does DataFrames.jl stubbornly ignore industry conventions? This can roughly be summarized as follows1: : There&amp;rsquo;s already a Base.tail function in Base, and they want to avoid conflicts. first and last were already implemented for the</description></item><item><title>How to Install unofficial Packages in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2642/</link><pubDate>Thu, 01 May 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2642/</guid><description>Guide For unofficial packages, it is sometimes explained as a complex process requiring registration and so on, but in reality, it can be installed just by having the GitHub address1. Suppose the GitHub remote repository address of the package you want to install is https://github.com/JuliaLang/Example.jl. Pkg using Pkg; Pkg.add(url=&amp;#34;https://github.com/JuliaLang/Example.jl&amp;#34;) This is the method using the Pkg package. Package Management Mode ] add https://github.com/JuliaLang/Example.jl This is a method to enter the</description></item><item><title>How to Add a Column Filled with the Same Value to a Julia DataFrame</title><link>https://freshrimpsushi.github.io/en/posts/2640/</link><pubDate>Sun, 27 Apr 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2640/</guid><description>Code Fundamentally, this is similar to the method to add a new column, but initialization can be easily performed without creating a separate column by applying broadcasting to the assignment operation = using .=. julia&amp;gt; df = DataFrame(rand(3, 4), :auto) 3×4 DataFrame Row │ x1 x2 x3 x4 │ Float64 Float64 Float64 Float64 ─────┼─────────</description></item><item><title>How to Use l1 Trend Filtering in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2632/</link><pubDate>Fri, 11 Apr 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2632/</guid><description>Overview L1TrendFiltering.jl is a Julia package that translates the $\ell_{1}$ trend filtering code originally implemented in MATLAB1. The $\ell_{1}$ finds the solution $x = \left\{ x_{t} \right\}_{t=1}^{n}$ to the following optimization problem for the given time series data $y = \left\{ y_{t} \right\}_{t = 1}^{n}$ and $\lambda \ge 0$2. $$ \argmin_{x} {\frac{ 1 }{ 2 }} \left\| y - x \right\|_{2}^{2} + \lambda \left\| D x \right\|_{1} $$ Here, the</description></item><item><title>Julia's Permutation Dimension Function and Its Application permutedims</title><link>https://freshrimpsushi.github.io/en/posts/834/</link><pubDate>Mon, 24 Mar 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/834/</guid><description>Overview The built-in function permutedims in Julia can be seen as a generalization of transpose matrix and is useful for handling dimensions of multi-dimensional arrays. Code Tensor Dimension Transformation julia&amp;gt; A = reshape(Vector(1:8), (2,2,2)) 2×2×2 Array{Int64, 3}: [:, :, 1] = 1 3 2 4 [:, :, 2] = 5 7 6 8 julia&amp;gt; B = permutedims(A, (3, 1, 2)) 2×2×2 Array{Int64,</description></item><item><title>Numerical solution of ordinary differential equations with external forces (Julia DifferentialEquations Package)</title><link>https://freshrimpsushi.github.io/en/posts/1083/</link><pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1083/</guid><description>Explanation DifferentialEquations.jl is a Julia package for numerical solutions of differential equations. In this article, we will introduce how to find a numerical solution of an ordinary differential equation with a forcing term using DifferentialEquations.jl. Reading the tutorial might be helpful. First-order ODE with Forcing Term Consider the following simple problem. $$ \begin{align*} \dfrac{du(t)}{dt} &amp;amp;= u(t) + \sin(t) \qquad t \in [0, 1] \\ u(0) &amp;amp;= 0.0 \end{align*} $$ Solving</description></item><item><title>How to Read Excel XLSX Files in Julia</title><link>https://freshrimpsushi.github.io/en/posts/242/</link><pubDate>Tue, 10 Dec 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/242/</guid><description>Overview Introducing how to read *.XLSX files, which are Excel workbook extensions, in Julia. Although it is somewhat more complex than reading CSV files, in scenarios where you must use *.XLSX files due to the nature of the data or the sheer number of such files, it&amp;rsquo;s inevitable to use them1. Code For instance, assume that the example.xlsx file contains alpha, beta sheets as follows. Specifically, beta has a detached</description></item><item><title>How to Check the Operating System in Julia</title><link>https://freshrimpsushi.github.io/en/posts/233/</link><pubDate>Fri, 06 Dec 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/233/</guid><description>Overview Julia is a language specialized for scientific computing, and thus you often need to deploy and execute programs on multiple servers, necessitating writing code that can handle various operating systems. Code To check the operating system, use the Sys module1. Sys.iswindows julia&amp;gt; Sys.islinux() false julia&amp;gt; Sys.iswindows() true In addition to the most commonly used islinux and iswindows, there are also isapple, isbsd, isfreebsd, and isunix. Notably, isunix encompasses all</description></item><item><title>How to Swap the Horizontal and Vertical Axes in Julia</title><link>https://freshrimpsushi.github.io/en/posts/179/</link><pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/179/</guid><description>Overview This article introduces a method to swap the horizontal and vertical axes in Julia. Code By using permute = (:y, :x) as an argument in the plot function, you can change the order of the axes. bar(name, height) bar(name, height, permute = (:y, :x)) Full Code using Plots name = [&amp;#34;Gaeul&amp;#34;, &amp;#34;Yujin&amp;#34;, &amp;#34;Rei&amp;#34;, &amp;#34;Wonyoung&amp;#34;, &amp;#34;Liz&amp;#34;, &amp;#34;Leeseo&amp;#34;] height = [164, 173, 170, 173, 171, 165] bar(name, height) bar(name, height, permute</description></item><item><title>How to Use the Symbol of Pi on the Axis in Julia</title><link>https://freshrimpsushi.github.io/en/posts/127/</link><pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/127/</guid><description>Overview In Julia, this document explains how to directly use the pi symbol on ticks. It doesn&amp;rsquo;t necessarily have to be pi; you can apply in various forms by passing the tick locations and labels as tuples. Code For xticks, provide the tick locations and labels in the form (A, B) where A indicates the location and B represents the label. Full Code using Plots piticks = [0, π,</description></item><item><title>How to Edit and Save Text (txt) Files in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3728/</link><pubDate>Sat, 02 Nov 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3728/</guid><description>write() write(path, string) The basic function write() saves a .txt file whose contents are the input string. julia&amp;gt; fm = &amp;#34;프로미스나인\n송하영\n박지원\n이채영\n이나경\n백지헌&amp;#34; &amp;#34;프로미스</description></item><item><title>How to Read Text (txt) Files as Strings in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3727/</link><pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3727/</guid><description>Description There are several ways to load a text file. A simple approach is to use the functions read(), readline(), and readlines(). Among these, read() reads the entire file and returns a string, readline() reads the first line from the file and returns a string, and readlines() reads all lines of the file and returns a vector whose elements are the strings of each line. If you do not specify</description></item><item><title>Obtaining Colors with Values from 0 to 1 in the Julia Color Scheme</title><link>https://freshrimpsushi.github.io/en/posts/46/</link><pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/46/</guid><description>Overview To obtain colors in the range from 0 to 1 in Julia&amp;rsquo;s color scheme, use the get function1. Although this function originally exists in Base, it has been overloaded through using ColorSchemes. Code The color scheme used in the example is colorschemes[:plasma]. colorschemes[:plasma] By inputting a value between 0 and 1 as the second argument to the get function, you can obtain the exact color at that position in</description></item><item><title>Introduction to the Julia Natural Language Processing Package TextAnalysis.jl</title><link>https://freshrimpsushi.github.io/en/posts/24/</link><pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/24/</guid><description>Overview This section introduces TextAnalysis.jl, a natural language processing package for Julia1. For practical natural language processing, packages like Snowball.jl for stemming are also used2. Code julia&amp;gt; using TextAnalysis julia&amp;gt; crps = Corpus(StringDocument.([ &amp;#34;To be or not to be&amp;#34;, &amp;#34;It should be a question to be&amp;#34;, &amp;#34;It is not a question&amp;#34; ])) A Corpus with 3 documents: * 3 StringDocument&amp;#39;s * 0 FileDocument&amp;#39;s * 0 TokenDocument&amp;#39;s * 0 NGramDocument&amp;#39;s Corpus&amp;#39;s</description></item><item><title>How to Pass Multiple Keyword Arguments at Once Using a Dictionary in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1962/</link><pubDate>Thu, 26 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1962/</guid><description>Explanation Using a dictionary and a splat operator, you can pass multiple keyword arguments to a function at once. This technique is useful when you need to apply the same options to multiple plots. If all the plots need the same options, using the function default is straightforward. However, if even one plot needs to be drawn with a different style, using default can become inconvenient. Code You can create</description></item><item><title>Introduction to Julia's Symbolic Computing Package Symbolics.jl</title><link>https://freshrimpsushi.github.io/en/posts/18/</link><pubDate>Wed, 25 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/18/</guid><description>Overview This introduces Symbolics.jl, a package that supports symbolic algebra systems in Julia1. This package provides an extremely intuitive and powerful interface along with Julia&amp;rsquo;s basic syntax. Difference from SymEngine.jl Symbolics.jl is implemented natively in Julia and has many better aspects in terms of performance and interface. SymEngine.jl, introduced in the post on how to do symbolic operations in Julia, is originally a library written in C++ and wrapped in</description></item><item><title>Comprehensive Guide to File I/O in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3707/</link><pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3707/</guid><description>Overview This document summarizes packages and functions related to file I/O in Julia. Summary CSV: CSV.jl Reading CSV.read(&amp;quot;file_name.csv&amp;quot;, DataFrame) CSV.File(&amp;quot;file_name.csv&amp;quot;) Writing: CSV.write(&amp;quot;file_name.csv&amp;quot;, df_data) JSON: JSON3.jl, JSON.jl Reading String: read(&amp;quot;file_name.json&amp;quot;, String) JSON3.Object: JSON3.read(cd*&amp;quot;/wonnyo.json&amp;quot;) Dictionary: JSON3.read(cd*&amp;quot;/wonnyo.json&amp;quot;) |&amp;gt; Dict Writing JSON3.write(&amp;quot;file_name.json&amp;quot;, json_data) open(&amp;quot;file_name.json&amp;quot;, &amp;quot;w&amp;quot;) do io; JSON3.pretty(io, json_data); end Pickle: PyCall.jl Reading: open(&amp;quot;file_name.pkl&amp;quot;) do f; pickle.load(f); end Writing: open(&amp;quot;file_name.pkl&amp;quot;, &amp;quot;w&amp;quot;) do f; pickle.dump(dict_data, f); end Numpy: PyCall.jl Reading: open(joinpath(cd, &amp;quot;file_name.npy&amp;quot;)) do f; np.load(f);</description></item><item><title>How to Flip Images Vertically and Horizontally in Julia</title><link>https://freshrimpsushi.github.io/en/posts/7/</link><pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/7/</guid><description>Overview This section introduces how to vertically or horizontally flip an image in Julia. It might seem intuitive to expect a function like flip in Images.jl, but it&amp;rsquo;s not present1. However, such functionality is implemented in the Augmentor.jl package2. Considering dependencies, it&amp;rsquo;s inefficient to use a package just for the flipping feature, so let&amp;rsquo;s implement it using only built-in functions. Code We will use this example image. Horizontal Flip rotr90(img')</description></item><item><title>How to Reference Device Names and Account Names in Julia</title><link>https://freshrimpsushi.github.io/en/posts/902/</link><pubDate>Tue, 17 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/902/</guid><description>Overview Julia, aimed at high-performance computing, is likely to use multiple servers exceeding the usual level of computational demand. In such cases, it&amp;rsquo;s necessary to reference the unique name of each device for control, data transmission, or log creation. Code Device Name gethostname() julia&amp;gt; gethostname() &amp;#34;Sick3060&amp;#34; A hostname is the name of a local machine. It can be used whenever the name of the server that provides resources, regardless of</description></item><item><title>How to Use Clipboard in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2628/</link><pubDate>Sun, 15 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2628/</guid><description>Overview Introducing how to use the clipboard in Julia. Code clipboard is implemented with two methods. clipboard(x) Copies x to the clipboard. clipboard() Pastes from the clipboard. How to Use Outside the REPL using InteractiveUtils: clipboard Outside the REPL, the clipboard function cannot be used, so you must import the clipboard function from InteractiveUtils as shown above1. Full Code using InteractiveUtils: clipboard clipboard(&amp;#34;julia&amp;#34;) x = clipboard() Environment OS: Windows julia:</description></item><item><title>NamedArrays.jl Package in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1968/</link><pubDate>Sat, 14 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1968/</guid><description>Description Julia&amp;rsquo;s NamedArrays.jl package allows the use of 2D arrays with named rows and columns. Although it is also applicable to arrays with three or more dimensions, this article focuses on 2D arrays. Code Definition When inputting an array of size $3 \times 4$ into the NamedArray function, it outputs the array with names attached to rows and columns. julia&amp;gt; using NamedArrays julia&amp;gt; X = reshape(1:12, (3, 4)) 3×</description></item><item><title>How to Define an Array by Specifying Its Type in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1969/</link><pubDate>Thu, 12 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1969/</guid><description>Code To specify the type in front of the brackets, simply write the type name. julia&amp;gt; [1, 2, 3] 3-element Vector{Int64}: 1 2 3 julia&amp;gt; Float64[1, 2, 3] 3-element Vector{Float64}: 1.0 2.0 3.0 julia&amp;gt; Complex{Float64}[1, 2, 3] 3-element Vector{ComplexF64}: 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im julia&amp;gt; Char[1, 2, 3] 3-element Vector{Char}: &amp;#39;\x01&amp;#39;: ASCII/Unicode U+0001 (category Cc: Other, control) &amp;#39;\x02&amp;#39;: ASCII/Unicode U+0002 (category Cc: Other, control) &amp;#39;\x03&amp;#39;: ASCII/Unicode</description></item><item><title>How to Assess Code Performance, Benchmark in julia</title><link>https://freshrimpsushi.github.io/en/posts/2626/</link><pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2626/</guid><description>Overview The primary reason for using Julia is its speed and performance, so writing code that is optimized from an engineering perspective is extremely important. BenchmarkTools.jl provides an interface for easy, convenient, and accurate performance evaluation1. Code julia&amp;gt; sinpi(0.5), cospi(0.5) (1.0, 0.0) julia&amp;gt; sincospi(0.5) (1.0, 0.0) Let&amp;rsquo;s compare the performance between computing a value at once with sincospi and using sinpi and cospi separately. @btime The evaluation shows that sincospi</description></item><item><title>Comprehensions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1970/</link><pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1970/</guid><description>Code In Julia, like in Python, comprehension is possible. Comprehension is a method of creating arrays that involves embedding conditional expressions directly into the array. For instance, if you want to define an array containing integers sequentially from $0$ to $9$, you can embed a for loop directly into the array. julia&amp;gt; [i for i ∈ 0:9] 10-element Vector{Int64}: 0 1 2 3 4 5 6 7 8 9 julia&amp;gt;</description></item><item><title>Methods for Calculating Arrays Column-wise in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1971/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1971/</guid><description>Code There are methods like map, broadcast, and comprehension for calculating arrays by column or row. julia&amp;gt; using Statistics julia&amp;gt; X = stack([i*ones(8) for i ∈ 1:9], dims=2) 8×9 Matrix{Float64}: 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 1.0 2.0</description></item><item><title>Application for sortperm in julia</title><link>https://freshrimpsushi.github.io/en/posts/2624/</link><pubDate>Sat, 07 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2624/</guid><description>Code sortperm returns an array of indices that would sort the given array1. It might sound complicated when you hear it, but looking at an example makes it immediately clear. julia&amp;gt; foo = [&amp;#39;다&amp;#39;, &amp;#39;나&amp;#39;, &amp;#39;라&amp;#39;,</description></item><item><title>Differences Between Vectors and Tuples in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1972/</link><pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1972/</guid><description>Description Vectors and tuples may appear similar at first glance, and they indeed share several common points, which might lead one to think, &amp;quot;Are they just the same concept with different names?&amp;quot; However, there are a few important differences between vectors and tuples. This article will primarily focus on the similarities and differences from the perspective of writing and using code. The mathematical basis for tuples in Julia and how</description></item><item><title>Comparing NaN in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1973/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1973/</guid><description>Description In Julia, the standard for floating-point numbers follows the IEEE 754 standard. Under this rule, NaN always returns false when compared with all other values. It only returns true when using the != and !== operators. Code julia&amp;gt; NaN &amp;gt; 1 false julia&amp;gt; NaN ≥ 2 false julia&amp;gt; NaN == 3 false julia&amp;gt; NaN ≤ 4 false julia&amp;gt; NaN &amp;lt; 5 false julia&amp;gt; NaN != 6 true julia&amp;gt; NaN</description></item><item><title>Functions for accessing elements of a singleton set in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2622/</link><pubDate>Tue, 03 Sep 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2622/</guid><description>Overview Just as a singleton set and its element are distinctly different in set theory, as discussed with singleton set $\left\{ a \right\}$ and its element $a$, in programming, a collection [a] that contains only one element and the unique element a itself are different. While some environments like MATLAB may not distinguish between these in certain situations, Julia does so more strictly, and the function designed for this purpose</description></item><item><title>How to Preview a DataFrame in vscode julia</title><link>https://freshrimpsushi.github.io/en/posts/2620/</link><pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2620/</guid><description>Guide 1 julia&amp;gt; using DataFrames julia&amp;gt; df = DataFrame(a = 10:-1:1, b = &amp;#39;a&amp;#39;:&amp;#39;j&amp;#39;) 10×2 DataFrame Row │ a b │ Int64 Char ─────┼───────────── 1 │ 10 a 2 │ 9 b 3 │ 8 c 4 │ 7 d 5 │ 6 e 6 │ 5 f 7</description></item><item><title>How to Use Decision Trees in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2618/</link><pubDate>Mon, 26 Aug 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2618/</guid><description>Overview Introducing the DecisionTree.jl package, which implements Decision Trees in Julia1. Code As an example, we use the iris dataset, a classic built-in dataset in R. Our goal is to create a decision tree that uses four variables SepalLength, SepalWidth, PetalLength, PetalWidth to predict Species and evaluate its performance. julia&amp;gt; iris = dataset(&amp;#34;datasets&amp;#34;, &amp;#34;iris&amp;#34;) 150×5 DataFrame Row │ SepalLength SepalWidth PetalLength PetalWidth Speci ⋯ │ Float64</description></item><item><title>How to Remove Duplicates from a Collection in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2616/</link><pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2616/</guid><description>Overview This section introduces how to remove and check for duplicates in collections in Julia. The unique() function, which eliminates duplicates, is algorithmically straightforward, but can be bothersome to implement on your own, and may not be efficient. The allunique() function, which checks for the absence of duplicate elements, is easy enough to implement that one might not have sought it out, so it’s worth getting familiar</description></item><item><title>줄리아 미분방정식 패키지 DiffetentialEquations 튜토리얼</title><link>https://freshrimpsushi.github.io/en/posts/1098/</link><pubDate>Sun, 18 Aug 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1098/</guid><description>Description DifferentialEquations.jl is one of the packages under the SciML group developed for the numerical solution of differential equations. The equations that can be solved with this package are as follows: Discrete equations (function maps, discrete stochastic (Gillespie/Markov) simulations) Ordinary Differential Equations (ODEs) Split and Partitioned ODEs (Symplectic integrators, IMEX Methods) Stochastic Differential Equations (SDEs) Stochastic differential-algebraic equations (SDAEs) Random differential equations (RODEs or RDEs) Differential algebraic equations (DAEs) Delay</description></item><item><title>How to Use Clustering Packages in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2613/</link><pubDate>Fri, 16 Aug 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2613/</guid><description>Overview In Julia, the package for clustering offered is Clustering.jl1. The algorithms implemented include: K-means K-medoids Affinity Propagation Density-based spatial clustering of applications with noise (DBSCAN) Markov Clustering Algorithm (MCL) Fuzzy C-Means Clustering Hierarchical Clustering Single Linkage Average Linkage Complete Linkage Ward&amp;rsquo;s Linkage Code DBSCAN DBSCAN (Density-based spatial clustering of applications with noise) is implemented with the dbscan() function. If there are $n$ pieces of data in $p$ dimensions, a</description></item><item><title>Julia's Automatic Differentiation Package Zygote.jl</title><link>https://freshrimpsushi.github.io/en/posts/2609/</link><pubDate>Thu, 08 Aug 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2609/</guid><description>Overview In Julia, the Zygote.jl package is used for automatic differentiation, especially in the field of machine learning, and particularly for deep learning. The developers promote this package as the next-generation automatic differentiation system that enables differentiable programming in Julia, and indeed, using it can be surprisingly intuitive. If you are curious about packages related to the derivative itself, not automatic differentiation, check out the Calculus.jl package. Code Univariate Functions</description></item><item><title>Referencing Struct Properties as Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2607/</link><pubDate>Sun, 04 Aug 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2607/</guid><description>Overview In Julia, there are mainly two ways to reference the properties of a structure. They should be used appropriately according to grammatical convenience or actual use. Code For example, in Julia, the // operator creates a Rational type of number as follows. The names of the properties that a rational number has include :num meaning numerator and :den meaning denominator. julia&amp;gt; q = 7 // 12 7//12 julia&amp;gt; q</description></item><item><title>How to Draw Vector Fields in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2605/</link><pubDate>Wed, 31 Jul 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2605/</guid><description>Code quiver(, quiver=) In Julia, the quiver() function can be used to visualize a vector field. θ = 0:0.2:2π quiver(cos.(θ),sin.(θ), quiver = (-sin.(θ), cos.(θ)),</description></item><item><title>Referencing Specific Positions in an Array with Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2603/</link><pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2603/</guid><description>Overview When multiple arrays are given, there are often situations where one wants to access a specific element of these arrays, for example, the third element in each array. In Julia, this can be implemented through broadcasting the getindex() function. Code getindex.() julia&amp;gt; seq_ = [collect(1:k:100) for k in 1:10] 10-element Vector{Vector{Int64}}: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 91, 92, 93, 94, 95, 96, 97,</description></item><item><title>How to Import Packages from Julia to R</title><link>https://freshrimpsushi.github.io/en/posts/2601/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2601/</guid><description>Overview The way to load a package in Julia is to use using, but as the program grows, it becomes a task to individually write them each time. This introduces a method to load packages through a loop1. Code Metaprogramming packages = [:CSV, :DataFrames, :LinearAlgebra, :Plots] for package in packages @eval using ▷eq1◁(package) end In actual use,</description></item><item><title>How to Normalize Matrices Column-wise in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2599/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2599/</guid><description>Overview This document introduces a tip for easily normalizing matrices in Julia 1. At its core, it’s just mixing the method of scalar multiplying matrices by rows and columns, the eachcol() function, and the norm() function from the LinearAlgebra module, but it’s concise, ending in one line, and proving to be quite useful to memorize for frequent use. Code julia&amp;gt; using LinearAlgebra julia&amp;gt; X</description></item><item><title>Multiplying Matrices Row-wise and Column-wise with Scalar in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2597/</link><pubDate>Mon, 15 Jul 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2597/</guid><description>Overview Introducing how to perform scalar multiplication by row and column on matrices in Julia. Code julia&amp;gt; d = 1:10 1:10 julia&amp;gt; X = ones(Int64, 10, 10) 10×10 Matrix{Int64}: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</description></item><item><title>How to Use Color Gradients in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3608/</link><pubDate>Tue, 04 Jun 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3608/</guid><description>Description A color gradient is one of the two color schemes supported by Julia&amp;rsquo;s visualization package Plots.jl (the other is palette), which is what we commonly refer to as gradation. Simply put, a type that implements gradation is ColorGradient. Gradients are used to draw charts such as heatmap(), surface(), contour(). If you want to differentiate the colors of various graphs, use a palette instead of a gradient. Code Symbol It</description></item><item><title>How to Use Palettes in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3607/</link><pubDate>Sun, 02 Jun 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3607/</guid><description>Explanation A palette refers to a board where paints are squeezed out in advance. Mathematically, it can be explained as a &amp;lsquo;set of colors&amp;rsquo; or a &amp;lsquo;sequence of colors&amp;rsquo;. When drawing multiple graphs in one picture, the most common way is to distinguish them by using different colors. For this purpose, Julia has implemented a type called ColorPalette that collects various colors. It can be comfortably understood as a vector</description></item><item><title>How to Plot Two Data Axes of Different Scales in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3606/</link><pubDate>Fri, 31 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3606/</guid><description>Code When plotting two data sets that have a large scale difference on the same plot, the one with the smaller scale gets completely ignored as shown in the figure below. using Plots x = 0:0.01:2π plot(x, sin.(x)) plot!(x, exp.(x)) When plotting the second data set, if you input twinx() as the first argument, it shares the $x$ axis and the graph</description></item><item><title>List of Plot Properties in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3605/</link><pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3605/</guid><description>Description In Julia&amp;rsquo;s Plots.jl, a plot is also an object. If you draw an empty plot to check its type, it looks like this. julia&amp;gt; using Plots julia&amp;gt; p = plot() julia&amp;gt; p |&amp;gt; typeof Plots.Plot{Plots.GRBackend} Removing Plots., it becomes Plot{GRBackend}, meaning the plot&amp;rsquo;s backend is GR, similar to how a vector with elements of type Float64 is denoted as Vector{Float64}. Checking the properties of Plot, we find the following.</description></item><item><title>Decorating the Background Grid in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3604/</link><pubDate>Mon, 27 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3604/</guid><description>Overview Keywords related to the grid background in Plots.jl are as follows: Keyword Name Function grid Display grid gridalpha, ga, gα Specify grid transparency foreground_color_grid, fgcolor_grid Specify grid color gridlinewidth, grid_lw Specify grid thickness gridstyle, grid_ls Specify grid line style minorgrid Display minor grid minorgridalpha Specify minor grid transparency foreground_color_minor_grid, fgcolor_minorgrid Specify minor grid color minorgridlinewidth, minorgrid_lw Specify minor grid thickness minorgridstyle, minorgrid_ls Specify minor grid line style Code</description></item><item><title>How to Call a DataFrame without String7, String15 in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2574/</link><pubDate>Sun, 26 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2574/</guid><description>Error When using data frames in Julia, string data sometimes get read as String7, String15, String31, etc., causing various errors. Rather than specific errors occurring, the usual functions don&amp;rsquo;t work with these, causing all sorts of problems. Cause For performance reasons, String was changed to faster versions like String7, etc. It&amp;rsquo;s designed this way on purpose, so nothing much can be done about it. Solution Passing the option stringtype =</description></item><item><title>Specifying Background Color in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3603/</link><pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3603/</guid><description>Overview The keywords related to the background color of figures in Plots.jl are as follows. Keyword Name Function background_color, bg_color Specify the color of the overall background background_color_outside, bg_color_outside Specify the color of the area outside where the graph is drawn background_subplot, bg_subplot Specify the color of the area where the graph is drawn background_inside, bg_inside Specify the color of the area where the graph is drawn, excluding the legend</description></item><item><title>How to Specify Graph Colors for Each Subplot in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3602/</link><pubDate>Thu, 23 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3602/</guid><description>Overview This section introduces three methods for specifying graph colors for each subplot. To learn how to specify colors for graph elements, refer here. Method 1 The first way to specify the graph color for a subplot is to predefine the color when defining each subplot. In Julia, since a picture is an object itself, you can define multiple pictures with different attributes and then combine them into one plot.</description></item><item><title>How to Add a Main Title in Julia Subplots</title><link>https://freshrimpsushi.github.io/en/posts/2572/</link><pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2572/</guid><description>Overview When drawing figures in Julia, to apply a title to all subplots, one should use plot_title instead of title1. This is because the arguments of the outermost plot() function, in the case of a plot with subplots like plot( plot1, plot2, ... ) inherit properties to the inner subplots. To clearly distinguish between them, title and plot_title are used separately. Code plot(p1, p2, title = &amp;#34;Two Plots&amp;#34;) As you</description></item><item><title>Specifying the Color of Graph Elements in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3601/</link><pubDate>Tue, 21 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3601/</guid><description>Overview In Plots.jl, the keywords for specifying the color of each graph component are as follows. Keyword Function markercolor, mc Specify the marker&amp;rsquo;s inside color markerstrokecolor, msc Specify the marker&amp;rsquo;s border color linecolor, lc Specify the line color fillcolor, fc Specify the fill color seriescolor, c Specify the color of all components Keyword Function markeralpha, ma, mα Specify the marker&amp;rsquo;s inside transparency markerstrokealpha, msa, msα Specify the</description></item><item><title>How to Use RGB Color Codes in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3600/</link><pubDate>Sun, 19 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3600/</guid><description>Code The package provided in Julia for dealing with colors is Colors.jl. By importing the visualization package Plots.jl, the features within Colors.jl can also be used. The color codes representing the RGB space include RGB, BGR, RGB24, RGBX, XRGB, which are subtypes of AbstractRGB. RGBA adds transparency to RGB. julia&amp;gt; using Plots julia&amp;gt; subtypes(AbstractRGB) 5-element Vector{Any}: BGR RGB RGB24 RGBX XRGB julia&amp;gt; subtypes(AbstractRGBA) 2-element Vector{Any}: BGRA RGBA Strings For the</description></item><item><title>How to Remove Axis Values in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/2570/</link><pubDate>Sat, 18 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2570/</guid><description>Overview In Julia, there are ways to remove color bars, axes, ticks, grids, etc., but these involve graphic elements, so it&amp;rsquo;s not possible to cleanly remove numbers alone. You must use an option called formatter. formatter = (_...) -&amp;gt; &amp;quot;&amp;quot; By giving the option formatter = (_...) -&amp;gt; &amp;quot;&amp;quot; to the plot() function, it&amp;rsquo;s done. using Plots x = rand(10) y = rand(10) plot( plot(x,y) ,plot(x,y, formatter = (_...) -&amp;gt;</description></item><item><title>Package for Color Processing in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3599/</link><pubDate>Fri, 17 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3599/</guid><description>Introduction1 Introducing the capabilities of Colors.jl, a package for color processing in Julia. When using the visualization package Plots.jl, there&amp;rsquo;s no need to load Colors.jl separately. It provides the following functionalities: Color parsing and conversion Color maps Color scales Parsing and Conversion Assuming str is a string representing color information, you can parse the string into a color code of a specific color space using @colorant_str or parse(Colorant, str). Note</description></item><item><title>How to Use Colors in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3598/</link><pubDate>Wed, 15 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3598/</guid><description>Overview The package that facilitates the convenient use of colors in Julia is Colors.jl. It can be used together just by importing the visualization package Plots.jl. Symbols and Strings The way to check the list of named colors is by entering Colors.color_names in the console window or checking the official documentation. julia&amp;gt; using Plots julia&amp;gt; Colors.color_names Dict{String, Tuple{Int64, Int64, Int64}} with 666 entries: &amp;#34;darkorchid&amp;#34; =&amp;gt; (153, 50, 204) &amp;#34;chocolate&amp;#34; =&amp;gt;</description></item><item><title>How to Use Finite Difference in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2568/</link><pubDate>Tue, 14 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2568/</guid><description>Overview To use Finite Differences in Julia, more specifically to calculate the coefficients of finite differences, it is advisable to use FiniteDifferences.jl1. In cases where there is susceptibility to noise, it’s possible to use Total Variation Regularized Numerical Differentiation, known as TVDiff, implemented in NoiseRobustDifferentiation.jl. Code FiniteDifferenceMethod() julia&amp;gt; f′ = FiniteDifferenceMethod([-2, 0, 5], 1) FiniteDifferenceMethod: order of method: 3 order of derivative: 1 grid: [-2, 0,</description></item><item><title>Decorating Text Output with Built-in Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3597/</link><pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3597/</guid><description>Code Using the function printstyled(string; color = color) allows you to decorate the outputted function. As input for the keyword argument color, symbols and integers $(0 \le n \le 255)$ are possible. Note that strings are not allowed. The available symbols include not only colors but also options like :blink, :reverse, etc. These can also be applied by entering them as keyword arguments like blink = true, bold = true.</description></item><item><title>Numerical Interpolation in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2566/</link><pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2566/</guid><description>Overview In Julia, the Interpolations.jl package is used for numerical interpolation1. Be cautious not to confuse it with the interpolation method used when printing the value of a variable in Julia[../2041]. Code Interpolate() julia&amp;gt; y = rand(10) 10-element Vector{Float64}: 0.8993801321974316 0.12988982511901515 0.49781160399025925 0.22555299914088356 0.4848674643768577 0.6089318286915111 0.10444895196527337 0.5921775799940143 0.2149546302906653 0.32749334953170317 julia&amp;gt; f = interpolate(y, BSpline(Linear())); julia&amp;gt; f(1.2) 0.7454820707817483 julia&amp;gt; f(0.1) ERROR: BoundsError: attempt to access 10-element interpolate(::Vector{Float64}, BSpline(Linear())) with element type</description></item><item><title>Calculating the Difference of Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2564/</link><pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2564/</guid><description>Overview In Julia, the diff() function is provided to calculate differences1. It&amp;rsquo;s also possible to use the circshift() function to easily create a similar effect, but dealing with end points and such can be somewhat inconvenient, so knowing how to use diff() can be much more comfortable. It can be used almost in the same way as the diff() functions in R and MATLAB, however, unlike these, Julia does not</description></item><item><title>How to Use Circular Arrangements in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2562/</link><pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2562/</guid><description>Overview Though Julia does not natively support Circular Arrays, it essentially allows for such functionality by providing the circshift() function, which pushes or pulls elements circularly1. It&amp;rsquo;s not particularly difficult to write this function yourself, but knowing it obviates the need. This function can be used almost exactly like the circshift() in MATLAB. Code This function has been introduced in the post about how to translate arrays in parallel as</description></item><item><title>List of Markers and Line Styles in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2560/</link><pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2560/</guid><description>Code 1 No need for a lengthy description, it literally shows what the marker and line styles look like in reality. linesytle Choose one from [:auto, :solid, :dash, :dot, :dashdot, :dashdotdot]. shape Choose one from [:none, :auto, :circle, :rect, :star5, :diamond, :hexagon, :cross, :xcross, :utriangle, :dtriangle, :rtriangle, :ltriangle, :pentagon, :heptagon, :octagon, :star4, :star6, :star7, :star8, :vline, :hline, :+, :x]. Full Code ▷code1◁ Environment OS:</description></item><item><title>Drawing a Regression Line on a Julia Plot</title><link>https://freshrimpsushi.github.io/en/posts/2558/</link><pubDate>Wed, 24 Apr 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2558/</guid><description>Code To insert a regression line in the scatter plot of Julia, simply use the option smooth = true. using Plots x = rand(100) scatter(x, 2x .+ 0.1randn(100), smooth = true) savefig(&amp;#34;plot.svg&amp;#34;) Environment OS: Windows julia: v1.8.3 Plots v1.38.5</description></item><item><title>The Difference Between Inf and NaN When Dividing by Zero in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2556/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2556/</guid><description>Overview Explains how 0/0 and 1/0 are different in Julia. Code julia&amp;gt; 0/0 NaN julia&amp;gt; 1/0 Inf At least in programming, infinity Inf can be quite useful in terms of initialization or comparison of sizes, making division by 0 not so strange after all. The problem is ${{ 0 } \over { 0 }} \ne \infty$, and in Julia, it is treated as NaN. In other words, while dividing by</description></item><item><title>Tips for passing Optional Arguments through the Julia Splatt Operator</title><link>https://freshrimpsushi.github.io/en/posts/2554/</link><pubDate>Tue, 16 Apr 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2554/</guid><description>Overview In Julia, the most frequently used purpose of the ... splat is explained as the method of passing optional arguments. Basically, it uses the method of applying the splat operator to the tuple after determining in advance what options to put into which arguments, in the form of a named tuple. Code Passing to Multiple Functions args1 = (; dims = 1) The named tuple args1 above can be</description></item><item><title>Julia's Splat Operator</title><link>https://freshrimpsushi.github.io/en/posts/2552/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2552/</guid><description>Overview In Julia, ... is called the splat operator. It is usefully employed when using functions or defining arrays1. This operator isn&amp;rsquo;t exclusive to Julia, but it&amp;rsquo;s defined in a more intuitive way compared to other languages, making it exceptionally easy to learn and understand. From personal experience, using ... seems to bring some sort of enlightenment regarding Julia programming. Code Function Input Primarily, ... is appended after an array</description></item><item><title>Slicing Only a Part of Unicode Strings in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2550/</link><pubDate>Mon, 08 Apr 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2550/</guid><description>Overview As with many programming languages, in Julia, English is written in ASCII code and characters like Chinese and Korean are written in Unicode. The trouble, unlike with other languages, is that dealing with these strings is quite tricky, which is intended for performance reasons1, so one has no choice but to bear with it and use them as they are. Code julia&amp;gt; str1 = &amp;#34;English&amp;#34; &amp;#34;English&amp;#34; julia&amp;gt; str2 =</description></item><item><title>Omitting DataFrame Names in Julia StatsPlots with Macro @df</title><link>https://freshrimpsushi.github.io/en/posts/2548/</link><pubDate>Thu, 04 Apr 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2548/</guid><description>Overview In the StatsPlots package of Julia, the @df macro allows omitting the repeatedly mentioned dataframe name when plotting1. The syntax for using the macro, when using column a of dataframe X, is to specify which dataframe to use with @df X, followed immediately by passing the argument a as a symbol :a in the scope that follows, writing it as plot (:a). In summary, the code is written as</description></item><item><title>How to Use Functions Defined in Other Files in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2544/</link><pubDate>Wed, 27 Mar 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2544/</guid><description>Overview Introducing the function include() which executes Julia code itself to use functions from another file. In MATLAB, if it&amp;rsquo;s in the same directory, it tends to automatically find the function, so some people think this process is hard. There is a way to properly modularize and export, but1 it is not recommended for beginners who urgently need functionality because it is difficult and complicated. It&amp;rsquo;s not too late to</description></item><item><title>How to k-means cluster in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3572/</link><pubDate>Sun, 24 Mar 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3572/</guid><description>Description k-means clustering is a clustering algorithm that divides the given $n$ data points into $k$ clusters. In Julia, it can be easily implemented using the Clustering.jl package. Code The following is a code to perform clustering with $k=3$ on the Iris dataset. Since data loaded from RDatasets.jl are by default data frames, they are converted into arrays, and transposed so that each column becomes a single data point. It</description></item><item><title>How to Color Markers in a Julia Fractal</title><link>https://freshrimpsushi.github.io/en/posts/2537/</link><pubDate>Wed, 13 Mar 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2537/</guid><description>Code using Plots x, y = rand(100), rand(100) Given the data above, depending on whether the data is continuous or categorical, the shape of the plot and the method of plotting differ. Continuous scatter(marker_z=) z = x + y scatter(x, y, marker_z = z) Categorical scatter(group=) 1 team = rand(&amp;#39;A&amp;#39;:&amp;#39;C&amp;#39;, 100) scatter(x, y, group = team) Environment OS: Windows julia: v1.8.3 https://stackoverflow.com/a/60846501/12285249&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>How to Adjust the Size and Resolution of an Image in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3559/</link><pubDate>Tue, 27 Feb 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3559/</guid><description>Code Size plot(x, y, size=(600,400)) In Julia, the size of a plot is set using the size option. It must be input as a Tuple{Integer, Integer}, where each integer represents the width and height in pixels, respectively. The default value is (600,400). using Plots x = rand(10) plot(x) savefig(&amp;#34;size_default.png&amp;#34;) plot(x, size=(1200,800)) savefig(&amp;#34;size_(1200,800).png&amp;#34;) 1800x1200 image (left), 600x400 image (right) Resolution plot(x, y, dpi=100) The resolution of an image is set using</description></item><item><title>Drawing Arrows in Graphics with Julia</title><link>https://freshrimpsushi.github.io/en/posts/3558/</link><pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3558/</guid><description>Code plot!([x1, x2], [y1, y2], arrow=:true) This code plots an arrow from point $(x1, y1)$ to point $(x2, y2)$ on the plot. Naturally, the tip of the arrow is at the terminal point $(x2, y2)$. The maximum value of the sine function can be shown as follows. using Plots x = range(0, 2π, 100) plot(x, sin.(x), label=&amp;#34;&amp;#34;, ylims=(-1.3,1.3)) plot!([π/2</description></item><item><title>How to Adjust Camera Position for 3D Plots in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3556/</link><pubDate>Wed, 21 Feb 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3556/</guid><description>Explanation Unlike 2D plots such as line graphs and heatmaps, 3D plots have different appearances depending on the viewing angle. The viewpoint of a 3D plot can be set using the camera=(azimuth, altitude) option. Azimuth represents the compass direction and corresponds to the angle measured from the $xz$-plane. Altitude represents the elevation and corresponds to the angle measured from the $xy$-plane. The default value is camera=(30, 30). Drawing a spiral</description></item><item><title>How to Fix the Random Seed in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3555/</link><pubDate>Mon, 19 Feb 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3555/</guid><description>Explanation1 In Julia, the random seed can be fixed as follows: seed!([rng=default_rng()], seed) -&amp;gt; rng seed!([rng=default_rng()]) -&amp;gt; rng The input variable rng stands for Random Number Generator, which refers to the algorithm used for drawing random numbers. The Random package offers the following options: TaskLocalRNG: This is the default setting. Xoshiro RandomDevice MersenneTwister Code By fixing the seed to 0, drawing three times, and then fixing it again to 0</description></item><item><title>How to Draw a Box Plot in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3553/</link><pubDate>Thu, 15 Feb 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3553/</guid><description>English Translation Description To draw a box plot, the statistical visualization package StatsPlots.jl must be used. boxplot([data], labels=[label]) Code using StatsPlots x = rand(0:100, 100) y = rand(50:100, 100) z = cat(x,y, dims=1) boxplot(x, label=&amp;#34;x&amp;#34;) boxplot!(y, label=&amp;#34;y&amp;#34;) boxplot!(z, label=&amp;#34;z&amp;#34;) Or boxplot([x,y,z], label=[&amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;]) will draw the same figure. Note that there should be no commas in lable. That is, it needs to be an array, not an $3 \times</description></item><item><title>How to Use Infinite Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2511/</link><pubDate>Sun, 21 Jan 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2511/</guid><description>Overview InfiniteArrays.jl is a package that enables the use of arrays of infinite size1, and is, in fact, closely related to Lazy Arrays. Lazy Evaluation refers to the method where the computer knows what needs to be computed but postpones the calculation until it is absolutely necessary. Obviously, computers cannot understand infinity, but this method allows for the implementation of infinite arrays on computers. Code ∞ julia&amp;gt; using InfiniteArrays julia&amp;gt;</description></item><item><title>Reading and Writing mat Files in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2509/</link><pubDate>Wed, 17 Jan 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2509/</guid><description>Overview MAT.jl is a library for reading and writing *.mat files, which are the data storage format used in MATLAB1. As is typical of Julia, this package does not force users to abandon their existing programming languages and habits; instead, it aims to secure users by providing an environment that is as familiar as possible. While the speed and convenience of Julia are significant advantages, MATLAB offers unique benefits for</description></item><item><title>How to Output Simple Graphics in the Julia Console</title><link>https://freshrimpsushi.github.io/en/posts/2507/</link><pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2507/</guid><description>Overview UnicodePlots.jl is a library that uses Unicode characters to print graphics in the Julia REPL1, enabling lightweight yet high-quality visualization as the program runs. Code using UnicodePlots p1 = lineplot(100 |&amp;gt; randn |&amp;gt; cumsum) p1 = lineplot!(p1, 100 |&amp;gt; randn |&amp;gt; cumsum); p1 UnicodePlots.heatmap(cumsum(abs.(randn(100,100)), dims=2)) The result of running the above example code is as follows. Environment OS: Windows julia: v1.7.3 UnicodePlots v3.0.4 https://github.com/JuliaPlots/UnicodePlots.jl&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>How to Initialize the Console in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2505/</link><pubDate>Tue, 09 Jan 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2505/</guid><description>Method In the console, pressing Ctrl + L appears to clear the console completely, but in some environments, it does not actually reset but rather scrolls the window as if it were pushed up. To cleanly remove or not rely on keyboard input, printing ASCII character \033c can be used1 2. print(&amp;#34;\033c&amp;#34;) Also, printing \007 will play a notification sound3. It&amp;rsquo;s surprisingly useful when you want to hear the end</description></item><item><title>Removing Missing Values in DataFrames in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2503/</link><pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2503/</guid><description>Overview 1 In Julia, you can easily remove missing values using the dropmissing() function. Code julia&amp;gt; df = DataFrame(x = [&amp;#34;i&amp;#34;, missing, &amp;#34;k&amp;#34;, &amp;#34;j&amp;#34;], y = [1, 2, 3, missing]) 4×2 DataFrame Row │ x y │ String? Int64? ─────┼────────────────── 1 │ i 1 2</description></item><item><title>How to Reference Environment Variables in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2499/</link><pubDate>Thu, 28 Dec 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2499/</guid><description>Overview This document explains how to reference environment variables in Julia1. Code Base.ENV Base.ENV[&amp;#34;JULIA_NUM_THREADS&amp;#34;] As you can see, accessing environment variables does not require loading any separate package; you can directly access them through Base.ENV. Since they are read as a dictionary, using the name of the desired environment variable as a key will return the environment variable as a string. The results of executing the above two lines of</description></item><item><title>How to use progress bars in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2497/</link><pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2497/</guid><description>Overview In Julia, you can easily use a progress bar to indicate the progress of a program. Code ProgressMeter.jl By placing the @showprogress macro from the ProgressMeter.jl package in a for loop, you can display the progress1. using ProgressMeter chi2 = [] @showprogress for n in 1:20000 push!(chi2, sum(randn(n) .^ 2)) end Compared to ProgressBars.jl below, the use of a macro makes the code more concise. ProgressBars.jl You can wrap</description></item><item><title>Calculating the Mean Excluding 0 or Missing Values in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2495/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2495/</guid><description>Overview R language has options within functions like sum() or mean() to ignore missing values directly, whereas Julia lacks such options but actively employs Functional Programming approaches instead. Code julia&amp;gt; data = [0,1,2,3,0] 5-element Vector{Int64}: 0 1 2 3 0 julia&amp;gt; sum(data) / length(data) 1.2 julia&amp;gt; sum(data) / sum(!iszero, data) 2.0 The top portion results in 1.2, dividing by the total number of samples including up to $0$, while the</description></item><item><title>How to Perform Regression Analysis in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2493/</link><pubDate>Sat, 16 Dec 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2493/</guid><description>Overview This brief introduction presents the GLM.jl package for conducting regression analysis in Julia, emphasizing its similarity to the interface in R and thus, skipping detailed explanations1. Code Julia using GLM, RDatasets faithful = dataset(&amp;#34;datasets&amp;#34;, &amp;#34;faithful&amp;#34;) out1 = lm(@formula(Waiting ~ Eruptions), faithful) The result of running the above code is as follows: julia&amp;gt; out1 = lm(@formula(Waiting ~ Eruptions), faithful) StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}}}}, Matrix{Float64}} Waiting ~ 1 + Eruptions Coefficients:</description></item><item><title>How to Neatly Print without Axes, Scales, etc. in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3501/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3501/</guid><description>Code Plots.jl essentially outputs everything including grids, ticks, axes, and color bars by default, but if you want to make it clean without these, you can add the following options. colorbar=:none: Removes the color bar. showaxis = false: Removes the axes and ticks. grid=false: Removes the background grid. ticks=false: Removes both background grid and ticks. framestyle=:none: Removes both background grid and axes. using Plots surface(L, title=&amp;#34;default&amp;#34;) surface(L, title=&amp;#34;colorbar=:none&amp;#34;, colorbar=:none) surface(L,</description></item><item><title>How to Create a Meshgrid in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3500/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3500/</guid><description>Overview There is no direct equivalent to the meshgrid() function used in Python and MATLAB. If you only want to obtain the function values on a grid, there is a simpler method that does not require creating a grid. Code 2D Multiplying a column vector by a row vector gives the same result as taking the Kronecker product of a column vector and a row vector. U(t,x) = si</description></item><item><title>Broadcasting of Multivariable Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3499/</link><pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3499/</guid><description>Overview Introducing how to broadcast multivariable functions in Julia. Like in Python, you can create a meshgrid, or you can easily calculate by creating vectors for each dimension. Bivariate Functions $$ u(t,x) = \sin(\pi x) e^{-\pi^{2}t} $$ To plot the function $(t,x) \in [0, 0.35] \times [-1,1]$ as above, the function values can be calculated like this: x = LinRange(-1., 1, 100) t = LinRange(0., 0.35, 200)&amp;#39; u1 = @.</description></item><item><title>How to Calculate the Difference Between Two Times in Seconds in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2461/</link><pubDate>Fri, 13 Oct 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2461/</guid><description>Overview To achieve this, one can use the canonicalize() function of the Dates module1. Code using Dates tic = DateTime(2022,3,7,7,1,11) toc = now() Dates.canonicalize(toc-tic) The result of executing the above code is as follows. julia&amp;gt; using Dates julia&amp;gt; tic = DateTime(2022,3,7,7,1,11) 2022-03-07T07:01:11 julia&amp;gt; toc = now() 2022-07-19T22:26:22.070 julia&amp;gt; Dates.canonicalize(toc-tic) 19 weeks, 1 day, 15 hours, 25 minutes, 11 seconds, 70 milliseconds It automatically calculates and outputs up to weeks, precisely</description></item><item><title>Specifying the Color of Axes, Axis Names, Ticks, and Tick Values in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/3490/</link><pubDate>Thu, 12 Oct 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3490/</guid><description>Overview The keywords related to specifying the color of axes and ticks in Plots.jl are as follows. Keyword Name Function guidefontcolor Specify axis name color foreground_color_border, fgcolor_border Specify axis color foreground_color_axis, fgcolor_axis Specify tick color foreground_color_text, fgcolor_text Specify tick value color Adding x_ or y_ in front of the keyword name applies it to the respective axis only. Code1 Axis Names The keyword to specify the color of axis names</description></item><item><title>How to Convert between 2D Arrays and Matrices in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2459/</link><pubDate>Mon, 09 Oct 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2459/</guid><description>Overview Introducing tips for switching between 2D arrays and matrices in Julia, which may be the simplest, fastest, and most beautiful way to do it, especially in environments of Julia 1.7 or lower1. Code There are countless ways to switch between matrices and 2D arrays, not just the method introduced here. Since the goal itself is not difficult whether you code haphazardly or not, it&amp;rsquo;s better to consider not only</description></item><item><title>How to Send an Email via Naver in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2457/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2457/</guid><description>Overview This document introduces how to send emails from Naver using the SMTPClient.jl package with SMTP 1. I use it to send reports to Kakao Mail when long-running simulations are finished, which helps to speed up my research. This way, knowing when simulations are finished without having to check the server myself, as Jordy notifies me via personal chat. Code Regardless of the programming language, the first thing to do</description></item><item><title>Sampling Randomly from a Given Distribution in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3463/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3463/</guid><description>설명 Using the Distributions.jl package, you can randomly sample from a given distribution.</description></item><item><title>Sampling Randomly in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3462/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3462/</guid><description>Description1 In Julia, the function for random sampling is as follows: rand([rng=default_rng()], [S], [dims...]) rng stands for Random Number Generator, which specifies the random number generation algorithm. If you don&amp;rsquo;t understand what this means, it&amp;rsquo;s okay to leave it untouched. S likely stands for Set, and it is a variable that specifies the set from which the random sampling will occur. The variables that can be input for S include</description></item><item><title>How to Print Without Omitting Data in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2416/</link><pubDate>Sat, 15 Jul 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2416/</guid><description>Overview Originally, Julia formats the data output to fit the size of the REPL beautifully, but sometimes we want to see the entire data comfortably. If the data is foo, you can print the entire data using show(stdout, &amp;quot;text/plain&amp;quot;, foo)1. Code julia&amp;gt; foo = rand(100,2) 100×2 Matrix{Float64}: 0.956438 0.663427 0.790117 0.472821 0.976134 0.198475 0.727601 0.472336 0.0469046 0.991999 0.625807 0.26634 0.490773 0.588481 0.352966 0.426474 0.585632 0.00185974 ⋮</description></item><item><title>How to Use the Linear Algebra Package in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2412/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2412/</guid><description>Overview Julia supports [linear algebra](../../categories/Linear Algebra) as well as MATLAB does, if not better. The intuitive and elegant syntax of Julia gives a feeling that it has been well-designed since its inception1. Code julia&amp;gt; A = [ 1 0 3 0 5 1 3 1 9 ] 3×3 Matrix{Int64}: 1 0 3 0 5 1 3 1 9 As you can see, defining matrices is intuitive and easy</description></item><item><title>Using Date and Time Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2410/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2410/</guid><description>Overview 1 Dates is a module that collects functions related to dates and times. It is inevitably useful not only for general programming but also for handling a lot of data, whether it&amp;rsquo;s related to time series or not1. Code Full Code using Dates 오늘 = DateTime(2022,3,10) typeof(오늘) propertyname</description></item><item><title>How to Use Fast Fourier Transform (FFT) in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3440/</link><pubDate>Sun, 02 Jul 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3440/</guid><description>Overview 1 2 The Fastest Fourier Transform in the West (FFTW) is a software library developed by Matteo Frigo and Steven G. Johnson at the Massachusetts Institute of Technology (MIT) for computing the Discrete Fourier Transform. While there exists a Julia package named AbstractFFTs.jl for FFT implementation, it is not intended to be used on its own but rather to aid in the implementation of fast Fourier transforms, such as</description></item><item><title>How to Change Basic Data Types in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3439/</link><pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3439/</guid><description>Overview In fields like machine learning, 32-bit floating point numbers are used instead of 64-bit ones for improving computation speed and saving memory. Therefore, in PyTorch, when tensors are created, their data type is fundamentally 32-bit floating point numbers by default. In Julia, there&amp;rsquo;s a machine learning package called Flux.jl, which takes Julia&amp;rsquo;s standard arrays as input for the neural networks it implements. The fact that it does not use</description></item><item><title>Distributed Computing in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2398/</link><pubDate>Fri, 09 Jun 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2398/</guid><description>Overview In Julia, this introduces how to schedule computations across multiple devices1. Honestly, I&amp;rsquo;m not quite sure myself. Code using Distributed ip_ = [] for last in [160,161,162,163,164,32,33,34,35,36,43,44,45,46,47] push!(ip_, join([155,230,211,last],&amp;#39;.&amp;#39;)) end sort!(ip_) for ip in ip_ addprocs([(&amp;#34;chaos@&amp;#34; * ip, 8)]; dir =&amp;#34;/home/chaos&amp;#34;, exename = &amp;#34;julia&amp;#34;) #add slave node\&amp;#39;s workers println(&amp;#34;ip $ip&amp;#34; * &amp;#34; passed&amp;#34;) end nworkers() @everywhere function f(n) return n^2 - n end A = pmap(f,1:20000) X = []</description></item><item><title>Julia's Multidimensional Indices</title><link>https://freshrimpsushi.github.io/en/posts/2394/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2394/</guid><description>Overview Julia provides a type of index that can reference multi-dimensional arrays, known as CatesianIndex1. Naturally, the naming Catesian comes from the Cartesian product, which is the product of sets. Code julia&amp;gt; M = rand(0:9, 4,4) 4×4 Matrix{Int64}: 9 3 7 0 8 6 2 1 3 8 4 9 5 6 8 2 For example, let&amp;rsquo;s assume you want to access the element 9, which is in</description></item><item><title>Julia's Short Circuit</title><link>https://freshrimpsushi.github.io/en/posts/2392/</link><pubDate>Sun, 28 May 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2392/</guid><description>Overview In Julia, &amp;amp;&amp;amp; and || not only perform logical AND and OR operations but also execute short-circuit evaluation1. For instance, A &amp;amp;&amp;amp; B returns true only if both A and B are true, but in reality, if A is false, there is no need to check whether B is true or false; A &amp;amp;&amp;amp; B is false. Short-circuit evaluation essentially skips checking B. Skipping the calculation for B can</description></item><item><title>Julia's find functions</title><link>https://freshrimpsushi.github.io/en/posts/2390/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2390/</guid><description>Overview Julia&amp;rsquo;s basic built-in functions are increasingly useful the more you know them. Without further ado, let&amp;rsquo;s learn through examples. Code x = [3, 7, 4, 5, 10, 3, 12, 3, 2, 4] argmin(x) argmax(x) findmin(x) findmax(x) extrema(x) findfirst(x .== 3) findlast(x .== 3) findall(x .== 3) findnext(x .== 3, 5) findprev(x .== 3, 5) Optimal solutions argmin(),argmax(),findmin(),findmax(),extrema() Finding the optimal solutions. x = [3, 7, 4, 5, 10, 3,</description></item><item><title>Julia's Exclamation Point Convention</title><link>https://freshrimpsushi.github.io/en/posts/2388/</link><pubDate>Sat, 20 May 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2388/</guid><description>Overview 1 In Julia, appending an exclamation mark ! at the very end of a function name is referred to as the bang convention. Such functions are characterized by modifying the arguments they are given. Code function add_1!(x) x .+= 1 return x end foo = [2,5,-1] add_1!(foo) foo For example, executing the code above yields the following result. julia&amp;gt; foo = [2,5,-1] 3-element Vector{Int64}: 2 5 -1 julia&amp;gt; add_1!(foo)</description></item><item><title>How to Quickly Reference Subarrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2384/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2384/</guid><description>Overview In Julia, view is a data structure that quickly refers to a subarray of an array, making it seem cumbersome from a user&amp;rsquo;s perspective, although there might seem to be no difference. However, it returns a lighter array as it is lazily referenced. Therefore, in Julia code that is optimized even at a very basic level, it is easy to find the macro @views. Code Let&amp;rsquo;s refer to a</description></item><item><title>Julia's Broadcasting Syntax</title><link>https://freshrimpsushi.github.io/en/posts/2382/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2382/</guid><description>Overview Broadcasting is one of the most important concepts in Julia, offering a convenient syntax for writing vectorized code1. It is used by placing a dot . before a binary operation or after a function. This represents the application of a function in a pointwise manner, which is a perfect expression of its purpose. From a programming perspective, broadcasting can be viewed as a simplification of using Map in Map</description></item><item><title>Creating Dictionaries from Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2375/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2375/</guid><description>Code 1 julia&amp;gt; Dict([&amp;#34;a&amp;#34;, &amp;#34;bc&amp;#34;] .=&amp;gt; [2,8]) Dict{String, Int64} with 2 entries: &amp;#34;a&amp;#34; =&amp;gt; 2 &amp;#34;bc&amp;#34; =&amp;gt; 8 Given two arrays you want to use as keys and values, you can create a dictionary using Dict(Key .=&amp;gt; Value). Essentially, it&amp;rsquo;s nothing more than broadcasting the =&amp;gt; operator to create pairs. Environment OS: Windows julia: v1.7.0 https://discourse.julialang.org/t/create-a-dictionary-from-arrays-of-keys-and-values/13908/3&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>How to Use Complex Numbers in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2373/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2373/</guid><description>Overview In Julia, complex numbers are natively supported, similar to R. Code Imaginary unit im julia&amp;gt; z = 3 + 4im 3 + 4im im represents the pure imaginary unit $i = \sqrt{-1}$. All the common arithmetic operations that we are familiar with can be used. julia&amp;gt; typeof(z) Complex{Int64} julia&amp;gt; typeof(3.0 + 4.0im) ComplexF64 (alias for Complex{Float64}) When checking the type, even though it&amp;rsquo;s the same complex number, the type</description></item><item><title>How to Change Axis Style in Julia Plots `framestyle`e`</title><link>https://freshrimpsushi.github.io/en/posts/3376/</link><pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3376/</guid><description>Overview1 The framestyle attribute allows changing the style of the plot&amp;rsquo;s axes and border. The possible options are as follows: :box :semi :axes :origin :zerolines :grid :none Code The default setting is :axes. ▷code1◁ The styles for each attribute are as follows. ▷code2◁ https://docs.juliaplots.org/latest/generated/attributes_subplot/&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>How to Write Conditional Statements Concisely in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2341/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2341/</guid><description>Overview In Julia, &amp;lt;condition&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt; executes &amp;lt;statement&amp;gt; when &amp;lt;condition&amp;gt; is true. As a function, it returns the result of &amp;lt;statement&amp;gt; if true, and if false, &amp;lt;statement&amp;gt; is not even evaluated. While it allows writing code efficiently and concisely, it may reduce readability. Moreover, even if you don&amp;rsquo;t use it frequently, you should understand it to read the code written by others. Without any context, encountering such syntax can be</description></item><item><title>How to Replace NaN with 0 in Julia DataFrames</title><link>https://freshrimpsushi.github.io/en/posts/2330/</link><pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2330/</guid><description>Overview The method of replacing with a specific value is inconvenient because it changes one column at a time, and when dealing with NaN throughout the dataframe, it seems more practical to use a better trick. Code julia&amp;gt; df = DataFrame(rand(1:9,3,3), :auto) ./ DataFrame(rand(0:1,3,3), :auto) 3×3 DataFrame Row │ x1 x2 x3 │ Float64 Float64 Float64 ─────┼──────</description></item><item><title>Julia's Ternary Operator ? :</title><link>https://freshrimpsushi.github.io/en/posts/2328/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2328/</guid><description>Overview In Julia, A ? B : C is known as the Ternary Operator, which returns B if A is true and C otherwise. Just like binary operations are defined as functions in mathematics, the ternary operation is also a function. It&amp;rsquo;s similar to an if statement but has this fundamental difference, making it very useful once you&amp;rsquo;re accustomed to it. However, it can make the code less readable, so</description></item><item><title>How to Change a Specific Value in a DataFrame in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2326/</link><pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2326/</guid><description>Overview To make replacements, use the replace!() method1. The first argument should be the column of the dataframe you want to change, and the second argument takes a pair A =&amp;gt; B. It&amp;rsquo;s important that it&amp;rsquo;s the dataframe&amp;rsquo;s column being specified here. Code julia&amp;gt; WJSN 10×4 DataFrame Row │ member birth height unit │ String Int64 Int64 String ─────┼───</description></item><item><title>How to Calculate Frequency in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2324/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2324/</guid><description>Overview 1 Use the freqtable() function from the FreqTables.jl package. It provides a similar functionality to the freq() function in R. Code Arrays julia&amp;gt; compartment = rand([&amp;#39;S&amp;#39;,&amp;#39;I&amp;#39;,&amp;#39;R&amp;#39;], 1000); julia&amp;gt; freqtable(compartment) 3-element Named Vector{Int64} Dim1 │ ──────┼──── &amp;#39;I&amp;#39; │ 316 &amp;#39;R&amp;#39; │ 342 &amp;#39;S&amp;#39; │ 342 By inserting an array like shown above, it will count the frequency for each class.</description></item><item><title>Reading Only Columns from a CSV File in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2322/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2322/</guid><description>Guide Let&amp;rsquo;s say we have an example.csv file like the one above. When loading it into a dataframe, sometimes we want to create an entirely empty dataframe that only retains the column names, without importing all the data. This is necessary in cases where an empty dataframe is needed. using CSV # Loading the dataframe with no rows df_empty = CSV.read(&amp;#34;example.csv&amp;#34;, DataFrame; limit = 0) In the resulting dataframe created</description></item><item><title>How to View Data Frame Summaries in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2320/</link><pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2320/</guid><description>Guide 1 using RDatasets iris = dataset(&amp;#34;datasets&amp;#34;, &amp;#34;iris&amp;#34;) describe(iris) describe() function can be used. Let&amp;rsquo;s summarize the iris data. julia&amp;gt; describe(iris) 5×7 DataFrame Row │ variable mean min median max nmissing eltype │ Symbol Union… Any Union… Any Int64 DataType ─────┼────────────</description></item><item><title>Julia's Categorical Array</title><link>https://freshrimpsushi.github.io/en/posts/2318/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2318/</guid><description>Overview The CategoricalArrays.jl package in Julia serves a similar function to factor in R. Code julia&amp;gt; A = [&amp;#34;red&amp;#34;, &amp;#34;blue&amp;#34;, &amp;#34;red&amp;#34;, &amp;#34;green&amp;#34;] 4-element Vector{String}: &amp;#34;red&amp;#34; &amp;#34;blue&amp;#34; &amp;#34;red&amp;#34; &amp;#34;green&amp;#34; julia&amp;gt; B = categorical(A) 4-element CategoricalArray{String,1,UInt32}: &amp;#34;red&amp;#34; &amp;#34;blue&amp;#34; &amp;#34;red&amp;#34; &amp;#34;green&amp;#34; julia&amp;gt; levels(B) 3-element Vector{String}: &amp;#34;blue&amp;#34; &amp;#34;green&amp;#34; &amp;#34;red&amp;#34; categorical() The categorical() function allows for casting a regular array to a categorical array. levels() With the levels() function, one can view the categories. Naturally,</description></item><item><title>How to Load a Built-in Dataset in R Used in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2316/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2316/</guid><description>Guide Using the RDatasets.jl package should do the trick. The following is an example of how to load the simplest iris dataset. It includes a variety of datasets beyond the basic built-in ones, so make sure to check out GitHub1. julia&amp;gt; using RDatasets julia&amp;gt; iris = dataset(&amp;#34;datasets&amp;#34;, &amp;#34;iris&amp;#34;) 150×5 DataFrame Row │ SepalLength SepalWidth PetalLength PetalWidth Species │ Float64 Float64 Float64 Float64 Cat…</description></item><item><title>How to Check Package Versions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2313/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2313/</guid><description>Guide For example, let&amp;rsquo;s check the version of the Plots.jl package. Press the ] key in the REPL to enter the package mode. Here, if you type status foo, you can check the version of the foo package as follows. Environment OS: Windows julia: v1.6.3</description></item><item><title>How to Check if an Array is Empty in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2311/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2311/</guid><description>Overview Use the isempty() function. Code julia&amp;gt; isempty([]) true julia&amp;gt; isempty(Set()) true julia&amp;gt; isempty(&amp;#34;&amp;#34;) true Though it&amp;rsquo;s mentioned as an array in the title, it actually could be a set or a string. Optimization Of course, checking if an array is empty by seeing if length() is $0$ might be fine too. julia&amp;gt; @time for t in 1:10^6 isempty([]) end 0.039721 seconds (1000.00 k allocations: 76.294 MiB, 27.85% gc time)</description></item><item><title>How to Handle Exceptions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2309/</link><pubDate>Tue, 13 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2309/</guid><description>Overview People who have struggled with severe loneliness know, oh they know Anyone who has struggled with unknown errors while coding understands the critical importance of errors in programming&amp;hellip; In Julia, errors can be thrown using the error() function or the @error macro. As of Julia v1.63, 25 types of built-in exceptions are defined1. Code julia&amp;gt; log(1 + 2im) 0.8047189562170501 + 1.1071487177940904im Consider, for instance, when using the logarithmic function</description></item><item><title>How to Check DataFrame Size in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2307/</link><pubDate>Fri, 09 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2307/</guid><description>Overview nrow(), ncol(), and size() can be used. Unlike with R, length() results in an error. Code julia&amp;gt; df = DataFrame(rand(100000,5), :auto) 100000×5 DataFrame Row │ x1 x2 x3 x4 x5 │ Float64 Float64 Float64 Float64 Float64 ────────┼─────────────────</description></item><item><title>How to Create a DataFrame with Variable Names as Column Names in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2305/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2305/</guid><description>Overview Named tuples can be used. The way to create a named tuple is by attaching a semicolon ; right after the left parenthesis. For example, if you say DataFrame(; x, y), a DataFrame is created with column names :x and :y, and the contents are x and y respectively. Code julia&amp;gt; MyCol7 = rand(5); B = 1:5; julia&amp;gt; DataFrame(; MyCol7, B) 5×2 DataFrame Row │ MyCol7 B</description></item><item><title>Julia's Named Tuples</title><link>https://freshrimpsushi.github.io/en/posts/2303/</link><pubDate>Thu, 01 Dec 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2303/</guid><description>Overview Named tuples are tuples that, unlike regular tuples, can be used like dictionaries or structures. They have an array of symbols as keys and allow access to values via those keys, all the while retaining their tuple-like usage. Code x = rand(Bool, 5); y = rand(Bool, 5); z = (; x, y) typeof(z) z.x Let&amp;rsquo;s run the above code to see how named tuples are used. julia&amp;gt; z =</description></item><item><title>Differences in Array Dimensions in Julia, Python (NumPy, PyTorch)</title><link>https://freshrimpsushi.github.io/en/posts/3315/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3315/</guid><description>Overview When dealing with high-dimensional arrays in Julia and NumPy, PyTorch (hereinafter referred to collectively as Python for simplicity), it is important to pay attention to what each dimension signifies as they differ. This distinction arises because Julia&amp;rsquo;s arrays are column-major, whereas Python&amp;rsquo;s arrays are row-major. Note that Matlab, being column-major like Julia, does not have this discrepancy, so those familiar with Matlab need not be overly cautious, but those</description></item><item><title>How to Insert Command Line Arguments in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2280/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2280/</guid><description>English Translation Code println(ARGS[1] * &amp;#34; + &amp;#34; * ARGS[2] * &amp;#34; = &amp;#34; * string(parse(Float64, ARGS[1]) + parse(Float64, ARGS[2]))) Let&amp;rsquo;s say we have a file named example.jl that consists of a single line as shown above. In Julia, we can receive command line arguments as an array through ARGS, similar to how sys.argv works with command line arguments in Python. The code written is a program that takes two</description></item><item><title>Methods for Symbolic Computation in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3311/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3311/</guid><description>Overview Symbolic operations in Julia can be used through the SymEngine.jl1 package. Code Defining Symbols Symbols can be defined in the following way. julia&amp;gt; using SymEngine julia&amp;gt; x = symbols(:x) x julia&amp;gt; x, y = symbols(&amp;#34;x y&amp;#34;) (x, y) julia&amp;gt; @vars x, y (x, y) julia&amp;gt; x = symbols(:x) x julia&amp;gt; f = 2x + x^2 + cos(x) 2*x + x^2 + cos(x) Vectors and Matrices julia&amp;gt; v = [</description></item><item><title>Executing External Programs in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2278/</link><pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2278/</guid><description>Code In Julia, you can execute a string wrapped in backticks using the run() function. This is similar to using os.system() from the os module in Python. julia&amp;gt; txt = &amp;#34;helloworld&amp;#34; &amp;#34;helloworld&amp;#34; julia&amp;gt; typeof(`echo $txt`) Cmd As shown above, a string wrapped in backticks has the type Cmd and can be executed with the run() function. julia&amp;gt; run(`cmd /C echo $txt`) helloworld Process(`cmd /C echo helloworld`, ProcessExited(0)) In this example,</description></item><item><title>Converting String to Number in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2276/</link><pubDate>Sat, 08 Oct 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2276/</guid><description>Code To convert a string str to a number of type type, use parse(type, str). julia&amp;gt; parse(Int, &amp;#34;21&amp;#34;) 21 julia&amp;gt; parse(Float64, &amp;#34;3.14&amp;#34;) 3.14 You might wonder why we can&amp;rsquo;t do something like Int64(&amp;quot;21&amp;quot;) as in Python&amp;hellip; That&amp;rsquo;s because changing &amp;lsquo;&amp;ldquo;21&amp;rdquo;&amp;rsquo; into 21 is not about changing types but interpreting the string &amp;quot;21&amp;quot; as a number, which justifies the use of parse1. Environment OS: Windows julia: v1.6.3 https://discourse.julialang.org/t/why-are-there-all-these-strange-stumbling-blocks-in-julia/92644/2&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>How to Define Variadic Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2266/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2266/</guid><description>Overview 1 A Varargs Function, commonly mentioned in programming, is a function that can receive an unlimited number of arguments. In Julia, you can simply set a variable to accept variadic arguments by appending ... after it. Let&amp;rsquo;s understand this with an example code. Additionally, this ... is called splat operator2. Code Isaac Newton famously discovered that adding the reciprocals of factorials simply converges to $e$ with the following theorem.</description></item><item><title>How to Check the Element Type Inside a Julia Container</title><link>https://freshrimpsushi.github.io/en/posts/2264/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2264/</guid><description>Overview To achieve this, use the eltype() function. It likely gets its name from element type. Code julia&amp;gt; set_primes = Set([2,3,5,7,11,13]) Set{Int64} with 6 elements: 5 13 7 2 11 3 julia&amp;gt; arr_primes = Array([2,3,5,7,11,13]) 6-element Vector{Int64}: 2 3 5 7 11 13 Consider two types of containers that hold prime numbers up to $13$. Honestly, they contain the same data, but one is a set while the other is</description></item><item><title>How to Change the Basic Settings of a Julia Plot</title><link>https://freshrimpsushi.github.io/en/posts/2262/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2262/</guid><description>Code You can use the default() function. using Plots default(size = (400,400), color = :red) default(:size, (400,400)) for key in [:size, :color], value in [(400,400), :red] default(key, value) end There is a way to set it up like the ordinary plot() function, and there is a way to change them one by one by giving key and value. Usually, the former is more convenient, but in the case of very</description></item><item><title>How to Remove Specific Rows from a DataFrame in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2260/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2260/</guid><description>Overview When indexing, you can use the Not() function1. If you input the symbol of the column name as is, or an array of symbols, those columns are excluded from the indexing. Code using DataFrames WJSN = DataFrame( member = [&amp;#34;다영&amp;#34;,&amp;#34;다원&amp;#34;,&amp;#3</description></item><item><title>How to Insert Vertical and Horizontal Lines in Figures in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2258/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2258/</guid><description>Overview To draw vertical and horizontal lines, use the vline!() and hline!() functions respectively. Code @time using Plots plot(rand(100)) hline!([0.5], linewidth = 2) vline!([25, 75], linewidth = 2) png(&amp;#34;result&amp;#34;) The positions where lines are drawn should be passed as an array. If the array contains multiple elements, multiple lines will be drawn at once. Environment OS: Windows julia: v1.6.3</description></item><item><title>How to Create Art Styles in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2256/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2256/</guid><description>Overview RecipesBase.jl is a package that allows users to create their own styles for new plots, similar to how ggplot works in the R programming language, with its own unique syntax1 separate from the base Julia. Let&amp;rsquo;s learn through examples. Code using Plots using DataFrames df = DataFrame(x = 1:10, y = rand(10)) plot(df) @userplot TimeEvolution @recipe function f(te::TimeEvolution) df = te.args[1] linealpha --&amp;gt; 0.5 column_names = names(df) for (column_index,</description></item><item><title>grouping and Calculating DataFrames in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2254/</link><pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2254/</guid><description>Overview Using groupby() to divide by group and combine() for calculation is the way to go1. groupby(df, :colname) Returns a groupedDataFrame based on :colname. combine(gdf, :colname =&amp;gt; fun) gdf is a groupedDataFrame divided by groups. :colname =&amp;gt; fun represents a pair of the symbol :colname, which is the name of the column containing the values to be calculated, and the calculation function fun. Code using DataFrames using StatsBase WJSN =</description></item><item><title>How to Delete Duplicate Rows in DataFrames in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2252/</link><pubDate>Sun, 21 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2252/</guid><description>Overview To achieve this, we can use unique(). More precisely, it leaves only one of the duplicates rather than deleting duplicated rows. Code using DataFrames WJSN = DataFrame( member = [&amp;#34;다영&amp;#34;,&amp;#34;다원&amp;#34;,&amp;#34;루다&amp;#34;,</description></item><item><title>Drawing Subplots with a Layout in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2250/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2250/</guid><description>Overview In Julia, options related to subplots can be controlled through the layout option. Entering an integer automatically creates a grid of that many plots. Entering a 2-tuple of integers creates a grid exactly as specified. The @layout macro is used to create complex layouts of the Plots.GridLayout type. Code using Plots left = plot(randn(100), color = :red) right = plot(randn(100), color = :blue) plot(left, right) png(&amp;#34;easyone&amp;#34;) data = rand(10,</description></item><item><title>Adjusting the Position of the Legend in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/2248/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2248/</guid><description>Overview 1 The position of the legend can be freely adjusted with the legend option of the plot() function. Giving a 2-tuple comprised of values between $0$ and $1$ will exactly place it at that location, otherwise, it can be controlled by symbols. Symbols combine top/bottom and left/right in order. Adding an outer at the very beginning places the legend outside of the plot. Examples of symbols that can be</description></item><item><title>How to Adjust the Aspect Ratio of a Julia Set Picture</title><link>https://freshrimpsushi.github.io/en/posts/2246/</link><pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2246/</guid><description>Overview 1 To adjust the width and height of the figure, you can include the ratio option. Other recommended aliases include aspect_ratios, axis_ratio. ratio = :none: The default value, where the figure&amp;rsquo;s size is adjusted to fit the ratio. ratio = :equal: Regardless of the figure&amp;rsquo;s size, the x and y axes are adjusted to a one-to-one ratio. ratio = Number: The ratio is adjusted according to Number. Number is</description></item><item><title>Solving Broken Characters when Exporting CSV in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2244/</link><pubDate>Fri, 05 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2244/</guid><description>Error using DataFrames, CSV example = DataFrame(x = 1:10, 가 = &amp;#34;나다&amp;#34;) CSV.write(&amp;#34;example.csv&amp;#34;, example) When outputting to a CSV file in Julia, you can see a phenomenon where the Korean text becomes garbled, as shown above. Cause The garbling isn&amp;rsquo;t actually due to the Korean text itself but a Unicode encoding issue, especially due to the UTF-8 encoding&amp;rsquo;s</description></item><item><title>- Text Formatting Package in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2242/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2242/</guid><description>Overview The Crayons.jl package is known for decorating text output in Julia1. If you want to decorate using only built-in functions, you can use printstyled(). Code using Crayons print(Crayon(background = :red), &amp;#34;빨강&amp;#34;) print(Crayon(foreground = :blue), &amp;#34;파랑&amp;#34;) print(Crayon(bold = true), &amp;#34;볼드</description></item><item><title>Adding a New Column to a DataFrame in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3273/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3273/</guid><description>Code Let&amp;rsquo;s say we are given the Cosmic Girls dataframe as follows. WJSN = DataFrame( member = [&amp;#34;다영&amp;#34;,&amp;#34;다원&amp;#34;,&amp;#34;루다&amp;#34;,&amp;#34;소정&amp;#34;,</description></item><item><title>Inserting a Line into a Julia Set Image</title><link>https://freshrimpsushi.github.io/en/posts/2240/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2240/</guid><description>Code using Plots scatter(rand(100), randn(100)) plot!([0,1],[0,1]) png(&amp;#34;example1&amp;#34;) plot!([.00,.25,.50],[-2,0,-2]) png(&amp;#34;example2&amp;#34;) θ = 0:0.01:2π plot!(.5 .+ cos.(θ)/3, 1.5sin.(θ)) png(&amp;#34;example3&amp;#34;) Let&amp;rsquo;s learn how to insert line segments into the diagram by executing the code above. Line Segment plot!([0,1],[0,1]) Whether you draw just one line segment or</description></item><item><title>How to Sort Dataframe in julia</title><link>https://freshrimpsushi.github.io/en/posts/2238/</link><pubDate>Sun, 24 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2238/</guid><description>Code using DataFrames Unit1 = DataFrame( member = [&amp;#34;다영&amp;#34;,&amp;#34;루다&amp;#34;,&amp;#34;수빈&amp;#34;,&amp;#34;진숙&amp;#34;], birth = [99,97,96,99], height = [161,157,159,162] ) Unit2</description></item><item><title>Inserting a New Row into a DataFrame in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2236/</link><pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2236/</guid><description>Code using DataFrames Unit1 = DataFrame( member = [&amp;#34;다영&amp;#34;,&amp;#34;루다&amp;#34;,&amp;#34;수빈&amp;#34;,&amp;#34;진숙&amp;#34;], birth = [99,97,96,99], height = [161,157,159,162] ) Unit2</description></item><item><title>Using Infinity in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2234/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2234/</guid><description>Overview Infinities.jl is a package that aids in using infinity symbols in Julia1. Surprisingly, infinity is quite useful in scientific computing coding. Code julia&amp;gt; 8 &amp;lt; Inf true The reason it&amp;rsquo;s mentioned that it helps in using infinity symbols, not just infinity, in the introduction is that you can actually use them without the package. julia&amp;gt; using Infinities julia&amp;gt; 8 &amp;lt; ∞ true julia&amp;gt; -∞ &amp;lt; 8 true julia&amp;gt;</description></item><item><title>How to Install a Specific Version of a Package in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2232/</link><pubDate>Tue, 12 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2232/</guid><description>Guide 1 (@v1.6) pkg&amp;gt; status JuMP Status `C:\Users\rmsms\.julia\environments\v1.6\Project.toml` [4076af6c] JuMP v0.20.0 By pressing the ] key in the REPL, you enter the package mode. For example, if you want to upgrade a package version from v0.20.0 to v0.21, you can do so by appending @x.yy to the package as follows. (@v1.6) pkg&amp;gt; add JuMP@0.21 Resolving package versions... ... (@v1.6) pkg&amp;gt; status JuMP Status `C:\Users\rmsms\.julia\environments\v1.6\Project.toml` [4076af6c] JuMP v0.21.4 If you check</description></item><item><title>How to Make Empty DataFrame in julia</title><link>https://freshrimpsushi.github.io/en/posts/2230/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2230/</guid><description>Overview Despite many languages supporting dataframes, surprisingly, creating empty arrays can be a new and annoying task each time. Code Type Specification julia&amp;gt; using DataFrames julia&amp;gt; df1 = DataFrame(x = Int64[], y = String[]) 0×2 DataFrame You actually just need to insert an empty array as data. At this point, a type is specified, but when there&amp;rsquo;s absolutely no data, neither column names nor types are visible. julia&amp;gt;</description></item><item><title>How to Perform Hierarchical Clustering in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3259/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3259/</guid><description>Explanation Use the hclust() function from the Clustering.jl package. hclust(d::AbstractMatrix; [linkage], [uplo], [branchorder]) It takes a distance matrix as input and returns the result of hierarchical clustering. The default method for calculating distances between clusters is single linkage. To plot a dendrogram, use StatsPlots.jl instead of Plots.jl. Code using StatsPlots using Clustering using Distances using Distributions a = rand(Uniform(-1,1), 2, 25) scatt = scatter(a[1,:], a[2,:], label=false) savefig(scatt, &amp;#34;julia_hclust_scatter.png&amp;#34;) D_a =</description></item><item><title>How to Find a Specific Pattern Location in Julia Strings</title><link>https://freshrimpsushi.github.io/en/posts/2226/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2226/</guid><description>Code julia&amp;gt; findfirst(&amp;#34;li&amp;#34;, &amp;#34;multicolinearlity&amp;#34;) 8:9 julia&amp;gt; findlast(&amp;#34;li&amp;#34;, &amp;#34;multicolinearlity&amp;#34;) 14:15 julia&amp;gt; findnext(&amp;#34;l&amp;#34;, &amp;#34;multicolinearlity&amp;#34;, 1) 3:3 julia&amp;gt; findnext(&amp;#34;l&amp;#34;, &amp;#34;multicolinearlity&amp;#34;, 4) 8:8 julia&amp;gt; findnext(&amp;#34;l&amp;#34;, &amp;#34;multicolinearlity&amp;#34;, 9) 14:14 julia&amp;gt; findfirst(r&amp;#34;t.+t&amp;#34;, &amp;#34;multicolinearlity&amp;#34;) 4:16 findfirst(pattern, A) Returns a Range representing the interval matching pattern in the string A. The pattern can include regular expressions. In the last example, it finds and returns the interval from the first t to the last t.</description></item><item><title>How to Draw a Dendrogram in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3257/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3257/</guid><description>Explanation When attempting to draw a dendrogram by using the plot() function after performing hierarchical clustering with hclust() on the given data, the following error occurs. using Clustering using Distances using Plots a = rand(2, 10) D_a = pairwise(Euclidean(), a, a) SL = hclust(D_a, linkage=:single) dendrogram = plot(SL) ERROR: LoadError: Cannot convert Hclust{Float64} to series data for plotting To draw a dendrogram, one should use StatsPlots.jl instead of Plots.jl. using</description></item><item><title>How to Check if a Specific String is Contained in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2224/</link><pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2224/</guid><description>Code julia&amp;gt; contains(&amp;#34;qwerty&amp;#34;, &amp;#34;er&amp;#34;) true julia&amp;gt; contains(&amp;#34;qwerty&amp;#34;, &amp;#34;et&amp;#34;) false julia&amp;gt; contains(&amp;#34;qwerty&amp;#34;, r&amp;#34;q?&amp;#34;) true contains(haystack::AbstractString, needle) Returns a boolean indicating whether needle is contained in haystack. needle can include regular expressions, such as r&amp;quot;...&amp;quot;. Note that &amp;lsquo;haystack&amp;rsquo; means a hay pile, referring to the idiom &amp;ldquo;a needle in a haystack&amp;rdquo;. Environment OS: Windows julia: v1.6.2</description></item><item><title>How to Use Factorization and Prime Number Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2222/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2222/</guid><description>Overview Primes.jl is a package that deals with functions related to primes and prime factorization. The implementation of functions related to analytic number theory is still lacking. This is not a comprehensive list of all the features of the package, but rather a selection of the useful ones. For more details, check the repository1. Types Prime Factorization Primes.Factorization julia&amp;gt; factor(12) 2^2 * 3 julia&amp;gt; factor(12)[1] 0 julia&amp;gt; factor(12)[2] 2 julia&amp;gt;</description></item><item><title>How to Use Polynomials in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2220/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2220/</guid><description>Overview Polynomials.jl is a package that includes the representation and computation of polynomial functions. Since polynomials are mathematically simple, there&amp;rsquo;s a tendency to think their coding should be straightforward, too. However, once you start implementing the necessary features, it can become quite cumbersome. Of course, it&amp;rsquo;s not extremely difficult, but it&amp;rsquo;s generally better to use a package whenever possible. This is not an exhaustive list of all features of the</description></item><item><title>Concatenating Strings in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2218/</link><pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2218/</guid><description>Code Concatenate Strings * julia&amp;gt; &amp;#34;oh&amp;#34; * &amp;#34;my&amp;#34; * &amp;#34;girl&amp;#34; &amp;#34;ohmygirl&amp;#34; Corresponds to the + in Python. Concatenate Multiple Strings string() julia&amp;gt; string(&amp;#34;oh&amp;#34;,&amp;#34;my&amp;#34;, &amp;#34;girl&amp;#34;) &amp;#34;ohmygirl&amp;#34; Corresponds to paste0() in R. Joining Items of a List of Strings join() julia&amp;gt; OMG = [&amp;#34;oh&amp;#34;,&amp;#34;my&amp;#34;, &amp;#34;girl&amp;#34;] 3-element Vector{String}: &amp;#34;oh&amp;#34; &amp;#34;my&amp;#34; &amp;#34;girl&amp;#34; julia&amp;gt; join(OMG) &amp;#34;ohmygirl&amp;#34; Corresponds to join() in Python. Repeat the Same String ^ julia&amp;gt; &amp;#34;=-&amp;#34; ^ 10 &amp;#34;=-=-=-=-=-=-=-=-=-=-&amp;#34; Corresponds to * in</description></item><item><title>Hiding Specific Data Labels in Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/2216/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2216/</guid><description>Code 1 using Plots x = rand(30) y = rand(30) z = rand(30) plot(x) plot!(y) plot!(z) png(&amp;#34;result1&amp;#34;) In some cases, you might want to make only certain data labels appear in the legend, as shown above. label = &amp;quot;&amp;quot; plot(x, label = &amp;#34;&amp;#34;) plot!(y) png(&amp;#34;result2&amp;#34;) In such cases, you can set the option label = &amp;quot;&amp;quot;. As you can see, the first data is displayed in the figure, but it</description></item><item><title>How to Insert Text into a Julia Plot</title><link>https://freshrimpsushi.github.io/en/posts/2214/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2214/</guid><description>Code 1 You can use annotate!(). The following code is for drawing a picture that marks the maximum and minimum points in Brownian motion. using Plots cd(@__DIR__) data = cumsum(randn(100)) plot(data, color = :black, legend = :none) annotate!(argmax(data), maximum(data), &amp;#34;max\n&amp;#34;) annotate!(argmin(data), minimum(data), &amp;#34;\nmin&amp;#34;) png(&amp;#34;result&amp;#34;) Environment OS: Windows julia: v1.7.0 https://discourse.julialang.org/t/plots-annotate/37784&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Inserting Korean Text into Julia Plots</title><link>https://freshrimpsushi.github.io/en/posts/2212/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2212/</guid><description>Environment OS: Windows julia: v1.6.2 Error julia&amp;gt; plot(data, color = :black, label = &amp;#34;값&amp;#34;, title = &amp;#34;브라운모션&amp;#34;) GKS: glyph missing from current font: 48652 GKS: glyph missing from current font: 46972 GKS: glyph missing from current font: 50868 GKS: glyph missing from current font:</description></item><item><title>Handling Strings in Julia like in Python</title><link>https://freshrimpsushi.github.io/en/posts/2205/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2205/</guid><description>Code 1 2 3 julia&amp;gt; replace(&amp;#34;qwerty&amp;#34;, &amp;#34;q&amp;#34;=&amp;gt;&amp;#34;Q&amp;#34;) &amp;#34;Qwerty&amp;#34; julia&amp;gt; join(&amp;#34;qwerty&amp;#34;, &amp;#34;,&amp;#34;) &amp;#34;q,w,e,r,t,y&amp;#34; julia&amp;gt; split(&amp;#34;qwerty&amp;#34;, &amp;#34;&amp;#34;) 6-element Vector{SubString{String}}: &amp;#34;q&amp;#34; &amp;#34;w&amp;#34; &amp;#34;e&amp;#34; &amp;#34;r&amp;#34; &amp;#34;t&amp;#34; &amp;#34;y&amp;#34; Julia is not particularly outstanding in string processing, but maybe because of that, it has followed Python closely making it easy and quick to learn. Most of the already known functionalities are implemented, so apart from whether it&amp;rsquo;s a module or not, the usage is almost similar.</description></item><item><title>How to Check Approximate Values in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2203/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2203/</guid><description>Code Using the comparison operator $\approx$, it only returns true when two values are sufficiently similar. ≈ can be used by entering \approx and then pressing Tab, just as in $\TeX$. julia&amp;gt; π ≈ 3.141592653 true julia&amp;gt; π ≈ 3.14159265 true julia&amp;gt; π ≈ 3.1415926 false julia&amp;gt; π ≈ 3.141592 false Environment OS: Windows julia: v1.7.0</description></item><item><title>From Julia: Dictionaries and Pairs</title><link>https://freshrimpsushi.github.io/en/posts/2201/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2201/</guid><description>Code 1 julia&amp;gt; d = Dict(&amp;#34;A&amp;#34;=&amp;gt;1, &amp;#34;B&amp;#34;=&amp;gt;2) Dict{String, Int64} with 2 entries: &amp;#34;B&amp;#34; =&amp;gt; 2 &amp;#34;A&amp;#34; =&amp;gt; 1 julia&amp;gt; push!(d,(&amp;#34;C&amp;#34;,3)) ERROR: MethodError: no method matching push!(::Dict{String, Int64}, ::Tuple{String, Int64}) julia&amp;gt; push!(d,&amp;#34;C&amp;#34; =&amp;gt; 3) Dict{String, Int64} with 3 entries: &amp;#34;B&amp;#34; =&amp;gt; 2 &amp;#34;A&amp;#34; =&amp;gt; 1 &amp;#34;C&amp;#34; =&amp;gt; 3 julia&amp;gt; typeof(&amp;#34;C&amp;#34; =&amp;gt; 3) Pair{String, Int64} Dictionaries in Julia are data types that pair Keys and Values, much like in other programming languages.</description></item><item><title>How to Store Data like .mat in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2199/</link><pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2199/</guid><description>Overview JLD.jl is a package that allows the storage of temporary data created while using Julia1. It is useful for managing the input and output of data in pure Julia projects. On the other hand, JLD2.jl, which further improves the intuitiveness of the JLD.jl interface, is also available. 2 The content introduced in this post should be taken as a rough understanding of these functionalities, and it is recommended to</description></item><item><title>How to Refer to Both Index and Value in Julia's Loops</title><link>https://freshrimpsushi.github.io/en/posts/2197/</link><pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2197/</guid><description>Code 1 Base.Iterators.enumerate() returns an iterator that allows referencing both the index and value of an array, similar to Python. julia&amp;gt; x = [3,5,4,1,2] 5-element Vector{Int64}: 3 5 4 1 2 julia&amp;gt; for (idx, value) in enumerate(x) println(&amp;#34;x[▷eq1◁value&amp;#34;) end x[1]:</description></item><item><title>Symbols in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2195/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2195/</guid><description>Overview When first encountering Julia, one might be perplexed by the symbol data type. Symbols are used with a preceding :, functioning simply by their name without any internal data. They are commonly used as names, labels, or dictionary keys1. Explanation In other programming languages, when giving options to a function, they are often provided as numbers or strings to clarify the meaning. For example, the following two functions illustrate</description></item><item><title>How to Check if Elements of an Array Belong to a List in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2193/</link><pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2193/</guid><description>Guide 1 julia&amp;gt; x = rand(&amp;#39;a&amp;#39;:&amp;#39;c&amp;#39;, 10) 10-element Vector{Char}: &amp;#39;a&amp;#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase) &amp;#39;a&amp;#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase) &amp;#39;b&amp;#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;b&amp;#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;c&amp;#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase) &amp;#39;b&amp;#39;: ASCII/Unicode U+0062 (category Ll:</description></item><item><title>How to Directly Define Multidimensional Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3223/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3223/</guid><description>Explanation 1D arrays (vectors) are defined as follows. julia&amp;gt; A = [1; 2; 3] 3-element Vector{Int64}: 1 2 3 Here, ; signifies moving to the next element based on the first dimension. By generalizing this, ;; signifies moving to the next element based on the second dimension. julia&amp;gt; A = [1; 2; 3;; 4; 5; 6] 3×2 Matrix{Int64}: 1 4 2 5 3 6 Similarly, arrays of three</description></item><item><title>How to Use Elegant Loops in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2191/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2191/</guid><description>Guide while The while loop is no different from other languages. julia&amp;gt; while x &amp;lt; 10 x += 1 print(&amp;#34;▷eq1◁i - &amp;#34;) end 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - julia&amp;gt; for i = 1:10 print(</description></item><item><title>List of Available Commands in Julia Package Management Mode</title><link>https://freshrimpsushi.github.io/en/posts/3217/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3217/</guid><description>Description By typing the right bracket ] in the Julia REPL, you can switch to package management mode. The available commands in package management mode are as follows. Command Function add foo Adds the package foo. free foo Unpins the package version. help, ? Shows these commands. pin foo Pins the version of the package foo. remove foo, rm foo Removes the package foo. test foo Test-runs the package foo.</description></item><item><title>How to load a npy file in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3215/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3215/</guid><description>설명 This document outlines the process of calculating the Radon transform $\mathcal{R}f$ of a phantom $f$ in Python and saving the results as a *.npy file. To load this file in Julia, one can use the PyCall.jl package. using PyCall np = pyimport(&amp;#34;numpy&amp;#34;) The above code is equivalent to executing import numpy as np in Python. This allows one to directly use the code written for numpy in Python</description></item><item><title>Overlaying Plots on Heatmaps in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3213/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3213/</guid><description>Code Let&amp;rsquo;s say we want to draw a sine curve from $0$ to $2\pi$ on the heatmap of the array $(5,5)$. You might want to write the code like this, but as you can see in the figure, it doesn&amp;rsquo;t output as desired. using Plots A = rand(Bool, 5,5) heatmap(A, color=:greens) x = range(0, 2pi, length=100) y = sin.(x) plot!(x, y, color=:red, width=3) This is because the horizontal and vertical</description></item><item><title>Using TeX in Plots in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2180/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2180/</guid><description>Code 1 To use the LaTeXStrings library, prefix strings with L, like so L&amp;quot;...&amp;quot;. @time using Plots @time using LaTeXStrings plot(0:0.1:2π, sin.(0:0.1:2π), xlabel = L&amp;#34;x&amp;#34;, ylabel = L&amp;#34;y&amp;#34;) title!(L&amp;#34;\mathrm{TeX\,representation:\,} y = \sin x , x \in [0, 2 \pi]&amp;#34;) Note that the package</description></item><item><title>Performing Operations on Vectors of Different Sizes Component-wise in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3207/</link><pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3207/</guid><description>Description julia&amp;gt; x = [1 2 3] 1×3 Matrix{Int64}: 1 2 3 julia&amp;gt; y = [1 2 3 4] 1×4 Matrix{Int64}: 1 2 3 4 julia&amp;gt; x .+ y ERROR: DimensionMismatch Two vectors of different sizes cannot perform element-wise operations by default. To implement this manually, one would have to use a double for loop, but fortunately, it can be easily calculated by treating one as</description></item><item><title>How to Make a Transparent Background in Graphics with Julia</title><link>https://freshrimpsushi.github.io/en/posts/2173/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2173/</guid><description>Code 1 If the browser is in dark mode, you can clearly see that the background has been rendered transparent. You just need to insert the :transparent symbol into the background_color option. It saves well as *.png, but it is said that it doesn&amp;rsquo;t save well as *.pdf. using Plots plot(rand(10), background_color = :transparent) png(&amp;#34;example&amp;#34;) As you can guess from the option name, if you put in a color symbol,</description></item><item><title>Methods for Coloring Up to a Certain Value from Curves in Julia / Between Two Curves / Inside a Closed Curve</title><link>https://freshrimpsushi.github.io/en/posts/3203/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3203/</guid><description>Fill up to a Specific Value1 Using attributes fillrange=a, fillalpha=b, fillcolor=:color in plot(), it colors with :color to the value a from the plotted curve with the transparency b. It works the same by writing fill=(a,b,:color). That is, the following two codes are the same. plot(x,y, fillrange=a, fillalpha=b, fillcolor=:color) plot(x,y, fill=(a,b,:color)) It seems to be a bug, but selecting the value of fillrange as $(0,1)$ does not get colored. using</description></item><item><title>The Difference Between == and === in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2157/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2157/</guid><description>Code 1 == compares whether values are the same, and === operates differently depending on whether the values to be compared are Mutable or not. Mutable: Checks if both terms refer to the same object, in other words, it returns whether the two variables can be programmatically distinguished or not. Immutable: Checks if both terms are of the same type, Checks if both terms have the same structure, And recursively</description></item><item><title>How to Invert a Bit Array in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2149/</link><pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2149/</guid><description>Code 1 It&amp;rsquo;s quite simple, but a common mistake is to treat the negation operators ! and ~ not as unary operators but as functions, and use !. or ~.. They should be written as .! or .~ instead. julia&amp;gt; a = rand(1,10) .&amp;lt; 0.5 1×10 BitMatrix: 1 1 0 0 1 0 1 0 0 0 julia&amp;gt; .!(a) 1×10 BitMatrix: 0 0 1</description></item><item><title>How to Open a Dialog Box and Select a File Like file.choose() in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2143/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2143/</guid><description>Code 1 using Gtk file_name = open_dialog(&amp;#34;파일 열기&amp;#34;) The string given as the first argument is the title of the dialog. When executed, you can see a &amp;lsquo;Open File&amp;rsquo; dialog popping up like this. Environment OS: Windows julia: v1.6.0 https://discourse.julialang.org/t/choose-a-file-interactively/10910/3&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>How to Round to a Specific Decimal Place in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2133/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2133/</guid><description>Code In fact, Julia is not a very convenient language for things like string formatting. While there are methods that utilize the intrinsic capabilities of strings for printing to the console, often it&amp;rsquo;s more convenient to use the round() function&amp;rsquo;s default option, digits. julia&amp;gt; for k in 0:8 println(round(π, digits = k)) end 3.0 3.1</description></item><item><title>How to Specify Heatmap Color Ranges in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2126/</link><pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2126/</guid><description>Code 1 When drawing a heatmap, sometimes it&amp;rsquo;s essential to fix the scale of values, so they don&amp;rsquo;t adjust with the numerical values. You can fix the color range using the clim option in the basic heatmap function. using Plots cd(@__DIR__) heatmap(rand(4,4)); png(&amp;#34;1.png&amp;#34;) heatmap(rand(4,4), clim = (0,1)); png(&amp;#34;2.png&amp;#34;) The results are as follows. The first heatmap has no fixed range, but the second heatmap&amp;rsquo;s range is fixed between 0 and</description></item><item><title>How to Use zfill() in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2124/</link><pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2124/</guid><description>Overview 1 In Python, zfill() actually serves as a method of the string class, filling the left side with zeros. Julia, on the other hand, offers the lpad() as a more versatile and widely applicable built-in function. While zfill() means to fill with zeros, lpad() signifies padding to the left. Code julia&amp;gt; lpad(&amp;#34;12&amp;#34;, 4, &amp;#34;0&amp;#34;) &amp;#34;0012&amp;#34; julia&amp;gt; lpad(12, 4, &amp;#34;0&amp;#34;) &amp;#34;0012&amp;#34; Continuing from the overview, lpad() in Julia is more</description></item><item><title>Checking Struct Properties in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2120/</link><pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2120/</guid><description>Code propertynames() You can check with the propertynames() function1. Since Julia has no classes, only structs2, all symbols returned by this function are precisely the names of properties only. The following is code for creating an Erdős–Rényi network in the Graphs package, checking the number of nodes, and each node&amp;rsquo;s neighborhood. The propertynames() function was used on this network, and</description></item><item><title>How to Find Derivatives in Julia</title><link>https://freshrimpsushi.github.io/en/posts/3135/</link><pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/3135/</guid><description>Overview1 The package is named Calculus.jl, but it does not support integration. If automatic differentiation, as discussed in machine learning, is needed, refer to the Zygote.jl package. Differentiation of Single Variable Function Derivative function derivative() It calculates the derivative of $f : \R \to \R$. derivative(f) or derivative(f, :x): Returns the derivative $f^{\prime}$. derivative(f, a): Returns the differential coefficient $f^{\prime}(a)$. julia&amp;gt; f(x) = 1 + 2x + 3x^2 f (generic</description></item><item><title>How to Create an Array Filled with a Specific Value in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2101/</link><pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2101/</guid><description>Code fill() function can be used. It serves a similar purpose to the rep() function in R.</description></item><item><title>How to Read SHP Files in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2097/</link><pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2097/</guid><description>Code The code to read a shp file named XsDB_주거인구_100M_TM.shp is as follows. using Shapefile cd(@__DIR__) path = &amp;#34;XsDB_주거인구_100M_TM.shp&amp;#34; table</description></item><item><title>How to truncate decimal points and convert to an integer in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2095/</link><pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2095/</guid><description>Overview To use the trunc function, simply pass Int as the first argument. Code julia&amp;gt; @time for t in 1:10^8 Int64(ceil(t/1000)) end 0.189653 seconds julia&amp;gt; @time for t in 1:10^8 trunc(Int64, ceil(t/1000)) end 0.128472 seconds The two loops perform the identical task but with about a 1.5 times speed difference. The former drops the decimal points using ceil and type casts to Int64, whereas the latter returns an integer natively</description></item><item><title>Renaming Column Names of a DataFrame in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2093/</link><pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2093/</guid><description>Overview To rename columns, you can use the rename!() function1. You can rename them all at once by providing a list of strings, or individually. Code using DataFrames df = DataFrame(rand(1:9, 10, 3), :auto) rename!(df, [&amp;#34;X&amp;#34;, &amp;#34;Y&amp;#34;, &amp;#34;Z&amp;#34;]) rename!(df, :X =&amp;gt; :A) When executed, it first creates the following dataframe: julia&amp;gt; df = DataFrame(rand(1:9, 10, 3), :auto) 10×3 DataFrame Row │ x1 x2 x3 │ Int64 Int64</description></item><item><title>How to Calculate Distance using NearstNeibors.jl in julia</title><link>https://freshrimpsushi.github.io/en/posts/2088/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2088/</guid><description>Overview To calculate the distance between $n$ points, if there&amp;rsquo;s no need to create a matrix but just to compute the distance, using a k-d tree1, a data structure advantageous for multi-dimensional search, can enhance speed. All related algorithms are implemented in NearestNeighbors.jl, so refer to the official GitHub page. Speed Comparison Let&amp;rsquo;s compare with the technique optimized for calculating distance matrices using the pairwise() function. using Distances using StatsBase</description></item><item><title>How to Output a 2D Array to a CSV File in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2073/</link><pubDate>Sat, 28 Aug 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2073/</guid><description>Code using CSV, DataFrames A = rand(1:10, 10) B = zeros(10) AB = DataFrame(hcat(A,B), [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;]) CSV.write(&amp;#34;AB.csv&amp;#34;, AB) The write function of the CSV package allows you to easily output a two-dimensional array. A, B are one-dimensional arrays, which are combined using the hcat function to transform into a dataframe. Execution Result julia&amp;gt; using CSV, DataFrames julia&amp;gt; A = rand(1:10, 10) 10-element Array{Int64,1}: 8 5 4 3 6 4 10</description></item><item><title>Writing Greek Characters and Subscripts in Julia Variable Names</title><link>https://freshrimpsushi.github.io/en/posts/2065/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2065/</guid><description>Overview In Julia, Unicode (UTF-8) is allowed for variable names. Therefore, you can use not only Greek letters but also superscripts, subscripts, and even Korean or emojis. There&amp;rsquo;s no particular need to use them, but odd codes like the following work fine. julia&amp;gt; α₁ = 2 2 julia&amp;gt; α₂ = 1 1 julia&amp;gt; println(α₁ \ast\ α₂) 2</description></item><item><title>How to Conveniently Print Variable Values in Julia, Interpolation</title><link>https://freshrimpsushi.github.io/en/posts/2041/</link><pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2041/</guid><description>Overview This section explains the convenient feature of interpolation in Julia. By using interpolation effectively, you can make output statements simple and clean, which is very handy. Although it is not related to interpolation in numerical analysis, the meaning of the word is similar. For features related to numerical analysis interpolation, refer to the usage of Interpolations.jl. Code The usage is very simple. You can append the dollar sign $</description></item><item><title>Using Julia in Windows CMD and PowerShell</title><link>https://freshrimpsushi.github.io/en/posts/2036/</link><pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2036/</guid><description>Guide Step 0. Install julia 1.6 or higher From version 1.6, you can add it to the environment variables during the installation process. Just check the indicated option and install. If using an older version, either install version 1.6 or higher, or follow the instructions below. Step 1. Check the Julia installation path Check the installation path of Julia. If you haven&amp;rsquo;t altered anything, it should be stored in the</description></item><item><title>Metaprogramming in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2024/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2024/</guid><description>Code 1 Julia supports meta programming at the language level. The following is the result of reading and executing a string as code itself. julia&amp;gt; text = &amp;#34;f(x) = 2x + 1; f(2)&amp;#34; &amp;#34;f(x) = 2x + 1; f(2)&amp;#34; julia&amp;gt; code = Meta.parse(text) :($(Expr(:toplevel, :(f(x) = begin #= none:1 =# 2x + 1 end), :(f(2))))) julia&amp;gt; eval(code) 5 Meta.Parse(): This function converts the input string into an expression and returns</description></item><item><title>How to Flatten an Array in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2022/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2022/</guid><description>Code Use the vec() function. julia&amp;gt; A = rand(0:9, 3,4) 3×4 Array{Int64,2}: 6 8 7 3 2 9 3 2 5 0 6 7 julia&amp;gt; vec(A) 12-element Array{Int64,1}: 6 2 5 8 9 0 7 3 6 3 2 7 To the human eye, it appears the same as a 1-dimensional array, but it&amp;rsquo;s actually a 2-dimensional array by type, which can cause errors. This method can solve</description></item><item><title>Optimizing Distance Matrix Calculations in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2020/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2020/</guid><description>Conclusion Let&amp;rsquo;s calculate the distance between $n$ coordinates. If it&amp;rsquo;s not necessary to calculate the distance between all coordinates, divide them into groups and create a rectangular distance matrix. The rectangular distance matrix can be calculated quickly and easily with the pairwise() function. Speed Comparison Let&amp;rsquo;s imagine doing a moving agent-based simulation for the SIR model. The original time complexity is $O \left( n^{2} \right)$, but if you divide it</description></item><item><title>How to Weight and Random Sample in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2018/</link><pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2018/</guid><description>Overview The usage of the function sample() which serves a similar role to R&amp;rsquo;s sample() or Python package numpy&amp;rsquo;s random.choice(), and the Weights function in Julia. Code 1 using StatsBase items = 0:5 weights = 0:5 sample(items, Weights(weights)) # With replacement my_samps = sample(items, Weights(weights), 10) # Without replacement my_samps = sample(items, Weights(weights), 2, replace=false) Execution Result julia&amp;gt; using StatsBase julia&amp;gt; items = 0:5 0:5 julia&amp;gt; weights = 0:5 0:5</description></item><item><title>Comparison of the Speed of the Equality Operator == for Characters and Integers in Julia</title><link>https://freshrimpsushi.github.io/en/posts/2016/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2016/</guid><description>Conclusion Comparing each element in an array using the Equal Operator == shows that Char is faster than integers. Speed Comparison julia&amp;gt; integer = rand(1:5, N); print(typeof(integer)) Array{Int64,1} julia&amp;gt; character = rand([&amp;#39;S&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;I&amp;#39;,&amp;#39;R&amp;#39;,&amp;#39;D&amp;#39;], N); print(typeof(character)) Array{Char,1} julia&amp;gt; @time integer .== 1; 0.009222 seconds (6 allocations: 1.196 MiB) julia&amp;gt; @time character .== &amp;#39;S&amp;#39;; 0.005266 seconds (7 allocations: 1.196 MiB) The above code identifies where 1 and S are located in an array</description></item><item><title>Solving \General\registry.toml: No such file or directory when Installing Julia Packages</title><link>https://freshrimpsushi.github.io/en/posts/2069/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2069/</guid><description>Error ERROR: SystemError: opening file &amp;quot;C:\\Users\\rmsms\\.julia\\registries\\General\\registry.toml&amp;quot;: No such file or directory Cause It&amp;rsquo;s a really frustrating error, which, as the message indicates, occurs because the Registry.toml file does not exist at the specified path. Solution Delete the C:\Users\사용자이름\.julia\registries\</description></item><item><title>How to Install the Latest Version of Julia on Windows</title><link>https://freshrimpsushi.github.io/en/posts/2067/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/2067/</guid><description>Guide Julia Version After 1.10 In the terminal, enter the command winget install julia -s msstore as shown above. Julia Version Before 1.10 Step 1. Install Julia Download and run the installation file from the Julia Downloads Page. Step 2. Install VS Code Download and run the installation file from the Visual Studio Code Download Page. Step 3. Install Julia Extension Open Extensions using the fifth icon from the left</description></item><item><title>How to Use Hexadecimal RGB Codes (HEX) in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1921/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1921/</guid><description>Code The package provided for handling colors in Julia is Colors.jl. By loading the visualization package Plots.jl, one can also use the functionality within Colors.jl. Color codes representing the RGB space, such as RGB, BGR, RGB24, RGBX, XRGB, are supported and are subtypes of AbstractRGB. RGBA is RGB with added transparency. julia&amp;gt; using Plots julia&amp;gt; subtypes(AbstractRGB) 5-element Vector{Any}: BGR RGB RGB24 RGBX XRGB julia&amp;gt; subtypes(AbstractRGBA) 2-element Vector{Any}: BGRA RGBA Strings</description></item><item><title>Converting Between DataFrames and 2D Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1930/</link><pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1930/</guid><description>Code Matrix(df) or Array(df) functions can be used to convert a DataFrame into an array of the same size. To create a DataFrame from an array, use DataFrame(array, :auto). In the past, the convert function was used, but it&amp;rsquo;s not applicable anymore, so be careful. using DataFrames julia&amp;gt; A = rand(5,3) 5×3 Matrix{Float64}: 0.678876 0.10431 0.827079 0.621647 0.372007 0.29346 0.756844 0.171237 0.0732631 0.922519 0.0535938 0.121689 0.164058 0.0684278 0.68446</description></item><item><title>How to Read *.csv Files in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1923/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1923/</guid><description>Guide Old Version In julia v1.5.0, *.csv files were read as follows: In fact, Julia is not yet a language notably convenient for data input. However, if one desires speed, there may come a time when Julia should be chosen over Python, R, or Matlab. For instance, if one wants to load a *.csv file located just under the E drive, it can be entered as follows. using CSV data</description></item><item><title>Changing the Number of Threads for parallel Computing in Julia on Windows</title><link>https://freshrimpsushi.github.io/en/posts/1933/</link><pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1933/</guid><description>Guide In Julia, parallel computing is commonly used, so it may be necessary to focus all of a computer&amp;rsquo;s resources on computation depending on the situation. Although there are various ways to change the number of threads, the most static and convenient method is to edit environmental variables. Step 1. Edit System Environmental Variables Press the Windows key or Windows+S to search for &amp;lsquo;Edit system environment variables&amp;rsquo;. When the System</description></item><item><title>How to Determine the Location of Code Files Executed in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1935/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1935/</guid><description>Guide If you are someone who uses Julia, it&amp;rsquo;s likely that you&amp;rsquo;re comfortable with using multiple operating systems or computers, including servers. If there is file input/output involved, having to adjust the path each time the development environment changes can be quite bothersome. This is where the @__DIR__ macro comes in handy. Suppose you have a Julia code file like the following. Typically, when executed from the terminal, pwd() and</description></item><item><title>Changing the Number of Threads for parallel Computing in Julia on Linux</title><link>https://freshrimpsushi.github.io/en/posts/1937/</link><pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1937/</guid><description>Guide In Julia, parallel computing is routinely used, so sometimes it&amp;rsquo;s necessary to focus all of a computer&amp;rsquo;s resources on the computation. There are several ways to change the number of threads, but the most static and convenient method is to edit the environment variables. Step 1. Edit System Environment Variables Press Ctrl + Alt + T to open the terminal and type gedit ~/.bashrc. A window for editing environment</description></item><item><title>How to Use Composite Functions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1942/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1942/</guid><description>Code julia&amp;gt; f(x) = 2x + 1 f (generic function with 1 method) julia&amp;gt; g(x) = x^2 g (generic function with 1 method) julia&amp;gt; (g ∘ f)(3) 49 Description In Julia, function composition is similar to the pipe operator in programming. The main advantage of this composition is that it makes it easier for mathematicians to express formulas as code. The example above is simply a translation of the following</description></item><item><title>Making GIFs in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1863/</link><pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1863/</guid><description>Code Although the original Sakura Sushi restaurant tends to add much more detailed explanations, to emphasize how easy it is to create animated GIFs in Julia, we will keep this explanation as brief as possible. Even setting aside simulating a random walk, creating an animated GIF like the one above can be very difficult and demanding, depending on the language. However, Julia makes this incredibly easy with the @animate macro</description></item><item><title>How to Compute Distance Matrices in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1799/</link><pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1799/</guid><description>Overview The Distance Matrix is commonly used in simulations based on Particle Dynamics and Moving Agents, but it is often difficult to find a ready-made function for this purpose, and coding it from scratch can be daunting. In Julia, you can easily calculate a distance matrix using the pairwise() function and the Euclidean() function from the Distances package1. The dims option allows you to specify the direction of rows and</description></item><item><title>How to Create an Empty Array in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1797/</link><pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1797/</guid><description>Code Size Specification julia&amp;gt; empty = Array{Float64, 2}(undef, 3, 4) 3×4 Array{Float64,2}: 3.39519e-313 3.18299e-313 4.66839e-313 1.061e-313 4.03179e-313 5.51719e-313 1.6976e-313 4.24399e-314 2.97079e-313 4.66839e-313 7.00259e-313 5.0e-324 Executing the code above results in an empty array being created. Occasionally, it may seem like a strange value such as 1.76297e-315 is entered, but this is a value very close to 0, so it&amp;rsquo;s not a major issue for initialization. Array{X, Y}(undef, ...)</description></item><item><title>Installing the Latest Version of Julia on Linux</title><link>https://freshrimpsushi.github.io/en/posts/1511/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1511/</guid><description>Guide After Julia Version 1.10 In the terminal, enter the command curl -fsSL https://install.julialang.org | sh as shown above. Before Julia Version 1.10 Step 1. Download Julia Download the file that matches your CPU&amp;rsquo;s bit from Generic Linux Binaries for x86. Step 2. Extract and Move Extract the file. Move the folder to the location where Julia will be stored. You can place it anywhere you like, but in this</description></item><item><title>How to Parallel Process in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1474/</link><pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1474/</guid><description>Code While the original sushi restaurant with fresh shrimp includes detailed explanations, Julia wants to omit explanations on purpose to emphasize how easy it is to do parallel processing. using Base.Threads for i in 1:10 println(i^2) end If you want to parallelize the above loop, you just need to prepend @threads to the for loop. @threads for i in 1:10 println(i^2) end However, if I must add one piece of</description></item><item><title>Julia's Powerful Convenience Features, Macros</title><link>https://freshrimpsushi.github.io/en/posts/1454/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1454/</guid><description>Overview Macros in Julia provide convenience features when coding, being executed in front of a scope. For example, if you want to know how much time your program is consuming, you can write it as follows. @time for t in 1:10 foo() bar() end Examples There are many types, but the following macros are especially widely used: @time: Measures the execution time of the function or scope that follows. When</description></item><item><title>How to Use Pipe Operators in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1450/</link><pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1450/</guid><description>Overview Julia supports the pipeline operator, highlighting its strength in handling data. Code julia&amp;gt; (1:5) .|&amp;gt; (x -&amp;gt; sqrt(x+2)) .|&amp;gt; sin |&amp;gt; minimum 0.4757718381527513 julia&amp;gt; minimum(sin.((x -&amp;gt; sqrt(x+2)).(1:5))) 0.4757718381527513 The example code above puts the array $[1,2,3,4,5]$ into $\sqrt{x + 2}$, and then puts the result into $\sin$ to obtain the smallest value. The code above and below produces exactly the same results. It goes without saying how useful the</description></item><item><title>Lambda Expressions in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1448/</link><pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1448/</guid><description>Overview In Julia, lambdas are defined as follows: (x -&amp;gt; 3x^2 - 2x + 3)(1) This corresponds to defining the anonymous function $\lambda : \mathbb{Z} \to \mathbb{Z}$, substituting $1$ into it, and obtaining the function value $4$. $$ \lambda : x \mapsto ( 3 x^{2} - 2 x + 3 ) \\ \lambda (1) = 4 $$ Indeed, lambda expressions themselves are not a Julia-specific feature but almost naturally supported,</description></item><item><title>How to Change Image Size in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1466/</link><pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1466/</guid><description>Resizing Images To resize images, you can use the imresize function from the Images package. The function name is the same as in Matlab. imresize(X, ratio=a): Returns the image of array X scaled by a factor of a. Unlike Matlab, you must explicitly write ratio=a. imresize(X, m, n): Returns the image of array X resized to m rows and n columns. Below are example codes and their results. using Images</description></item><item><title>How to Load Images in Julia and Save Them as Matrices</title><link>https://freshrimpsushi.github.io/en/posts/1446/</link><pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1446/</guid><description>Code using Images cd(&amp;#34;C:/Users/rmsms/OneDrive/examples&amp;#34;) pwd() example = load(&amp;#34;example.jpg&amp;#34;) typeof(example) size(example) gray1 = Gray.(example) typeof(gray1) size(gray1) M = convert(Array{Float64},gray1) typeof(M) size(M) colorview(Gray, M.^(1/2)) save(&amp;#34;rgb.png&amp;#34;, colorview(RGB, example)) save(&amp;#34;gray1.png&amp;#34;, colorview(Gray, gray1)) save(&amp;#34;gray2.png&amp;#34;, colorview(Gray, transpose(gray1))) save(&amp;#34;gray3.png&amp;#34;, colorview(Gray, M.^(1/2))) Let&amp;rsquo;s briefly understand the example code from top to bottom: cd() : Change Directory, changes the working directory to the desired location. pwd() : Print Working Directory, prints the working directory. If you want to follow</description></item><item><title>How to Rotate Image Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1462/</link><pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1462/</guid><description>Image Rotation imrotate(X, theta): Rotates array X by theta radians. Note that, unlike in MATLAB where the angle unit is degrees ($^{\circ})$, the angle unit here is radians. Additionally, unlike MATLAB, it rotates clockwise. If no other variables are inputted, the interpolation method defaults to bilinear, and the rotated image is not cropped. Examples of rotating the original image X by $90^\circ=\pi/2$, $180^\circ=\pi$, and $270^\circ=\frac{3}{2}\pi$, along with their results, are</description></item><item><title>Functions for 2D Array Operations in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1460/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1460/</guid><description>Let&amp;rsquo;s say $A = \begin{pmatrix} 1 &amp;amp; 2 &amp;amp; 1 \\ 0 &amp;amp; 3 &amp;amp; 0 \\ 2 &amp;amp; 3 &amp;amp; 4\end{pmatrix}$. Transpose Matrix julia&amp;gt; A =[1 2 1; 0 3 0; 2 3 4] 3×3 Array{Int64,2}: 1 2 1 0 3 0 2 3 4 julia&amp;gt; transpose(A) 3×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}: 1 0 2 2 3 3 1 0 4 julia&amp;gt; A&amp;#39; 3×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}: 1</description></item><item><title>How to output and save arrays as heatmap images in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1459/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1459/</guid><description>Heatmap Using the heatmap function from the Plots package, you can output a 2D array as a heatmap image, and with the savefig function, you can save the resulting image. The @__DIR__ macro tells you the location of the Julia code file. # code1 However, if you compare array A with the heatmap image, you may notice that the top and bottom of the array are flipped in the heatmap</description></item><item><title>Sets and Operators in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1442/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1442/</guid><description>Overview Julia, like Python, supports the set data type. As with any set data type, it is incredibly useful for those who use it and utterly ignored by those who don&amp;rsquo;t. Given that Julia&amp;rsquo;s design is closely aligned with mathematics, its implementation of set concepts and operations is robust, making it an important feature to understand. Perhaps the most distinct difference from other languages, especially Python, is the ability to</description></item><item><title>Slicing and Indexing of Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1437/</link><pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1437/</guid><description>Overview Julia is a language that mixes the advantages of R, Python, and Matlab. Arrays are fundamental to programming, and their usage reveals traces of these languages. Code Matrix julia&amp;gt; M = [1. 2. ; 3. 4.] 2×2 Array{Float64,2}: 1.0 2.0 3.0 4.0 julia&amp;gt; size(M) (2, 2) julia&amp;gt; length(M) 4 For matrices, the syntax is defined and used almost exactly like Matlab. The size() function is used just</description></item><item><title>Translating Arrays in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1453/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1453/</guid><description>Description Using circshifr(A, (n,m)), you can shift the rows of the array A $n$ positions down, and the columns $m$ positions to the right. (n,m) must be a tuple of integers, and negative numbers are also possible. If negative, it shifts in the opposite direction. For arrays of 3 dimensions or more, it is applied to each smallest 2-dimensional array respectively. Code 2D array julia&amp;gt; A = transpose(reshape(1:25,5,5)) 5×</description></item><item><title>Various Methods of Creating Vectors in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1452/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1452/</guid><description>Code julia&amp;gt; x1=[1 2 3] 1×3 Array{Int64,2}: 1 2 3 julia&amp;gt; x2=[1, 2, 3] 3-element Array{Int64,1}: 1 2 3 julia&amp;gt; x3=[i for i in 1:3] 3-element Array{Int64,1}: 1 2 3 julia&amp;gt; x4=[i for i in 1:3:10] 4-element Array{Int64,1}: 1 4 7 10 julia&amp;gt; x5=[i for i in 1:3:11] 4-element Array{Int64,1}: 1 4 7 10 x1 is a 2-dimensional array. Since it looks like a row vector, if you</description></item><item><title>Installing and Using Packages in Julia</title><link>https://freshrimpsushi.github.io/en/posts/1416/</link><pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1416/</guid><description>Method 1 using LinearAlgebra using Pkg Pkg.add(&amp;#34;Plots&amp;#34;) Pkg.add(&amp;#34;Distributions&amp;#34;) using Plots The above code demonstrates importing the LinearAlgebra and Pkg packages and installing the Plots, Distribution packages using the .add() function. The keyword using to import packages is somewhat reminiscent of the language used in mathematics when applying a theorem or argument. Installing packages is more akin to R than Python, and its usage closely resembles that of Python. Similar to</description></item><item><title>줄리아의 타입과 애노테이션</title><link>https://freshrimpsushi.github.io/en/posts/1379/</link><pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1379/</guid><description>Code julia&amp;gt; typeof(0) Int64 julia&amp;gt; typeof(0.0) Float64 julia&amp;gt; typeof(0 == 0.0) Bool julia&amp;gt; typeof(Bool) DataType julia&amp;gt; typeof(NaN) Float64 julia&amp;gt; typeof(Inf) Float64 julia&amp;gt; typeof(&amp;#39;O&amp;#39;) Char julia&amp;gt; typeof(&amp;#34;Ohmygirl&amp;#34;) String julia&amp;gt; typeof(&amp;#34;O&amp;#34;) String Julia implements a variety of types. $0$ and $0.0$ are the same $0$ but have different types, and as you can see, even the type Bool has a type called DataType. Similar to the C language, String is an array</description></item><item><title>Julia Programming Language</title><link>https://freshrimpsushi.github.io/en/posts/1374/</link><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/en/posts/1374/</guid><description>Overview Julia has been developed at MIT and publicly released in 2012, aiming for a language that is both highly productive and fast. It achieves speeds comparable to C or Fortran while also providing a high-level syntax similar to Python or R, among absorbing benefits from various other languages. As of November 2019, it&amp;rsquo;s true that Julia is somewhat lagging due to the rapid advancement of GPUs and the prevalence</description></item></channel></rss>