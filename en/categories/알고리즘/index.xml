<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on FreshrimpRestaurant</title>
    <link>https://freshrimpsushi.github.io/en/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
    <description>Recent content in Algorithm on FreshrimpRestaurant</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 22 Sep 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://freshrimpsushi.github.io/en/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stalin Sort</title>
      <link>https://freshrimpsushi.github.io/en/posts/2268/</link>
      <pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/2268/</guid>
      <description>Algorithm 1 Let&amp;rsquo;s say we have an array of length $n$. If we read the array from the beginning to the end and repeatedly remove elements where the element behind is greater than the one in front, we &amp;lsquo;in order&amp;rsquo; obtain a sorted array. Its time complexity is $O(n)$, and the pseudocode is as follows. FUNCTION stalinSort(A : list OF sortable items) n := length(A) bigger := 0 B SET</description>
    </item>
    <item>
      <title>Smith-Waterman Alignment: Local Sequence Alignment</title>
      <link>https://freshrimpsushi.github.io/en/posts/2017/</link>
      <pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/2017/</guid>
      <description>Overview Finding the alignment of the most similar parts from two base sequences is called local alignment, and the most widely used method for this is introducing the Smith-Waterman Algorithm. There are so many possible cases in Sequence Alignment, so there is a need to calculate efficiently and quickly through Dynamic Programming. Algorithm1 Input Given two strings $\textbf{v}, \textbf{w}$ and Substitution Matrix $\delta$, let&amp;rsquo;s say they are displayed as follows.</description>
    </item>
    <item>
      <title>Needleman-Wunsch Algorithm: Global Sequence Alignment</title>
      <link>https://freshrimpsushi.github.io/en/posts/2012/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/2012/</guid>
      <description>Overview Finding an alignment between two sequences that maximizes the number of common parts is called Global Alignment, and the most widely used method for this is the Needleman-Wunsch Algorithm. There are too many possible alignments in sequence alignment, so it&amp;rsquo;s necessary to compute them efficiently and quickly through dynamic programming. Algorithm1 Input Given two strings $\textbf{v}, \textbf{w}$ and a substitution matrix $\delta$, let&amp;rsquo;s represent them as follows. $$ \textbf{v}</description>
    </item>
    <item>
      <title>Sequence Alignment Scores and Gap Penalty</title>
      <link>https://freshrimpsushi.github.io/en/posts/1878/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1878/</guid>
      <description>Definitions Let&amp;rsquo;s assume we are given a reference sequence and a query sequence. A Sequence Alignment Score is the numerical representation and methodology of how well two sequences match when compared. Scoring is calculated based on weights assigned to the following: Match: The number of times the two sequences align. Mismatch: The number of times the two sequences do not align. Example For instance, consider the two nucleotide sequences shown</description>
    </item>
    <item>
      <title>Substitution Matrix in Sequence Alignment</title>
      <link>https://freshrimpsushi.github.io/en/posts/1881/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1881/</guid>
      <description>Definition A Substitution Matrix is the matrix used as a criterion for matches and mismatches when scoring sequence alignment. Example using BioAlignments EDNAFULL BLOSUM45 PAM30 Let’s dive straight into the examples. In Julia, there is a package called BioAlignments available, which allows one to easily load the desired substitution matrix. When loading matrices frequently used for DNA analysis like EDNAFULL or BLOSUM (BLOcks SUbstitution Matrix), and</description>
    </item>
    <item>
      <title>What is Sequence Alignment?</title>
      <link>https://freshrimpsushi.github.io/en/posts/1874/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1874/</guid>
      <description>Definition Sequence Alignment refers to the process of arranging sequences based on their similarity among base sequences. [^1]</description>
    </item>
    <item>
      <title>String Edit Distance</title>
      <link>https://freshrimpsushi.github.io/en/posts/1872/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1872/</guid>
      <description>Buildup 1 Strings have the following four operations: Insertion: Insert a new character into the string. Deletion: Remove a character from the string. Replacement: Replace one character in the string with another. Transposition: Swap the positions of two characters. Definition The edit distance is a distance function between strings, categorized into the following types by allowing or forbidding certain editing methods: (1) Hamming distance: Hamming distance is the simplest, allowing</description>
    </item>
    <item>
      <title>Genomics and Genes in Bioinformatics</title>
      <link>https://freshrimpsushi.github.io/en/posts/1864/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1864/</guid>
      <description>Definition The entire collection of genetic material in an organism is called a genome. A segment of the genome that serves as the unit of genetic traits is called a gene. Specifically, in eukaryotes, it consists of introns and exons. Explanation In fact, the term genome is seldom used as a pure Korean term, and it is commonly referred to as 게놈 or 지놈. Both genome and</description>
    </item>
    <item>
      <title>Intron and Exon in Bioinformatics</title>
      <link>https://freshrimpsushi.github.io/en/posts/1862/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1862/</guid>
      <description>Definition The part of DNA in eukaryotes that actually involves in the synthesis of proteins is referred to as exon, while the part that does not is called intron. Explanation Prokaryotes and eukaryotes are differentiated by the presence or absence of a nuclear membrane in the cell nucleus, but an important difference from the perspective of bioinformatics is whether the process of splicing, which occurs after mRNA is transcribed due</description>
    </item>
    <item>
      <title>Upstream and Downstream of the Base Sequence</title>
      <link>https://freshrimpsushi.github.io/en/posts/1855/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1855/</guid>
      <description>Buildup 1 The orientation of a nucleotide sequence can be represented by numbering based on the position of carbon atoms in the sugar as shown in the image above. RNA and DNA specifically form chains through the phosphodiester bond between the 3&amp;rsquo; carbon $3&amp;rsquo;$ and the 5&amp;rsquo; carbon $5&amp;rsquo;$. Let&amp;rsquo;s suppose four bases are given with their carbon positions as follows. $$ 3&amp;rsquo;C5&amp;rsquo; \\ 5&amp;rsquo;A3&amp;rsquo; \\ 5&amp;rsquo;G3&amp;rsquo; \\ 5&amp;rsquo;T3&amp;rsquo; $$</description>
    </item>
    <item>
      <title>Codon and Amino Acid Genetic Code in Bioinformatics</title>
      <link>https://freshrimpsushi.github.io/en/posts/1852/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1852/</guid>
      <description>Definition A unit consisting of three bases of DNA in sequence is called a triplet code. The triplet code of transcribed mRNA, according to the Central Dogma, is called a codon. Chemically, a molecule that includes an amino group and a carboxyl group, and which serves as the building block of proteins, is called an amino acid. The correspondence between the sequence of codons and amino acids is called the</description>
    </item>
    <item>
      <title>Principles of Molecular Biology</title>
      <link>https://freshrimpsushi.github.io/en/posts/1850/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1850/</guid>
      <description>Principles The central principle or the Central Dogma of molecular biology proposes that genetic information is transferred from DNA to RNA, and from RNA to protein, which is comprised of the following three phenomena: Replication: DNA replicates itself. Transcription: RNA, which contains the same information as DNA, is synthesized. Translation: Proteins are synthesized according to the information in RNA. Explanation The Central Dogma was an hypothesis proposed by Francis Crick</description>
    </item>
    <item>
      <title>Key Bases and Base Pairs in Bioinformatics</title>
      <link>https://freshrimpsushi.github.io/en/posts/1832/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1832/</guid>
      <description>Definition The following five bases are referred to as the Canonical Bases: Purine bases: Adenine $A$, Guanine $G$ Pyrimidine bases: Cytosine $C$, Thymine $T$, Uracil $U$ Description Thymine is only used in DNA, while Uracil is used in RNA. Therefore, by checking whether $T$ or $U$ is used in the data, one can tell whether it is a DNA or RNA base sequence. A Base Pair is formed by two</description>
    </item>
    <item>
      <title>Bioinformatics: DNA Sequencing</title>
      <link>https://freshrimpsushi.github.io/en/posts/1828/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1828/</guid>
      <description>Build-up A polymer is a large molecule composed of repeating monomeric units linked by chemical synthesis. Phosphoric Acid is a type of inorganic oxyacid, with the chemical formula $H_{3}PO_{4}$. A monosaccharide with five carbon atoms is called Pentose. The molecule that functions as the basic unit of genetic information is known as a Nitrogenous base or simply Base. A nucleotide is a molecule that consists of phosphate-pentose-base and becomes the</description>
    </item>
    <item>
      <title>Biomedical Informatics: DNA, RNA, Chromosomes</title>
      <link>https://freshrimpsushi.github.io/en/posts/1827/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1827/</guid>
      <description>Buildup Polymers are high molecular compounds formed by the repeating connection of monomers through chemical synthesis. Phosphoric Acid is a type of inorganic oxyacid, with the chemical formula $H_{3}PO_{4}$. Monosaccharides with five carbon atoms are called Pentoses. Molecules that function as the basic unit of genetic information are called Nitrogenous bases, or simply Bases. A molecule composed of phosphate, pentose, and a base, serving as the building block of nucleic</description>
    </item>
    <item>
      <title>Prokaryotes and Eukaryotes in Bioinformatics</title>
      <link>https://freshrimpsushi.github.io/en/posts/1810/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1810/</guid>
      <description>Definitions Organisms without a nuclear membrane are called Prokaryotes. Organisms consisting of nuclei with nuclear membranes are called Eukaryotes. Description In eukaryotic organisms, the part containing the genetic material, the Nucleus, and the Cytoplasm, where various metabolisms occur, are distinguished by the Nuclear Envelope. However, prokaryotic cells do not have a distinct boundary called a nuclear membrane but have a Nucleoid. The English notation of prokaryotic organisms signifies that the</description>
    </item>
    <item>
      <title>Greedy Algorithm</title>
      <link>https://freshrimpsushi.github.io/en/posts/1434/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1434/</guid>
      <description>Definition Greedy algorithm is a method of making choices that only considers the current moment and selects the best possible option. Description As its name suggests, the greedy algorithm focuses on the immediate without taking a long-term perspective. Speaking positively, it&amp;rsquo;s always trying to do its best, but this may not always be wise when looking at the bigger picture. Consider the following example: Let&amp;rsquo;s say there&amp;rsquo;s a problem of</description>
    </item>
    <item>
      <title>Levenshtein Algorithm</title>
      <link>https://freshrimpsushi.github.io/en/posts/510/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/510/</guid>
      <description>Algorithm Input Let&amp;rsquo;s denote the string as $A,B$, $A=[a_{i}]=(a_{1}, a_{2} , \cdots, a_{n})$, and $B=[b_{j}]=(b_{1}, b_{2} , \cdots, b_{m})$. Step 1. Initialization Create the matrix $M_{(n+1) \times (m+1)} = [m_{x y }]$ and assign $M_{11} ← 0$. Then fill the $1$ row and $1$ column as follows: $$ M_{(i+1) 1} ← i \\ M_{ 1 (j+1)} ← j $$ Step 2. Dynamic Programming for $i = 1, 2, \cdots ,</description>
    </item>
    <item>
      <title>Radix Sort</title>
      <link>https://freshrimpsushi.github.io/en/posts/1363/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1363/</guid>
      <description>Algorithm Assuming we have data comprised of numbers with digits limited to $k$. In this case, the data will be sorted according to the following algorithm, and its time complexity is $O (n)$. Sort by comparing the $i = 1 , \cdots , k$th digits of each number. Explanation Radix Sort is a clever method that can sort data in linear time without comparing the data elements, overcoming the limits</description>
    </item>
    <item>
      <title>Lower Bound on the Time Complexity of Comparison Sorting Algorithms</title>
      <link>https://freshrimpsushi.github.io/en/posts/1359/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1359/</guid>
      <description>Theorem The time complexity of comparison-based sorting algorithms cannot be better than $\Omega ( n \log n )$. Explanation Algorithms are inherently fascinating, yet seeing efficient ones like insertion sort being outperformed by quick sort makes one wonder if there exists an even more efficient algorithm. Fortunately or unfortunately, based on this proof, there is no need to consider algorithms more efficient than this. Of course, there might exist faster</description>
    </item>
    <item>
      <title>Time Complexity of Comparison Sorting Algorithms</title>
      <link>https://freshrimpsushi.github.io/en/posts/1357/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1357/</guid>
      <description>Theorem Given $n$ pieces of data, the time complexity of comparison sorting algorithms is as follows: [1] Bubble sort: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [2] Selection sort: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [3] Insertion sort: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [4] Heap sort: $$ \Theta ( n \log n ) \\ O</description>
    </item>
    <item>
      <title>Dynamic Programming</title>
      <link>https://freshrimpsushi.github.io/en/posts/1262/</link>
      <pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1262/</guid>
      <description>Buildup When solving a problem, if the solution to a larger problem includes the solution to a smaller problem, it is said to have an Optimal Substructure. An easy example of a problem with an optimal substructure is calculating the Fibonacci numbers. The $n$-th Fibonacci number is calculated as $a_{n} = a_{n-1} + a_{n-2}$, thus, the larger problem $a_{n}$ includes the smaller problems $a_{n-1}$ and $a_{n-2}$. A simple way to</description>
    </item>
    <item>
      <title>Reasons to Be Careful When Using Recursive Functions</title>
      <link>https://freshrimpsushi.github.io/en/posts/1254/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1254/</guid>
      <description>Caution When you first learn programming, regardless of the language, there&amp;rsquo;s a common caution that &amp;lsquo;recursion should be used carefully.&amp;rsquo; This is because recursion isn&amp;rsquo;t as frequently utilized technique, and the reason behind this caution is often left unexplained. This can lead to confusion for learners on why such a useful method is discouraged. Let&amp;rsquo;s delve into the examples to understand it better. Example def fibo1(n) : if n==1 or</description>
    </item>
    <item>
      <title>Time Complexity and Space Complexity</title>
      <link>https://freshrimpsushi.github.io/en/posts/1283/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1283/</guid>
      <description>Definition The time it takes to solve a given problem is called time complexity, and the memory requirements are referred to as space complexity. Example Asymptotic notation is a very useful means for expressing these. Let&amp;rsquo;s take a look at an example of time complexity. Constant Time $O(1)$ Algorithms that can finish regardless of $n$, essentially taking no time. For example, finding the third element in $\mathbb{x} = [4,3,8,-1,-9,0,5,7,2,6]$ just</description>
    </item>
    <item>
      <title>Asymptotic Notation of the Cost of Algorithms</title>
      <link>https://freshrimpsushi.github.io/en/posts/1281/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/1281/</guid>
      <description>Definition The cost of an algorithm for data of size $n$ is denoted as follows: $O$ notation: $$ O(g(n)) := \left\{ f(n) \ | \ \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \le c g(n) \right\} $$ $\Omega$ notation: $$ \Omega (g(n)) := \left\{ f(n) \ | \ \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \ge</description>
    </item>
    <item>
      <title>Zipf&#39;s Law</title>
      <link>https://freshrimpsushi.github.io/en/posts/560/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/560/</guid>
      <description>Laws Given a corpus, if the relative frequency of the $k$th most common word is denoted as $f_{k}$, then $$ f_{k} = {{C} \over {k}} $$ Explanation Here, $C$ is a normalization factor that makes $\displaystyle \sum_{k} f_{k} = 1$ possible. If shown as a histogram, the shape is roughly as described above, with the scale adjusted so the total area precisely equals $1$. The thick tail shape that appears</description>
    </item>
    <item>
      <title>Heaps&#39; Law</title>
      <link>https://freshrimpsushi.github.io/en/posts/559/</link>
      <pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/559/</guid>
      <description>Law Given the number of unique words as $M$, and the number of tokens as $T$ in a corpus, $$ M = kT^{b} $$ Explanation When the corpus is in English, the constant $k,b$ is typically $10 \le k \le 100$, and about $b = 0.5$. Heaps&amp;rsquo; law is not derived from a mathematical foundation but empirically obtained. The formula may seem quite complex at first glance, but if both</description>
    </item>
    <item>
      <title>n-Gram and Jaccard Coefficient</title>
      <link>https://freshrimpsushi.github.io/en/posts/525/</link>
      <pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate>
      <guid>https://freshrimpsushi.github.io/en/posts/525/</guid>
      <description>Definition An n-gram is a contiguous sequence of n items from a given sample of text or speech. The Jaccard Coefficient is a measure of how similar two sets are, ranging between $0$ and $1$. It can be mathematically represented as follows: $$ JC(A,B) = {{| A \cap B|} \over {| A \cup B| }} = {{| A \cap B|} \over { |A|+ |B| -| A \cap B| }} $$</description>
    </item>
  </channel>
</rss>
