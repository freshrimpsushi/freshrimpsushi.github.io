<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R_s on 생새우초밥집</title>
    <link>https://freshrimpsushi.github.io/r_/</link>
    <description>Recent content in R_s on 생새우초밥집</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Tue, 12 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/r_/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>git 자동 로그인하는 법</title>
      <link>https://freshrimpsushi.github.io/how-to-save-git-password/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/how-to-save-git-password/</guid>
      <description>커맨드 git config credential.helper store Credential 정보를 저장하면 된다.</description>
    </item>
    
    <item>
      <title>서열정렬에서의 치환행렬</title>
      <link>https://freshrimpsushi.github.io/substitution-matrix/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/substitution-matrix/</guid>
      <description>정의 서열정렬 점수를 매길 때 매치와 미스매치의 기준이 되는 행렬을 치환행렬이라 한다. 예시 거두절미하고 예시부터 보자. 줄리아에서는 BioAlignments라는 패키지가 나와있고 손쉽게 원하는 치환행렬을 불러들일 수 있다. DNA 분석에 자주 사용되는 EDNAFULL나 단백질 서열에 쓰이는 BLOSUM(BLOcks SUbstitution Matrix), PAM (Point Accepted Mutation) 행렬을 불러보면 다음과 같다. julia&amp;gt; using</description>
    </item>
    
    <item>
      <title>서열정렬 점수와 갭 페널티</title>
      <link>https://freshrimpsushi.github.io/sequence-alignment-score-and-gap-penalty/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/sequence-alignment-score-and-gap-penalty/</guid>
      <description>정의(서열정렬 점수) 레퍼런스 서열과 쿼리 서열이 주어져 있다고 하자. 서열정렬 점수란 두 서열을 비교했을 때 얼마나 일치하는지를 수치화하는 것과 그 방법을 말한다. 점수화는 다음과 같은 사항들에 가중치를 주어 계산된다. 1. Match: 두 서열이 일치하는 횟수다. 2. Mismatch: 두 서열이 일치하지 않는 횟수다. 예로써 위와 같은 두 염기서열이 있다고 하자. 이때 서열정렬</description>
    </item>
    
    <item>
      <title>서열정렬이란?</title>
      <link>https://freshrimpsushi.github.io/what-is-sequence-alignment/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/what-is-sequence-alignment/</guid>
      <description>정의 염기서열 간의 유사도를 근거로 나열하는 것을 서열정렬이라 한다. 설명 1 생명정보공학에서 유전체의 길이는 무척 길기 때문에 이를 데이터화하는 것부터가 엄청난 일이다. 상상하기에는 우리도 중합효소처럼 DNA의 상류부터 하류까지 순서대로 읽으면서 저장하면 좋을 것 같지만, 현실적으로는 그렇게 할 수가 없기 때문에 조각으로 나눠진 짧은 염기서열</description>
    </item>
    
    <item>
      <title>문자열의 편집 거리</title>
      <link>https://freshrimpsushi.github.io/edit-distance-of-strings/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/edit-distance-of-strings/</guid>
      <description>빌드업 편집 방법1 문자열에는 다음과 같이 네가지 작용이 있다. 1. 삽입: 문자열에 새로운 문자를 끼워넣는다. 2. 제거: 문자열에서 문자 하나를 없앤다. 3. 교체: 문자열에서 문자 하나를 다른 문자로 바꾼다. 4. 전치: 두 문자의 위치를 서로 바꾼다. 종류 편집 거리는 문자열간의 거리 함수로써 편집 방법을 허용하거나 금지함으로써 다음과 같은 타입들로 구분</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 유전체와 유전자</title>
      <link>https://freshrimpsushi.github.io/genome-and-gene-in-bioinformatics/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/genome-and-gene-in-bioinformatics/</guid>
      <description>정의 1. 한 개체의 염기서열을 모두 모은 것을 유전체라고 한다. 2. 유전체의 일부를 차지하는 구간으로, 유전 형질의 단위가 되는 것을 유전자라고 한다. 특히 진핵생물에서는 인트론과 엑손으로 이루어져있다. 설명 사실 genome에 대해 유전체라는 순화는 거의 쓰이지 않고, 게놈 혹은 지놈으로 부르는게 보통이다. 지놈과 유전자는, 특히 유전자는 생명공</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 인트론과 엑손</title>
      <link>https://freshrimpsushi.github.io/intron-and-exon-in-bioinformatics/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/intron-and-exon-in-bioinformatics/</guid>
      <description>정의 진핵 생물의 DNA에서 실제로 단백질의 합성에 관여하는 부분을 엑손, 그렇지 않은 부분을 인트론이라고 한다. 설명 원핵 생물과 진핵 생물은 세포핵에 핵막이 있냐 없느냐로 구분되지만, 생명정보공학의 관점에서 중요한 차이점은 센트럴 도그마에 의해 mRNA가 전사되고 난 뒤의 스플라이싱Splicing이라는 과정이 있느냐 없느냐다. 원핵 생물</description>
    </item>
    
    <item>
      <title>염기서열의 상류와 하류</title>
      <link>https://freshrimpsushi.github.io/upstream-and-downstream-of-nucleic-sequence/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/upstream-and-downstream-of-nucleic-sequence/</guid>
      <description>빌드업 1 염기서열의 방향은 위의 그림처럼 오탄당의 탄소 원자 위치에 따라 번호를 부여함으로써 나타낼 수 있다. RNA와 DNA는 구체적으로 3번 탄소 3&amp;rsquo;와 5번 탄소 5&amp;rsquo;가 **인산에스터 결합(Phosphodiester Bond)**을 형성함으로써 사슬 구조를 이룬다. 가령 네 개의 염기가 다음과 같이 탄소 위치</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 코돈과 아미노산, 유전 부호</title>
      <link>https://freshrimpsushi.github.io/codon-amino-acid-genetic-code/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/codon-amino-acid-genetic-code/</guid>
      <description>정의 1. DNA의 염기 3개를 순서쌍으로 묶은 단위를 트리플렛 코드Triplet Code라 한다. 2. 센트럴 도그마에 따라 전사된 mRNA의 트리플렛 코드를 코돈이라 한다. 3. 화학적으로 아미노기와 카복시기를 포함한 분자로, 단백질의 구성 단위를 아미노산이라 부른다. 4. 코돈의 순열에 따라 아미노산의 대응관계를 유전 부호라 한다. 설명 유전 부호</description>
    </item>
    
    <item>
      <title>분자생물학의 중심원리</title>
      <link>https://freshrimpsushi.github.io/central-dogma-of-molecular-biology/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/central-dogma-of-molecular-biology/</guid>
      <description>원리 분자생물학의 중심원리 혹은 센트럴 도그마란 유전 정보는 DNA에서 RNA로, RNA에서 단백질로 전달된다는 가설로써 다음과 같은 세 가지 현상으로 이루어져있다. 1. 복제: DNA는 스스로 복제된다. 2. 전사: DNA와 같은 정보를 담은 RNA가 만들어진다. 3. 번역: RNA의 정보에 따라 단백질이 합성된다. 설명 센트럴 도그마는 DNA의 이</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 주요 염기와 염기쌍</title>
      <link>https://freshrimpsushi.github.io/primary-base-and-base-pair-in-bioinformatcs/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/primary-base-and-base-pair-in-bioinformatcs/</guid>
      <description>정의 다음의 다섯가지 염기를 주요 염기라고 한다. 1. 퓨린 염기 : 아데닌Adenin $A$, 구아닌Guanine $G$ 2. 피리미딘 염기 : 사이토신Cytosine $C$, 티민Thymine $T$, 유라실Uracil $U$ 설명 티민은 DNA에서만 사용되며, 유라실은 RNA에서만 사용된다. 따라서 데이터에서 $T$ 와 $U$ 중 어느 것이 쓰이는지만 확인해도 DNA와 RNA</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 염기서열</title>
      <link>https://freshrimpsushi.github.io/nucleic-sequence-in-bioinformatics/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/nucleic-sequence-in-bioinformatics/</guid>
      <description>빌드업 1. 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 2. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화학식은 $H_{3}PO_{4}$이다. 3. 5개의 탄소 원자를 갖는 단당류를 오탄당Pentose이라 한다. 4. 유전 정보의 기본단위로써 기능하는 분자를 질소 염기Nitrog</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 DNA, RNA, 염색체</title>
      <link>https://freshrimpsushi.github.io/dna-rna-chromosome-in-bioinformatics/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/dna-rna-chromosome-in-bioinformatics/</guid>
      <description>빌드업 1. 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체Polymer라고 한다. 2. 인산Phosphoric Acid은 무기 산소산의 일종으로, 화학식은 $H_{3}PO_{4}$이다. 3. 5개의 탄소 원자를 갖는 단당류를 오탄당Pentose이라 한다. 4. 유전 정보의 기본단위로써 기능하는 분자를 질소 염기Nitrog</description>
    </item>
    
    <item>
      <title>생명정보공학에서의 원핵 생물과 진핵 생물</title>
      <link>https://freshrimpsushi.github.io/prokaryotes-and-eukaryotes/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/prokaryotes-and-eukaryotes/</guid>
      <description>정의 1. 핵막이 없는 생물을 원핵 생물Prokaryotes이라 한다. 2. 핵막이 있는 핵으로 이루어진 생물을 진핵 생물Eukaryotes이라 한다. 설명 진핵 생물에서는 유전 물질을 지니는 부분인 세포핵Nucleus과 각종 대사가 일어나는 세포질Cytoplasm이 핵막NuclearEnvelope에 의해 구분되지만 원핵 세포는 핵</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://freshrimpsushi.github.io/greedy-algorithm/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/greedy-algorithm/</guid>
      <description>정의 그리디 알고리즘이란 어떤 선택을 할 때 그 순간만을 고려해서 가장 좋은 경우를 고르는 방법이다. 예시 그리드 알고리즘은 탐욕Greed이라는 이름대로 길게 보지 않고 그 순간만을 생각한다. 좋게 말하면 항상 최선을 다하는 것이지만, 크게 보았을 때 이는 현명하지 못할 수도 있다. 다음의 예시를 보자 : 왼쪽 0에서 시작해 오른쪽 1에 도착하는 경로를 찾는</description>
    </item>
    
    <item>
      <title>동치류</title>
      <link>https://freshrimpsushi.github.io/equivalence-class/</link>
      <pubDate>Fri, 08 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/equivalence-class/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>레벤슈타인 알고리즘</title>
      <link>https://freshrimpsushi.github.io/levensteins-algorithm/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/levensteins-algorithm/</guid>
      <description>알고리즘 문자열 $A,B$ 를 $A=[a_{i}]=(a_{1}, a_{2} , \cdots, a_{n})$ 과 $B=[b_{j}]=(b_{1}, b_{2} , \cdots, b_{m})$ 로 표현하자. Step 1. 행렬 $M_{(n+1) \times (m+1)} = [m_{x y }]$ 를 만들고 $M_{11} = 0$ 을 대입한다. Step 2. $m_{(i+1) 1} = i$ 그리고 $m_{ 1 (j+1)} = j$ 을 대입한다. Step 3. for $i = 1, 2, \cdots , n$ 그리고 $j=1,2, \cdots , m$ if $a_{i}==b_{j}$ $M_{i,j} = M_{(i-1)(j-1)}$ 을 대입한다. else $M_{i,j} = \min \left\{ M_{(i-1)(j)}, M_{(i)(j-1)}, M_{(i-1)(j-1)}\right\} + 1 $ 을 대입한다. Step 4. $A$,$B$ 의 최소 수정 거리는 $m_{nm}$ 이다. 설명 편집 거리란 두 문자열 간의 유사성을 보여주</description>
    </item>
    
    <item>
      <title>집합의 분할</title>
      <link>https://freshrimpsushi.github.io/partition-of-set/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/partition-of-set/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>기수 정렬</title>
      <link>https://freshrimpsushi.github.io/radix-sort/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/radix-sort/</guid>
      <description>알고리즘 기수 정렬 자리수가 $k$ 로 제한된 $n$ 개의 자연수로 이루어진 데이터가 주어져있다고 하자. 그러면 데이터는 다음의 알고리즘에 따라 정렬되며 그 시간 복잡도는 $O (n)$ 이다. $i = 1 , \cdots , k$ 번째 자리수들끼리 비교해서 정렬한다. 설명 기수 정렬은 자리수의 제한이 있기 때문에 부동소수점이 있는 데이터에 적용할 수는 없으나, 정렬할 때 데이터간의 비교를</description>
    </item>
    
    <item>
      <title>수학에서의 동치관계</title>
      <link>https://freshrimpsushi.github.io/equivalent-relation/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/equivalent-relation/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>수학에서의 이항관계</title>
      <link>https://freshrimpsushi.github.io/binary-relation/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/binary-relation/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>프로그래밍 패러다임</title>
      <link>https://freshrimpsushi.github.io/programming-paradigm/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/programming-paradigm/</guid>
      <description>정의 프로그래밍 패러다임이란 주어진 문제를 해결하는 프로그램을 작성할 때의 관점 내지 방법론을 말한다. 어떠한 패러다임에 알맞는 프로그래밍 언어는 그러한 프로그래밍 패러다임을 갖는다고 말하며, 대개의 언어는 하나의 패러다임을 갖는다. 여러 패러다임을 갖는 언어를 멀티 패러다임 언어라고 한다. 설명 언어가 하나의 패러다임을 갖는다는 것은 다른 패</description>
    </item>
    
    <item>
      <title>집합의 데카르트 곱</title>
      <link>https://freshrimpsushi.github.io/cartesian-product/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/cartesian-product/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘 시간 복잡도의 하한</title>
      <link>https://freshrimpsushi.github.io/lower-bound-of-comparison-sort-algorithm/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/lower-bound-of-comparison-sort-algorithm/</guid>
      <description>정리 비교 정렬 알고리즘의 시간복잡도는 아무리 좋아도 $\Omega ( n \log n )$ 이다. 설명 알고리즘이 원래 신기한 것이지만, 삽입 정렬과 같은 효율적인 알고리즘도 퀵 정렬에 밀리는 것을 보면 그 이상의 알고리즘도 있지 않을까 궁금할 수밖에 없다. 다행인지 아닌지는 모르겠으나, 이 증명에 따라 그보다 효율적인 알고리즘을 생각할 필요는 없다. 물론 일반적인 비교 알고</description>
    </item>
    
    <item>
      <title>집합족과 첨수</title>
      <link>https://freshrimpsushi.github.io/family-and-index/</link>
      <pubDate>Sat, 02 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/family-and-index/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>비교 정렬 알고리즘들의 시간 복잡도</title>
      <link>https://freshrimpsushi.github.io/time-complexity-of-comparison-sort-algorithms/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/time-complexity-of-comparison-sort-algorithms/</guid>
      <description>시각화 $n$ 개의 데이터가 주어져 있을 때, 비교 정렬 알고리즘들의 시간 복잡도는 다음과 같다. [1] 버블 정렬 : $$\Theta ( n^2 ) \ O ( n^2 )$$ [2] 선택 정렬 : $$\Theta ( n^2 ) \ O ( n^2 )$$ [3] 삽입 정렬 : $$\Theta ( n^2 ) \ O ( n^2 )$$ [4] 힙 정렬 : $$\Theta ( n \log n ) \ O ( n \log n )$$ [5] 합병 정렬 : $$\Theta ( n \log n ) \ O ( n \log n )$$ [6] 퀵 정렬 : $$\Theta ( n \log n ) \ O ( n^2 )$$ 여기서 소개되는 알고리즘들이</description>
    </item>
    
    <item>
      <title>선택 공리가 추가된 체르멜로-프렝켈 집합론</title>
      <link>https://freshrimpsushi.github.io/fraenkel-set-theory-with-the-axiom-of-choice-included/</link>
      <pubDate>Thu, 31 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/fraenkel-set-theory-with-the-axiom-of-choice-included/</guid>
      <description>이관 대기</description>
    </item>
    
    <item>
      <title>선택 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-choice/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-choice/</guid>
      <description>이관 대기 $$ \forall U \left( \emptyset \notin U \implies \exists f : U \to \bigcup_{X \in U \\ f(X) \in X } U \right) $$ 모든 공집합이 아닌 집합들의 집합 $U$ 에 대해 $U$ 의 모든 원소로부터 원소 하나씩을 선택하는 선택 함수 $f$ 가 존재한다. 선택 공리는 가령 다음과 같은 집합의 집합 $U$ 가 있을 때, 그 원소인 집합에서 원소 하나을 뽑는 함수 $f$ 가 존재함을 보장해준다. 가령 다음의 예를 생각해보자 : $$ U = \left\{ \left\{ \pi , 1/2 \right\}</description>
    </item>
    
    <item>
      <title>치환 공리꼴</title>
      <link>https://freshrimpsushi.github.io/axiom-schema-of-replacement/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-schema-of-replacement/</guid>
      <description>이관 대기 $$ \forall X \left( \forall x \in X \exists ! y \left( p(x,y) \right) \implies \exists Y \forall x \in X \exists y \in Y \left( p(x,y) \right) \right) $$ 모든 함수에 대한 치역이 존재한다. * 기호 $\exists !$ 는 유일하게 존재함을 의미한다. * 여기서 $p(x,y)$ 는 $X \times Y$ 에서의 명제함수다. 명제함수 $p(x,y)$ 는 물론 함수지만 엄밀하게 말해 함수로써 정의된 것은 아니며, 설령 함수로 정의되었다고 할지라도 위 공리에서 말하는 함수 그 자체는 아니다.</description>
    </item>
    
    <item>
      <title>정칙성 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-regularity/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-regularity/</guid>
      <description>이관 대기 $$ \forall X \left( \exists x_{0} ( x_{0} \in X ) \implies \exists y ( y \in X \land \lnot \exists x ( x \in y \land x \in X )) \right) $$ 모든 집합 $X \ne \emptyset$ 은 자기 자신과 서로소인 원소를 가진다. 정칙성 공리에 따라 스스로를 원소로 포함하는 재귀 집합, 예컨대 $X = \left\{ X \right\}$ 와 같은 집합은 존재할 수 없다. 자기 자신과 서로소가 되기 위해서는 적어도 자기 자신은 아니어야하기 때문이다. 정칙성 공리는 공집합이</description>
    </item>
    
    <item>
      <title>무한 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-infinity/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-infinity/</guid>
      <description>이관 대기 $$ \exists U \left( \emptyset \in U \land \forall X ( X \in U \implies S(X) \in U) \right) $$ 공집합과 $X$ 를 원소로 가지면 $S(X)$ 도 원소로 가지는 집합 $U$ 가 존재한다. * 집합 $X$ 에 대해 $S(X)$ 는 $S(X) := X \cup \left\{ X \right\}$ 와 같이 정의되는 집합이다. 이것이 왜 무한 공리인지를 구구절절 설명하는 것보다 자연수 집합 $\mathbb{N}$ 의 존재성 증명을 한 번 보는 게 낫다. $\mathbb{N}$ 이 존재한다. Strategy : 폰 노이만이 제안한 구성법으로써, 자연</description>
    </item>
    
    <item>
      <title>멱집합 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-power-set/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-power-set/</guid>
      <description>이관 대기 $$ \forall X \exists P \forall A ( A \subset X \implies A \in P) $$ 임의의 집합 $X$ 에 대해 $X$ 의 모든 부분집합을 원소로 갖는 집합 $P$ 가 존재한다. $X$ 의 멱집합은 일반적으로 $\mathcal{P} (X)$ 와 같이 표기하거나 $2^{X}$ 와 같이 쓰는데, 그 이유는 유한 집합 $X$ 의 원소의 개수를 $|X|$ 이라고 하면 $P(X)=2^{|X|}$ 이기 때문이다. 꼭 개수가 중요한 것은 아니기 때문에 집합론을 많이 쓰면 많이 쓰는 분과일수록 $2^{X}$ 와 같은 표현을</description>
    </item>
    
    <item>
      <title>합집합 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-union/</link>
      <pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-union/</guid>
      <description>이관 대기 $$ \forall X \left( \exists U \left( \forall a \left( a \in x \land x \in X \implies a \in U \right) \right) \right) $$ 임의의 집합 $X$ 에 대해 $X$ 모든 원소들의 원소들을 포함하는 집합 $U$ 가 존재한다. 합집합 공리는 다음과 같이 정의되는 합집합의 존재성을 보장한다. $$ x \in A \lor x \in B \iff x \in A \cup B $$ 임의의 두 집합 $A$, $B$ 에 대해 적어도 둘 중 하나에 속하는 원소들의 집합을 $A$ 와 $B$ 의 합집합이라고 하고, $A \cup B$</description>
    </item>
    
    <item>
      <title>분류 공리꼴</title>
      <link>https://freshrimpsushi.github.io/axiom-schema-of-specification/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-schema-of-specification/</guid>
      <description>이관 대기 $$ \forall X \exists A \forall a \left( a \in A \iff ( a \in X \land p(a)) \right) $$ 임의의 집합 $X$ 에 대해 성질 $p$ 를 가지는 원소들로 이루어진 부분집합 $A$ 가 존재한다. * 여기서 $p(x)$ 는 $X$ 에서의 명제함수다. $A$ 를 $X$ 의 부분집합으로 한정하는 이유는 러셀의 역설과 같은 문제가 일어나는 것을 방지하기 위함이다. 공리가 아니라 공리꼴인 이유는 이 공리가 무수히 많은 $p(x)$ 에 따라 무수히 많이 존</description>
    </item>
    
    <item>
      <title>짝 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-union/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-union/</guid>
      <description>이관 대기 $$ \forall A \forall B \exists U ( a \in A \land b \in B ) $$ 임의의 두 집합 $A$, $B$ 에 대해 $A$ 와 $B$ 를 원소로 가지는 집합 $U$ 가 존재한다. 처음으로 짝 공리를 접하면 (사실 대부분의 공리를 접할 때는 거의 다 비슷하지만) 도대체 이런 공리가 왜 필요한지 의문이 들 수가 있다. 그런데 사실 짝 공리란 진정으로 집합이라는 개념을 수학의 영역으로 끌어올리는 역할을 한다고 말할 수 있</description>
    </item>
    
    <item>
      <title>공집합 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-empty-set/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-empty-set/</guid>
      <description>이관 대기 $$ \exists X \forall x \left( \lnot \left( x \in X \right) \right) $$ 어떤 원소도 가지지 않는 집합 $X$ 가 존재하고, 이 집합 $X$ 를 공집합이라고 정의한다. 공집합은 일반적으로 $\emptyset$ 과 같이 표기한다. 한편 공집합은 공집합은 원소의 개수가 $0$ 개인 집합으로도 볼 수 있는데, 이와 같이 원소의 개수로 정의할 수 있는 집합에는 다음과 같은 것들이 있다 : 1. Singletone Set : 원소의 개수가 단 하나인 집합을 홑</description>
    </item>
    
    <item>
      <title>외연 공리</title>
      <link>https://freshrimpsushi.github.io/axiom-of-extensionality/</link>
      <pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/axiom-of-extensionality/</guid>
      <description>이관 대기 $$ \forall A \forall B ( \forall x ( x \in A \iff x \in B) ) $$ 임의의 두 집합 $A$, $B$ 에 속한 원소가 같으면 두 집합이 같다고 하고 $A = B$ 와 같이 나타낸다. 한편 $A$ 와 $B$ 가 같지 않으면 $A \ne B$ 와 같이 나타낸다. 두 집합의 같음은 그 자체로 공리이자 정의다. Extensionality는 확장이 아니라 외연外延을 의미하는 것으로, 집합은 &amp;lsquo;어떠한 집합&amp;</description>
    </item>
    
    <item>
      <title>집합의 포함관계</title>
      <link>https://freshrimpsushi.github.io/subset-relation-of-sets/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/subset-relation-of-sets/</guid>
      <description>이관 대기 $$ A \subset B \iff \forall x (x\in A \implies x \in B) $$ 임의의 집합 $A$, $B$ 에 대하여 $A$ 의 모든 원소가 $B$ 의 원소일 때 $A$ 는 $B$ 의 부분집합Subset, $B$ 는 $A$ 의 초집합Superset이라고 하고 $A \subset B$ 와 같이 나타낸다. 한편 $A \subset B$ 인데 $B \not\subset A$ 이면 $A$ 를 $B$ 의 진부분집합Proper Subset이라고하고 $A \subsetneq B$ 와 같이 나타낸다. 사소한 주의사항으로, $A \subset B$</description>
    </item>
    
    <item>
      <title>명제함수의 한정규칙</title>
      <link>https://freshrimpsushi.github.io/quantification-rules/</link>
      <pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/quantification-rules/</guid>
      <description>이관 대기 전체집합 $U$ 의 명제함수 $P(x)$ 가 주어져있다고 하자. 1. Universal Quantifier : &amp;lsquo;모든 $x \in U$ 에 대하여&amp;rsquo;를 $\forall x$ 와 같이 쓰고 전칭기호라고 한다. 2. Existential Quantifier : &amp;lsquo;적어도 하나의 $x \in U$ 가 존재해서&amp;rsquo;를 $\exists x$ 와 같이 쓰고 존재기호라고 한다. 가령 자연수 집합 $\mathbb{N}$ 에 대해 논리식 $p(x)$ 가 &amp;lsquo;$x$ 는 $3$ 의 배수다&amp;rsquo;라면</description>
    </item>
    
    <item>
      <title>동적 프로그래밍</title>
      <link>https://freshrimpsushi.github.io/dynamic-programing/</link>
      <pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/dynamic-programing/</guid>
      <description>빌드업 문제를 풀 때, 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 최적 부분 구조Optimal Substructure를 가진다고 한다. 최적 부분 구조를 갖춘 문제의 예로써 가장 쉬운 것이 바로 피보나치 수를 구하는 것이다. $n$ 번째 피보나치 수는 $a_{n} = a_{n-1} + a_{n-2}$ 와 같이 구해지므로, 큰 문제 $a_{n}$ 에 작은 문제 $a_{n-1}$, $a_{n-2}$ 가 포함되어 있기 때문이다. 이</description>
    </item>
    
    <item>
      <title>집합과 명제함수의 정의</title>
      <link>https://freshrimpsushi.github.io/definition-of-set-and-propositional-function/</link>
      <pubDate>Fri, 04 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/definition-of-set-and-propositional-function/</guid>
      <description>이관 대기 1. Set : 우리의 직관 또는 사고의 대상으로써 서로 뚜렷이 구분되는 객체의 모임을 집합이라 한다. 2. Element : 집합에 속한 객체를 원소라고 한다. 3. Propositional Function : 집합 $U$ 의 원소 $x$ 에 대해 참이거나 거짓 둘 중 하나인 명제 $p(x)$ 를 $U$ 에서의 명제함수라고 한다. 1. 수학에서 집합은 거의 모국어 하나에 필적할만큼 중요한 개념이다. 어쩌면 자연어보다 나을 수도 있는 게, 필</description>
    </item>
    
    <item>
      <title>재귀함수를 쓸 때 주의해야하는 이유</title>
      <link>https://freshrimpsushi.github.io/why-we-care-recursive-function/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/why-we-care-recursive-function/</guid>
      <description>예시 프로그래밍을 처음 배우면 그것이 어떤 언어든지 &amp;lsquo;재귀함수는 조심해서 써야한다&amp;rsquo;는 경고가 함께한다. 사실 재귀함수라는 게 그렇게 빈번하게 사용되는 테크닉이 아니기 때문에 그 이유는 설명하지 않는 경우가 많은데, 배우는 입장에선 이 좋은 걸 왜 꺼리는지 이해가 잘 되지 않을 수 있다. 예시를 통해 알아보자. def fibo1(n) : if n==1 or n==2</description>
    </item>
    
    <item>
      <title>삼단논법의 수리논리적 증명</title>
      <link>https://freshrimpsushi.github.io/proof-of-syllogism/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/proof-of-syllogism/</guid>
      <description>이관 대기 $$ ( p \to q ) \land ( q \to r ) \implies p \to r $$ 삼단논법을 모르는 사람은 없고 굳이 설명해줄 것도 없다고 본다. 고대의 철학적 논쟁이 아닌 이상에야 굳이 &amp;lsquo;삼단논법에 의해&amp;rsquo;라는 말을 쓰는 경우는 흔치 않다. 그만큼 우리들에게는 익숙한 논법이자 보편타당한 원리기 때문이다. 하지만 삼단논법이 증명이 되는 것이고 증명을 해야</description>
    </item>
    
    <item>
      <title>수학적 귀납법</title>
      <link>https://freshrimpsushi.github.io/mathmatical-induction/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/mathmatical-induction/</guid>
      <description>이관 대기 명제 $p(n) (n=1,2,3, \cdots )$ 에 대해 $p(1)$ 이 참이고 $p(n)$ 을 가정했을 때 $p(n+1)$ 이 성립하면 $p(n)$ 은 참이다. 어떤 식이 자연수에 대해 성립할 때 특히 큰 위력을 발휘하는 증명법으로, 페아노 제5공리라고도 불리며 혹은 &amp;lsquo;수학적&amp;rsquo;이라는 말을 떼고 그냥 귀납법이라고도 한다. 본래 귀납법이란 현상이나 실체를 경험적으로 모아 어떤 결론을 내리는 것인데</description>
    </item>
    
    <item>
      <title>귀류법의 수리논리적 증명</title>
      <link>https://freshrimpsushi.github.io/proof-of-reductio-ad-absurdum/</link>
      <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/proof-of-reductio-ad-absurdum/</guid>
      <description>이관 대기 $$ (p \land \lnot q) \to c \iff p \to q $$ * 여기서 $c$ 는 모순을 의미한다. 배리법 혹은 귀류법은 수학 전반에서 정말 많이 사용되는 증명법이다. 하지만 처음 귀류법을 접하는 사람은 이게 단어부터 생소해서 거부감이 들 수 있다. 혹은 그냥 익숙해졌을 뿐, 왜 귀류법이 작동하는지 이해하지 못한 사람도 있을 것이다. 아래의 글을 읽어보면서 귀류법을 이해해보자: (1)</description>
    </item>
    
    <item>
      <title>대우법의 수리논리적 증명</title>
      <link>https://freshrimpsushi.github.io/proof-of-contrapositive-law/</link>
      <pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/proof-of-contrapositive-law/</guid>
      <description>이관 대기 $$ p \to q \iff \lnot q \to \lnot p $$ 어떤 명제가 참이면 그 대우도 참, 어떤 명제가 거짓이면 그 대우도 거짓이다. 물론 역Converse이 성립한다면 대우법에 의해서 원래 명제의 이Reverse도 성립한다. 이러한 표현들은 수학에 익숙하지 않은 사람들에겐 너무 어렵다. 예를 들어서 이해해보자 : $p$ : 날씨가 덥다 $q$ : 땀이 난다 $p \to q$ : 날씨가 더우</description>
    </item>
    
    <item>
      <title>드 모르간의 법칙 증명</title>
      <link>https://freshrimpsushi.github.io/proof-of-de-morgans-laws/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/proof-of-de-morgans-laws/</guid>
      <description>이관 대기 [1] 드 모르간의 법칙 : $$ \lnot (p \land q) \iff \lnot p \lor \lnot q \\ \lnot(p \lor q) \iff \lnot p \land \lnot q $$ [2] 드 모르간의 정리 : $$ (A \cup B)^{c} = A^{c} \cap B^{c} \\ (A \cap B)^{c} = A^{c} \cup B^{c} $$ 드 모르간의 법칙와 드 모르간의 정리는 각각 명제, 집합에 대한 정리지만 실제로 말을 하면서는 별로 구분하지 않는다. 법칙이든 정리든 **드 모르간-**만 붙으면 부정이나 여집합을 취하면 괄호 안의 명제, 집합</description>
    </item>
    
    <item>
      <title>항진 명제와 항위 명제</title>
      <link>https://freshrimpsushi.github.io/tautology-and-contradiction/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/tautology-and-contradiction/</guid>
      <description>이관 대기 모든 논리적 가능성에 대해 참인 명제를 항진 명제라고 한다. 모든 논리적 가능성에 대해 거짓인 명제를 항위 명제라고 한다. 실제로 항위 명제라는 단어는 거의 쓰이지 않으며, 그 대신 모순이라는 말을 많이 사용한다. 기호로는 항진 Tautology과 모순 Contradiction의 앞글자를 따서 항진 $t$, 모순 $c$ 와 같이 나타낸다. 위의 진리표</description>
    </item>
    
    <item>
      <title>명제와 결합자, 진리표</title>
      <link>https://freshrimpsushi.github.io/truth-table/</link>
      <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/truth-table/</guid>
      <description>이관 대기 참이거나 거짓이거나 둘 중 하나인 서술을 명제라고 한다. 명제는 참이거나 거짓 둘 중 하나의 진리값Truth Value을 가진다. 두 명제 $p$, $q$ 의 진리값이 같으면 $p$ 와 $q$ 가 (논리적) 동치(Logically) Equivalent라고 하고, $p \equiv q$ 와 같이 나타낸다. 다음을 결합자라고 한다. 1. 부정 : $\lnot$ 2. 논리곱 : $\land$ 3. 논리합 : $\lor$ 4.</description>
    </item>
    
    <item>
      <title>시간복잡도와 공간복잡도</title>
      <link>https://freshrimpsushi.github.io/time-complexity-and-space-complexity/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/time-complexity-and-space-complexity/</guid>
      <description>정의 주어진 문제를 풀 때의 걸리는 시간을 시간복잡도, 메모리 소요를 공간복잡도라고 한다. 예시 점근적 표기법은 이들을 표현하는데에 굉장히 유용한 수단이 된다. 시간복잡도에 대한 예시를 살펴보자. (0) 상수 시간 : $O(1)$ $n$ 에 관계없이 끝낼 수 있는 알고리즘으로, 사실상 시간이 걸리지 않는 것이다. 가령 $\mathbb{x} = [4,3,8,-1,-9,0,5,7,2,6]$ 에서 세번째 원소를 찾는 알고리즘은 $\mathbb{x}$ 가 어떻게</description>
    </item>
    
    <item>
      <title>알고리즘의 비용에 대한 점근적 표기법</title>
      <link>https://freshrimpsushi.github.io/asymptotic-notation-big-o/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/asymptotic-notation-big-o/</guid>
      <description>노테이션 크기가 $n$ 인 데이터에 대해 알고리즘의 비용을 다음과 같이 나타낸다. $O$ 표기법: $$ O(g(n)) := \left\{ f(n) , | , \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \le c g(n) \right\} $$ $\Omega$ 표기법: $$ \Omega (g(n)) := \left\{ f(n) , | , \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \ge c g(n) \right\} $$ $\Theta$ 표기법: $$ \Theta (g(n)) := O (g(n)) \cap \Omega (g(n)) $$ 설명 점근적 표기법은 알고리즘의 비용을 수리적으로 나타내는 것으로, 엡실론-델타 논</description>
    </item>
    
    <item>
      <title>베이즈 인자를 통한 가설검정</title>
      <link>https://freshrimpsushi.github.io/statistical-hypothesis-test-via-bayes-factor/</link>
      <pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/statistical-hypothesis-test-via-bayes-factor/</guid>
      <description>개요 고전적인 가설검정을 쓸 수 있게 되려면 기각역, 유의확률과 같은 개념에 대한 수학적인 이해를 포함해서 이를 직관적으로 받아들일 수 있을 정도의 통계학적 센스까지 갖추어야한다. 학부 1학년 교양 수준에서도 몇 시간이나 할애해가며 가르치고, 그래도 가설검정을 제대로 받아들이지 못하는 학생이 수두룩한 것도 당연한 일이다. 고등학교에서 배우는 통계</description>
    </item>
    
    <item>
      <title>최고사후밀도 신용구간</title>
      <link>https://freshrimpsushi.github.io/highst-posterior-density-credible-interval/</link>
      <pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/highst-posterior-density-credible-interval/</guid>
      <description>정의 모수공간 $\Theta$ 의 부분집합 $C \subset \Theta$ 가 유의수준 $\alpha$ 에 대해 $C : = \left\{ \theta \in \Theta , | , p ( \theta | y ) \ge k (\alpha) \right\} $ 를 자료 $y$ 가 주어졌을 때 $\theta$ 에 대한 $100(1 - \alpha) % $ 최고사후밀도 신용구간이라고 한다. 설명 여기서 $k(\alpha)$ 는 $p(\theta \in C | y ) \ge 1 - \alpha$ 를 만족하는 가장 큰 상수다. 수식과 말보다는 그림을 통해 보는게 훨씬 이해하기 좋다. 실제 계산에서도 위와 같이 $k$ 를 계속 바꿔</description>
    </item>
    
    <item>
      <title>신용구간과 신뢰구간의 차이</title>
      <link>https://freshrimpsushi.github.io/credible-interval-vs-confidence-interval/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/credible-interval-vs-confidence-interval/</guid>
      <description>요약 신용구간과 신뢰구간의 차이는 실로 베이지안과 프리퀀티스트의 차이라고 볼 수 있다. 신뢰구간(프리퀀티스트) : 모수는 고정된 상수고, 신뢰구간이 랜덤으로 구해진다. 신용구간(베이지안) : 모수도 분포를 가진 변수고, 신용구간도 사후분포로 구해진다. 신뢰구간 고전통계에서 모수 $\mu$ 에 대한 $95 %$ 신뢰구간 $[a , b]$ 이 의미하는 것은 같은 방법으</description>
    </item>
    
    <item>
      <title>신용구간</title>
      <link>https://freshrimpsushi.github.io/credible-interval/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/credible-interval/</guid>
      <description>정의 모수공간 $\Theta$ 의 부분집합 $C \subset \Theta$ 가 유의수준 $\alpha$ 에 대해 $P ( \theta \in C | y ) \ge 1 - \alpha$ 를 만족할 때, $C$ 를 자료 $y$ 가 주어졌을 때 $\theta$ 에 대한 $100(1 - \alpha) % $ 신용구간이라고 한다. 설명 베이지안에서의 구간추정이란 모수 $\theta$ 를 포함하는 확률이 높은 구간을 찾는 것이다. 이로써 찾아지는 &amp;lsquo;신용구간&amp;rsquo;이란 프리퀀티스트에게는 &amp;lsqu</description>
    </item>
    
    <item>
      <title>제프리 사전분포</title>
      <link>https://freshrimpsushi.github.io/jeffreys-prior/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/jeffreys-prior/</guid>
      <description>정의 자료의 분포 $p( y | \theta) $ 에 대해 $\pi ( \theta ) \propto I^{1/2} ( \theta )$ 를 제프리 사전분포Jeffreys Prior라고 한다. $I$ 는 피셔정보Fishser Information를 의미한다. $$ I ( \theta ) = E \left[ \left( \left. {{\partial \ln p (y | \theta) } \over {\partial \theta}} \right)^2 \right| \theta \right] = E \left[ \left. - {{\partial^2 \ln p (y | \theta) } \over { (\partial \theta )^2 }} \right| \theta \right] $$ 라플라스 사전분포 $\pi (\theta) \propto 1$ 는 모수 $\theta$ 의 사전분포로써는</description>
    </item>
    
    <item>
      <title>라플라스 사전분포</title>
      <link>https://freshrimpsushi.github.io/laplace-prior/</link>
      <pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/laplace-prior/</guid>
      <description>빌드업 모수에 대한 정보가 거의 없다면 구태여 복잡한 사전분포를 생각할 이유는 없다. 내년 모 대학의 통계학과 신입생의 성비를 추측해보라고 했을 때, 통계학과를 어느정도 아는 사람이라면 예년의 성비를 보고 어느정도 짐작을 하겠지만 전혀 관계도 없고 관심도 없는 사람이 이 질문을 들었을 땐 특별한 이유가 없는 한 50:50이라고 추측할 것이다. 어떤 주머니</description>
    </item>
    
    <item>
      <title>켤레사전분포</title>
      <link>https://freshrimpsushi.github.io/conjugate-prior/</link>
      <pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/conjugate-prior/</guid>
      <description>정의 사전분포와 사후분포가 동일한 분포족에 속하면 사전분포를 켤레사전분포라고 한다. 베이지안이란 본래 사전분포가 어떻게 되든 업데이트를 통해 모수를 찾아가는 것이긴 하지만, 모형에 대해 어느정도 아는 바가 있다면 적절한 사전분포를 사용함으로써 수학적 계산을 간단하게 하고 결과를 이해하기 쉽게 할 수 있다. 정리 [1] $\text{Bin} (n , \theta) $ 의 켤레사전분포는 $\theta</description>
    </item>
    
    <item>
      <title>라플라스 계승 법칙</title>
      <link>https://freshrimpsushi.github.io/laplaces-law-of-succession/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/laplaces-law-of-succession/</guid>
      <description>정리 이항모형 $\displaystyle p(y | \theta) = \pmatrix{ n \\ y} \theta^{y} (1- \theta)^{n-y}$ 의 사전분포가 균일분포 $U (0,1)$ 를 따르고 사후분포가 베타분포 $\beta (y+1 , n-y+1)$ 을 따라 $p( \theta | y ) \sim \theta^{y} (1- \theta)^{n-y} $ 이라고 하자. 그러면 이제까지 얻은 데이터 $y$ 에 대해 새로운 $\tilde{y}$ 가 $1$ 일 확률은 $$ p(\tilde{y} = 1| y) = {{y+1} \over {n+2}} $$ 프리퀀티스트의 관점으로 보았을 때 $\tilde{y} = 1$ 일 확률은 그 표본비율 $\displaystyle {{y} \over {n}}$ 에 가까울 것이다. 그런데 기본적으로 $n$</description>
    </item>
    
    <item>
      <title>베이지안 패러다임</title>
      <link>https://freshrimpsushi.github.io/bayesian-paradigm/</link>
      <pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/bayesian-paradigm/</guid>
      <description>빌드업 통계학이란 &amp;lsquo;모수를 파악하는 방법을 연구하는 학문&amp;rsquo;이라고 할 수 있다. 어떤 물리량을 측정하는 것처럼 공식이나 법칙을 통해 정확하게 모수를 추정할 수 있다면 더할나위 없지만, 현실적으로 그게 불가능하기 때문에 가정과 표본을 이용해 &amp;lsquo;모수로 예상되는 것&amp;rsquo;을 찾아낼 뿐이다. 우리나라 남성</description>
    </item>
    
    <item>
      <title>베이즈 정리로 보는 몬티홀 딜레마</title>
      <link>https://freshrimpsushi.github.io/monty-hall-dilemma/</link>
      <pubDate>Mon, 08 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/monty-hall-dilemma/</guid>
      <description>개요 알다시피 몬티홀 게임은 실제로 경품이 어디있든 관계 없이 선택을 바꾸는 것이 유리하다. 이것을 팩트로써 받아들이냐와 별개로 몬티홀 게임을 직관적으로 이해하지 못했거나 수식적인 표현이 서툰 사람들이 있다. 설명 편의상 본인이 플레이어고, 1번 문을 선택했다고 생각해보자. 문번호 사전확률 1 1/3 2 1/3 3 1/3 이 때 우리는 경품에 대한 어떤 정보도 없기에</description>
    </item>
    
    <item>
      <title>베이즈 정리 증명</title>
      <link>https://freshrimpsushi.github.io/proof-of-bayes-theorem/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/proof-of-bayes-theorem/</guid>
      <description>정리 표본공간 $S$ 와 사건 $A$ 에 대해서 ${S_1,S_2,&amp;hellip;,S_n}$ 가 $S$ 의 분할이면 $$ \displaystyle P(S_k|A)=\frac { P(S_k)P(A|S_k) }{ \sum _{ k=1 }^{ n }{ P(S_k)P(A|S_k) } } $$ 혹은 베이즈 법칙으로도 불리는 이 정리는 두개의 법칙만 쓰면 될 정도로 쉽게 증명할 수 있으나 그 응용은 어마어마하다. 이른바 베이지안 패러다임은 통계학 자체를 양분하는 사고방식으로써, 그 중요도는 몇 번을 강조해도 부족함이 없다. 우리가 알고 싶은 것은 위 식에서</description>
    </item>
    
    <item>
      <title>생새우초밥집</title>
      <link>https://freshrimpsushi.github.io/hugo-issue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freshrimpsushi.github.io/hugo-issue/</guid>
      <description>regal syntex in tex, but not rendered g(X) = \begin{cases} \text{argmin}{x \in X } | x | &amp;amp;, |X| &amp;lt; \infty \\ \text{argmin}{x \in X \cap \mathbb{Z}} |x| &amp;amp;, | X | = \infty \end{cases}: $$ g(X) = \begin{cases} \text{argmin}{x \in X } | x | &amp;amp;, |X| &amp;lt; \infty \\ \text{argmin}{x \in X \cap \mathbb{Z}} |x| &amp;amp;, | X | = \infty \end{cases} $$ regal syntex in tex $\text{argmin}$ 👈 This is a evidence of innocent &amp;lsquo;\text{argmin}&amp;rsquo; $$ g(X) = \begin{cases} _{x \in X } | x | &amp;amp;, |X| &amp;lt; \infty \\ _{x \in X \cap \mathbb{Z}} |x| &amp;amp;, | X | = \infty \end{cases}: $$ This is a evidence of innocent complement &amp;lsquo;\text{argmin}&amp;rsquo; 👆</description>
    </item>
    
  </channel>
</rss>
