<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>알고리즘 on 생새우초밥집</title><link>https://freshrimpsushi.github.io/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link><description>Recent content in 알고리즘 on 생새우초밥집</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Thu, 22 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://freshrimpsushi.github.io/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml"/><item><title>스탈린 정렬</title><link>https://freshrimpsushi.github.io/ko/posts/2268/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/2268/</guid><description>알고리즘 1 길이가 $n$ 인 배열이 주어져있다고 하자. 배열을 처음부터 뒤로 읽어가면서 뒤쪽이 앞쪽보다 크면 제거하는 것을 반복하면 &amp;lsquo;순서대로는&amp;rs</description></item><item><title>스미스-워터맨 정렬: 국소 서열 정렬</title><link>https://freshrimpsushi.github.io/ko/posts/2017/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/2017/</guid><description>개요 두 염기서열에서 가장 비슷한 부분의 정렬을 찾는 것을 국소 정렬local Alignment이라 하는데, 그 방법으로 가장 널리 쓰이는 스미스-워터맨 알고리</description></item><item><title>니들맨-분쉬 알고리즘: 전역 서열 정렬</title><link>https://freshrimpsushi.github.io/ko/posts/2012/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/2012/</guid><description>개요 두 염기서열의 공통 부분이 가장 많아지는 정렬을 찾는 것을 전역 정렬global Alignment이라 하는데, 그 방법으로 가장 널리 쓰이는 니들맨-분쉬 알</description></item><item><title>서열정렬 점수와 갭 페널티</title><link>https://freshrimpsushi.github.io/ko/posts/1878/</link><pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1878/</guid><description>정의 레퍼런스 서열과 쿼리 서열이 주어져 있다고 하자. 서열정렬 점수sequence Alignment Score란 두 서열을 비교했을 때 얼마나 일치하는지를 수치화하는 것과 그</description></item><item><title>서열정렬에서의 치환행렬</title><link>https://freshrimpsushi.github.io/ko/posts/1881/</link><pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1881/</guid><description>정의 서열정렬 점수를 매길 때 매치와 미스매치의 기준이 되는 행렬을 치환행렬substitution matrix이라 한다. 예시 using BioAlignments EDNAFULL BLOSUM45 PAM30 거두절미하고 예시</description></item><item><title>서열정렬이란?</title><link>https://freshrimpsushi.github.io/ko/posts/1874/</link><pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1874/</guid><description>정의 염기서열 간의 유사도를 근거로 나열하는 것을 서열정렬sequence Alignment이라 한다. 1 설명 생명정보공학에서 유전체의 길이는 무척 길기 때</description></item><item><title>문자열의 편집 거리</title><link>https://freshrimpsushi.github.io/ko/posts/1872/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1872/</guid><description>빌드업 1 문자열에는 다음과 같이 네가지 작용이 있다: 삽입: 문자열에 새로운 문자를 끼워넣는다. 제거: 문자열에서 문자 하나를 없앤다. 교체: 문자열에서 문자 하</description></item><item><title>생명정보공학에서의 유전체와 유전자</title><link>https://freshrimpsushi.github.io/ko/posts/1864/</link><pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1864/</guid><description>정의 한 개체의 염기서열을 모두 모은 것을 유전체genome라고 한다. 유전체의 일부를 차지하는 구간으로, 유전 형질의 단위가 되는 것을 유전자gene라고 한다</description></item><item><title>생명정보공학에서의 인트론과 엑손</title><link>https://freshrimpsushi.github.io/ko/posts/1862/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1862/</guid><description>정의 진핵 생물의 DNA에서 실제로 단백질의 합성에 관여하는 부분을 엑손exon, 그렇지 않은 부분을 인트론intron이라고 한다. 설명 원핵 생물과 진핵 생물</description></item><item><title>염기서열의 상류와 하류</title><link>https://freshrimpsushi.github.io/ko/posts/1855/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1855/</guid><description>빌드업 1 염기서열의 방향은 위의 그림처럼 오탄당의 탄소 원자 위치에 따라 번호를 부여함으로써 나타낼 수 있다. RNA와 DNA는 구체적으로 3번 탄소 $3&amp;rsq</description></item><item><title>생명정보공학에서의 코돈과 아미노산 유전 부호</title><link>https://freshrimpsushi.github.io/ko/posts/1852/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1852/</guid><description>정의 DNA의 염기 3개를 순서쌍으로 묶은 단위를 트리플렛 코드triplet Code라 한다. 센트럴 도그마에 따라 전사된 mRNA의 트리플렛 코드를 코돈co</description></item><item><title>분자생물학의 중심원리</title><link>https://freshrimpsushi.github.io/ko/posts/1850/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1850/</guid><description>원리 분자생물학의 중심원리 혹은 센트럴 도그마central dogma란 유전 정보는 DNA에서 RNA로, RNA에서 단백질로 전달된다는 가설로써 다음과 같</description></item><item><title>생명정보공학에서의 주요 염기와 염기쌍</title><link>https://freshrimpsushi.github.io/ko/posts/1832/</link><pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1832/</guid><description>정의 다음의 다섯가지 염기를 주요 염기canonical Base라고 한다. 퓨린 염기: 아데닌adenin $A$, 구아닌guanine $G$ 피리미딘 염기: 사이토</description></item><item><title>생명정보공학에서의 염기서열</title><link>https://freshrimpsushi.github.io/ko/posts/1828/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1828/</guid><description>빌드업 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체polymer라고 한다. 인산phosphoric Acid은 무기 산소산의 일종으로, 화</description></item><item><title>생명정보공학에서의 DNA, RNA, 염색체</title><link>https://freshrimpsushi.github.io/ko/posts/1827/</link><pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1827/</guid><description>빌드업 화학적 합성에 의해 단위체가 반복되어 연결된 고분자를 중합체polymer라고 한다. 인산phosphoric Acid은 무기 산소산의 일종으로, 화</description></item><item><title>생명정보공학에서의 원핵 생물과 진핵 생물</title><link>https://freshrimpsushi.github.io/ko/posts/1810/</link><pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1810/</guid><description>정의 핵막이 없는 생물을 원핵 생물prokaryotes이라 한다. 핵막이 있는 핵으로 이루어진 생물을 진핵 생물eukaryotes이라 한다. 설명 진핵 생물</description></item><item><title>그리디 알고리즘</title><link>https://freshrimpsushi.github.io/ko/posts/1434/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1434/</guid><description>정의 그리디 알고리즘 이란 어떤 선택을 할 때 그 순간만을 고려해서 가장 좋은 경우를 고르는 방법이다. 설명 그리드 알고리즘은 탐욕greed이라는 이름대로 길게 보지</description></item><item><title>레벤슈타인 알고리즘</title><link>https://freshrimpsushi.github.io/ko/posts/510/</link><pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/510/</guid><description>알고리즘 Input 문자열 $A,B$ 를 $A=[a_{i}]=(a_{1}, a_{2} , \cdots, a_{n})$ 과 $B=[b_{j}]=(b_{1}, b_{2} , \cdots, b_{m})$ 로 표현하자. Step 1. 초기화 행렬 $M_{(n+1) \times (m+1)} = [m_{x y }]$ 를 만들고 $M_{11} ← 0$ 을 대입한다. 그리고 $1$행과 $1$열을 다음과</description></item><item><title>기수 정렬</title><link>https://freshrimpsushi.github.io/ko/posts/1363/</link><pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1363/</guid><description>알고리즘 자리수가 $k$ 로 제한된 $n$ 개의 자연수로 이루어진 데이터가 주어져있다고 하자. 그러면 데이터는 다음의 알고리즘에 따라 정렬되며 그 시간 복잡도는 $O (n)$ 이다.</description></item><item><title>비교 정렬 알고리즘 시간 복잡도의 하한</title><link>https://freshrimpsushi.github.io/ko/posts/1359/</link><pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1359/</guid><description>정리 비교 정렬 알고리즘의 시간복잡도는 아무리 좋아도 $\Omega ( n \log n )$ 이다. 설명 알고리즘이 원래 신기한 것이지만, 삽입 정렬과 같은 효율적인 알고리즘도 퀵 정렬에 밀</description></item><item><title>비교 정렬 알고리즘들의 시간 복잡도</title><link>https://freshrimpsushi.github.io/ko/posts/1357/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1357/</guid><description>정리 $n$ 개의 데이터가 주어져 있을 때, 비교 정렬 알고리즘들의 시간 복잡도는 다음과 같다. [1] 버블 정렬: $$ \Theta ( n^2 ) \\ O ( n^2 ) $$ [2] 선택 정렬: $$ \Theta ( n^2 ) \\ O ( n^2</description></item><item><title>동적 프로그래밍</title><link>https://freshrimpsushi.github.io/ko/posts/1262/</link><pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1262/</guid><description>빌드업 문제를 풀 때, 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 최적 부분 구조optimal substructure를 가진다고 한다. 최적 부</description></item><item><title>재귀함수를 쓸 때 주의해야하는 이유</title><link>https://freshrimpsushi.github.io/ko/posts/1254/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1254/</guid><description>주의 프로그래밍을 처음 배우면 그것이 어떤 언어든지 &amp;lsquo;재귀함수는 조심해서 써야한다&amp;rsquo;는 경고가 함께한다. 사실 재귀함수라는 게 그렇게</description></item><item><title>시간복잡도와 공간복잡도</title><link>https://freshrimpsushi.github.io/ko/posts/1283/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1283/</guid><description>정의 주어진 문제를 풀 때의 걸리는 시간을 시간복잡도time complexity, 메모리 소요를 공간복잡도space complexity라고 한다. 예시 점근적 표기법은 이들을</description></item><item><title>알고리즘의 비용에 대한 점근적 표기법</title><link>https://freshrimpsushi.github.io/ko/posts/1281/</link><pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/1281/</guid><description>정의 크기가 $n$ 인 데이터에 대해 알고리즘의 비용을 다음과 같이 나타낸다. $O$ 표기법: $$ O(g(n)) := \left\{ f(n) \ | \ \exists c &amp;gt; 0, n_{0} \in \mathbb{N} : \forall n \ge n_{0} \implies f(n) \le c g(n) \right\} $$ $\Omega$ 표기법: $$ \Omega</description></item><item><title>지프의 법칙</title><link>https://freshrimpsushi.github.io/ko/posts/560/</link><pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/560/</guid><description>법칙 코퍼스에서 $k$ 번째로 자주 나타나는 단어의 상대빈도를 $f_{k}$ 라고 하면 $$ f_{k} = {{C} \over {k}} $$ 설명 여기서 $C$ 는 $\displaystyle \sum_{k} f_{k} = 1$ 이 되도록하는 정규화계수다. 히스토그램으로 나</description></item><item><title>힙스의 법칙</title><link>https://freshrimpsushi.github.io/ko/posts/559/</link><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/559/</guid><description>법칙 코퍼스에서 어휘의 갯수를 $M$, 토큰의 갯수를 $T$ 라고 하면 $$ M = kT^{b} $$ 설명 코퍼스가 영어일 경우 보통 상수 $k,b$ 는 $10 \le k \le 100$, 그리고 $b = 0.5$ 정도로 나타난다고 한다. 힙</description></item><item><title>n-그램과 자카드 계수</title><link>https://freshrimpsushi.github.io/ko/posts/525/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>https://freshrimpsushi.github.io/ko/posts/525/</guid><description>정의 n-그램n-gram이란 어떠한 문자열을 n개씩 끊어서 자른 것을 말한다. 자카드 계수jaccard coefficient란 두 집합이 얼마나 비슷한지</description></item></channel></rss>